include "exs/sequence_aux.csp"
include "exs/function_aux.csp"


maxbuff = 2
maxring = (maxbuff - 1)
Value = {0..2}
CellId = {1..2}
datatype Direction = req | ack
NatValue = {0..maxbuff}
--------------------------------
-- The universe of values
 datatype UNIVERSE = NAT.NatValue | CEL.CellId | VAL.Value

--------------------------------
--Conversions
subtype U_NAT = NAT.NatValue
subtype U_CEL = CEL.CellId
subtype U_VAL = VAL.Value


valueNAT(NAT.v) = v
valueCEL(CEL.v) = v
valueVAL(VAL.v) = v


typeNAT(x) = U_NAT
typeCEL(x) = U_CEL
typeVAL(x) = U_VAL


tagNAT(x) = NAT
tagCEL(x) = CEL
tagVAL(x) = VAL


--------------------------------
-- MEMORY
--------------------------------
Memory(b_NAT, b_CEL, b_VAL) = 
	([] n:dom(b_NAT) @ mget.n!(apply(b_NAT,n)) -> Memory(b_NAT, b_CEL, b_VAL))
	[] ([] n:dom(b_CEL) @ mget.n!(apply(b_CEL,n)) -> Memory(b_NAT, b_CEL, b_VAL))
	[] ([] n:dom(b_VAL) @ mget.n!(apply(b_VAL,n)) -> Memory(b_NAT, b_CEL, b_VAL))
	[] ([] n:dom(b_NAT) @ mset.n?x:typeNAT(n) -> Memory(over(b_NAT,n,x),b_CEL,b_VAL))
	[] ([] n:dom(b_CEL) @ mset.n?x:typeCEL(n) -> Memory(b_NAT,over(b_CEL,n,x),b_VAL))
	[] ([] n:dom(b_VAL) @ mset.n?x:typeVAL(n) -> Memory(b_NAT,b_CEL,over(b_VAL,n,x)))
		[] terminate -> SKIP

Memorise(P,b_NAT, b_CEL, b_VAL) = 
    ((P; terminate -> SKIP) [| MEM_I |] Memory(b_NAT, b_CEL, b_VAL)) \ MEM_I

datatype NAME = sv_Controller_cache_U_VAL | sv_Controller_size_U_NAT | sv_Controller_top_U_CEL | sv_Controller_bot_U_CEL | sv_RingCell_v_U_VAL
subtype NAME_NAT = sv_Controller_size_U_NAT
subtype NAME_CEL = sv_Controller_top_U_CEL | sv_Controller_bot_U_CEL
subtype NAME_VAL = sv_Controller_cache_U_VAL | sv_RingCell_v_U_VAL
--------------------------------
-- All possible bidings

NAMES_VALUES_NAT = seq({seq({(n,v) | v <- typeNAT(n)}) | n <- NAME_NAT})
NAMES_VALUES_CEL = seq({seq({(n,v) | v <- typeCEL(n)}) | n <- NAME_CEL})
NAMES_VALUES_VAL = seq({seq({(n,v) | v <- typeVAL(n)}) | n <- NAME_VAL})

BINDINGS_NAT = {set(b) | b <- set(distCartProd(NAMES_VALUES_NAT))}
BINDINGS_CEL = {set(b) | b <- set(distCartProd(NAMES_VALUES_CEL))}
BINDINGS_VAL = {set(b) | b <- set(distCartProd(NAMES_VALUES_VAL))}

channel mget, mset : NAME.UNIVERSE
channel terminate
MEM_I = {| mset,mget,terminate |}

DBuffer = ( ( ControllerR [| CtrI |] DRing ) \ CtrI )

ControllerR = Controller[[read <- rdi, write <- wrti]]

Controller = 
	(let 		restrictNAT(bs) = dres(bs,{sv_Controller_size_U_NAT})
		restrictCEL(bs) = dres(bs,{sv_Controller_top_U_CEL, sv_Controller_bot_U_CEL})
		restrictVAL(bs) = dres(bs,{sv_Controller_cache_U_VAL, sv_RingCell_v_U_VAL})
	within
		|~| b_NAT : BINDINGS_NAT, b_CEL : BINDINGS_CEL, b_VAL : BINDINGS_VAL @ Memorise(( mget.sv_Controller_cache_U_VAL?v_sv_Controller_cache_U_VAL:(typeVAL(sv_Controller_cache_U_VAL)) -> mget.sv_Controller_size_U_NAT?v_sv_Controller_size_U_NAT:(typeNAT(sv_Controller_size_U_NAT)) -> mget.sv_Controller_top_U_CEL?v_sv_Controller_top_U_CEL:(typeCEL(sv_Controller_top_U_CEL)) -> mget.sv_Controller_bot_U_CEL?v_sv_Controller_bot_U_CEL:(typeCEL(sv_Controller_bot_U_CEL)) -> mset.sv_Controller_cache_U_VAL.(VAL.0) -> mset.sv_Controller_size_U_NAT.(NAT.0) -> mset.sv_Controller_top_U_CEL.(CEL.1) -> mset.sv_Controller_bot_U_CEL.(CEL.1) -> SKIP ; ( let X = ( mget.sv_Controller_top_U_CEL?v_sv_Controller_top_U_CEL:(typeCEL(sv_Controller_top_U_CEL)) -> mget.sv_Controller_cache_U_VAL?v_sv_Controller_cache_U_VAL:(typeVAL(sv_Controller_cache_U_VAL)) -> mget.sv_Controller_bot_U_CEL?v_sv_Controller_bot_U_CEL:(typeCEL(sv_Controller_bot_U_CEL)) -> mget.sv_Controller_size_U_NAT?v_sv_Controller_size_U_NAT:(typeNAT(sv_Controller_size_U_NAT)) -> ( ( valueNAT(v_sv_Controller_size_U_NAT) < maxbuff & input?x -> ( ( valueNAT(v_sv_Controller_size_U_NAT) == 0 & mset.sv_Controller_cache_U_VAL.(VAL.x) -> mget.sv_Controller_size_U_NAT?v_sv_Controller_size_U_NAT:(typeNAT(sv_Controller_size_U_NAT)) -> mset.sv_Controller_size_U_NAT.(NAT.1) -> SKIP ) [] ( valueNAT(v_sv_Controller_size_U_NAT) > 0 & write.valueCEL(v_sv_Controller_top_U_CEL).req.x -> write.valueCEL(v_sv_Controller_top_U_CEL).ack?dumb -> mset.sv_Controller_size_U_NAT.(NAT.(valueNAT(v_sv_Controller_size_U_NAT) + 1)) -> mget.sv_Controller_top_U_CEL?v_sv_Controller_top_U_CEL:(typeCEL(sv_Controller_top_U_CEL)) -> mset.sv_Controller_top_U_CEL.(CEL.(valueCEL(v_sv_Controller_top_U_CEL) % maxring + 1)) -> SKIP )) ) [] ( valueNAT(v_sv_Controller_size_U_NAT) > 0 & output.valueVAL(v_sv_Controller_cache_U_VAL) -> ( ( valueNAT(v_sv_Controller_size_U_NAT) > 1 & 
			( ( |~| dumb : Value @ 
				read.valueCEL(v_sv_Controller_bot_U_CEL).req.dumb -> 
				read.valueCEL(v_sv_Controller_bot_U_CEL).ack?x -> 
				mset.sv_Controller_cache_U_VAL.(VAL.x) -> mset.sv_Controller_size_U_NAT.(NAT.(valueNAT(v_sv_Controller_size_U_NAT) - 1)) -> SKIP ; mget.sv_Controller_bot_U_CEL?v_sv_Controller_bot_U_CEL:(typeCEL(sv_Controller_bot_U_CEL)) -> mset.sv_Controller_bot_U_CEL.(CEL.(valueCEL(v_sv_Controller_bot_U_CEL) % maxring + 1)) -> SKIP ) ) 
		) [] ( valueNAT(v_sv_Controller_size_U_NAT) == 1 & mset.sv_Controller_size_U_NAT.(NAT.0) -> SKIP )) )) ; X ) within X ) ), restrictNAT(b_NAT), restrictCEL(b_CEL), restrictVAL(b_VAL))
)

DRing = |||i : CellId @ IRCell(i)

IRCell(i) = RingCell[[rrd <- rdi.i, wrt <- wrti.i]]

RingCell = 
	(let 		restrictNAT(bs) = dres(bs,{sv_Controller_size_U_NAT})
		restrictCEL(bs) = dres(bs,{sv_Controller_top_U_CEL, sv_Controller_bot_U_CEL})
		restrictVAL(bs) = dres(bs,{sv_Controller_cache_U_VAL, sv_RingCell_v_U_VAL})
	within
		|~| b_NAT : BINDINGS_NAT, b_CEL : BINDINGS_CEL, b_VAL : BINDINGS_VAL @ Memorise(( ( |~| x : Value @ mget.sv_RingCell_v_U_VAL?v_sv_RingCell_v_U_VAL:(typeVAL(sv_RingCell_v_U_VAL)) -> mset.sv_RingCell_v_U_VAL.(VAL.x) -> SKIP ) ; ( let X = ( mget.sv_RingCell_v_U_VAL?v_sv_RingCell_v_U_VAL:(typeVAL(sv_RingCell_v_U_VAL)) -> ( wrt.req?x -> mset.sv_RingCell_v_U_VAL.(VAL.x) -> wrt.ack.x -> SKIP [] rrd.req?dumb -> rrd.ack.valueVAL(v_sv_RingCell_v_U_VAL) -> SKIP) ; X ) within X ) ), restrictNAT(b_NAT), restrictCEL(b_CEL), restrictVAL(b_VAL))
)
CtrI = {| rdi,wrti |}
channel rrd, wrt : Direction.Value
channel write, read, rdi, wrti : CellId.Direction.Value
channel input, output : Value

--------------------------------
-- THE ABSTRACT BUFFER
--------------------------------

-- It takes its inputs and supplies its outputs on two different
-- typed channels.

ABuffer =
  let BufferState(s)= #s > 0 & output!head(s) -> BufferState(tail(s))
                      []
                      #s < maxbuff & input?x -> BufferState(s ^ <x>)

  within
    BufferState(<>)

--------------------------------
-- THE RING BUFFER
--------------------------------
MemoryControllerR = Controller[[ read <- rdi, write <- wrti]]
MemoryDBuffer = (MemoryControllerR [| {| rdi, wrti |} |] DRing) \ {| rdi, wrti |}

--------------------------------
-- VERIFICATION
--------------------------------
assert ABuffer [FD= MemoryDBuffer
assert MemoryDBuffer [FD= ABuffer