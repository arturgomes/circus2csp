include "sequence_aux.csp"
include "function_aux.csp"


--------------------------------
-- The universe of values
 datatype UNIVERSE = Nat.NatValue
 NatValueMax = 4
NatValue = {0..NatValueMax}

--------------------------------
--Conversions
subtype U_NAT = Nat.NatValue

value(Nat.v) = v

type(x) =
	 if x == sv_SysClock2_time then U_NAT
	 else {}

tag(x) =
	 if x == sv_SysClock2_time then Nat
	 else Nat


--------------------------------
-- MEMORY
--------------------------------
Memory(b) =
   ([] n:dom(b) @ mget.n!(apply(b,n)) -> Memory(b))
   [] ([] n:dom(b) @ mset.n?x:type(n) -> Memory(over(b,n,x)))
   [] terminate -> SKIP

Memorise(P, b) = 
    ((P; terminate -> SKIP) [| MEM_I |] Memory(b)) \ MEM_I

datatype NAME = sv_SysClock2_time
--------------------------------
-- All possible bidings
NAMES_VALUES = seq({seq({(n,v) | v <- type(n)}) | n <- NAME})
BINDINGS = {set(b) | b <- set(distCartProd(NAMES_VALUES))}

channel mget, mset : NAME.UNIVERSE
channel terminate
MEM_I = {| mset,mget,terminate |}

MakeTick = 
	tick -> SKIP

SysClock2 = 
	( let restrict(bs) = dres(bs,{sv_SysClock2_time})
		within
		|~| b:BINDINGS @ Memorise(( mget.sv_SysClock2_time?v_sv_SysClock2_time:(type(sv_SysClock2_time)) -> mset.sv_SysClock2_time.((tag(sv_SysClock2_time)).0) -> SKIP ; ( let X = ( mget.sv_SysClock2_time?v_sv_SysClock2_time:(type(sv_SysClock2_time)) -> (value(v_sv_SysClock2_time) <= 3 & SKIP [] value(v_sv_SysClock2_time) <= 2 & ( tick -> mset.sv_SysClock2_time.((tag(sv_SysClock2_time)).(1 + value(v_sv_SysClock2_time))) -> SKIP ||| getCurrentTime.value(v_sv_SysClock2_time) -> SKIP ) [] value(v_sv_SysClock2_time) > 2 & mset.sv_SysClock2_time.((tag(sv_SysClock2_time)).0) -> SKIP) ; X ) within X ) ), restrict(b))
)
channel tick
channel getCurrentTime : NatValue

Clock = 
  (SysClock2 \ {|mget,mset,terminate,getCurrentTime|}) 
  -- [| {|tick|} |] MakeTick 

assert Clock [FD= MakeTick
