include "sequence_aux.csp"
include "function_aux.csp"


datatype SWITCH = ON | OFF
datatype STATUS = START | RUNNING | IDLE | INTERRUPT
NatValue = {0..3}
SWITCHPARA = (SWITCH,NatValue)
--------------------------------
-- The universe of values
 datatype UNIVERSE = NAT.NatValue | SWI.SWITCHPARA | PST.Set(STATUS)

--------------------------------
--Conversions
subtype U_NAT = NAT.NatValue
subtype U_SWI = SWI.SWITCHPARA
subtype U_PST = PST.Set(STATUS)

valueNAT(NAT.v) = v
valueSWI(SWI.v) = v
valuePST(PST.v) = v

typeNAT(x) = U_NAT
typeSWI(x) = U_SWI
typePST(x) = U_PST

tagNAT(x) = NAT
tagSWI(x) = SWI
tagPST(x) = PST


--------------------------------
-- MEMORY
--------------------------------
Memory(b1,b2,b3) =
   ([] n:dom(b1) @ mget.n!(apply(b1,n)) -> Memory(b1,b2,b3))
   []  ([] n:dom(b2) @ mget.n!(apply(b2,n)) -> Memory(b1,b2,b3))
   []  ([] n:dom(b3) @ mget.n!(apply(b3,n)) -> Memory(b1,b2,b3))
   [] ([] n:dom(b1) @ mset.n?x:typeNAT(n) -> Memory(over(b1,n,x),b2,b3))
   [] ([] n:dom(b2) @ mset.n?x:typeSWI(n) -> Memory(b1,over(b2,n,x),b3))
   [] ([] n:dom(b3) @ mset.n?x:typePST(n) -> Memory(b1,b2,over(b3,n,x)))
   [] terminate -> SKIP

Memorise(P, b1,b2,b3) = 
    ((P; terminate -> SKIP) [| MEM_I |] Memory(b1,b2,b3)) \ MEM_I


datatype NAME = 
  sv_SysCmd_time_U_NAT | sv_SysCmd_swi_U_SWI | sv_SysCmd_phase_U_PST
subtype NAME_NAT = sv_SysCmd_time_U_NAT
subtype NAME_SWI = sv_SysCmd_swi_U_SWI
subtype NAME_PST = sv_SysCmd_phase_U_PST
--------------------------------
-- All possible bidings
NAMES_VALUES_NAT = seq({seq({(n,v) | v <- typeNAT(n)}) | n <- NAME_NAT})
NAMES_VALUES_SWI = seq({seq({(n,v) | v <- typeSWI(n)}) | n <- NAME_SWI})
NAMES_VALUES_PST = seq({seq({(n,v) | v <- typePST(n)}) | n <- NAME_PST})
BINDINGS_NAT = {set(b) | b <- set(distCartProd(NAMES_VALUES_NAT))}
BINDINGS_SWI = {set(b) | b <- set(distCartProd(NAMES_VALUES_SWI))}
BINDINGS_PST = {set(b) | b <- set(distCartProd(NAMES_VALUES_PST))}

channel mget, mset : NAME.UNIVERSE
channel terminate
MEM_I = {| mset,mget,terminate |}

MakeTick = 
	tick -> SKIP

SysCmd = 
	( let restrictNAT(bs) = dres(bs,{sv_SysCmd_time_U_NAT})
        restrictSWI(bs) = dres(bs,{sv_SysCmd_swi_U_SWI})
        restrictPST(bs) = dres(bs,{sv_SysCmd_phase_U_PST})
		within
		|~| b1:BINDINGS_NAT, b2:BINDINGS_SWI,b3:BINDINGS_PST @ Memorise(start -> 
      ( mget.sv_SysCmd_swi_U_SWI?v_sv_SysCmd_swi_U_SWI:(typeSWI(sv_SysCmd_swi_U_SWI)) -> 
        mget.sv_SysCmd_time_U_NAT?v_sv_SysCmd_time_U_NAT:(typeNAT(sv_SysCmd_time_U_NAT)) -> 
        mget.sv_SysCmd_phase_U_PST?v_sv_SysCmd_phase_U_PST:(typePST(sv_SysCmd_phase_U_PST)) -> 
        mset.sv_SysCmd_swi_U_SWI.(SWI.(ON,0)) -> 
        mset.sv_SysCmd_time_U_NAT.(NAT.0) -> 
        mset.sv_SysCmd_phase_U_PST.(PST.{START}) -> SKIP ;
        mget.sv_SysCmd_time_U_NAT?v_sv_SysCmd_time_U_NAT:(typeNAT(sv_SysCmd_time_U_NAT)) -> 
        (let XClock = (valueNAT(v_sv_SysCmd_time_U_NAT) <= 2 & 
                   ( ( tick -> 
                     mset.sv_SysCmd_time_U_NAT.(NAT.(valueNAT(v_sv_SysCmd_time_U_NAT) + 1)) -> 
                     mset.sv_SysCmd_phase_U_PST.(PST.{RUNNING,IDLE}) -> SKIP 
                     ||| getCurrentTime.valueNAT(v_sv_SysCmd_time_U_NAT) -> SKIP ) ; XClock )
                   [] valueNAT(v_sv_SysCmd_time_U_NAT) > 2 & 
                     ( mset.sv_SysCmd_time_U_NAT.(NAT.0) -> 
                     mset.sv_SysCmd_swi_U_SWI.(SWI.(OFF,1)) -> 
                     mset.sv_SysCmd_phase_U_PST.(PST.{INTERRUPT}) -> SKIP ; 
                     stop -> SKIP )) ; XClock within XClock) ), restrictNAT(b1), restrictSWI(b2), restrictPST(b3))
)
channel tick
channel getCurrentTime : NatValue
channel start, stop


Clock = 
  (SysCmd \ {|mget,mset,terminate,getCurrentTime|}) 
  [| {|tick|} |] MakeTick 

assert Clock [FD= MakeTick