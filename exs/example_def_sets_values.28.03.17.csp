-- 30/03/2017
-- Artur Gomes

-- I'm committing this so I can see what I left before pausing my work 
-- so I can take care of my family.

-- This should be an example of the new translation from HCircus to CSP
-- where we define bindings and its functions for each type defined 
-- in the spec.

include "sequence_aux.csp"
include "function_aux.csp"


datatype SWITCH = ON | OFF
datatype STATUS = START | RUNNING | IDLE | INTERRUPT
NatValue = {0..3}

-- You need to see this with care, as 
-- the translator makes use of the name variables, instead of the types.

SWITCHPARA = (SWITCH,NatValue) 
--------------------------------
-- The universe of values
 datatype UNIVERSE = NAT.NatValue | SWI.SWITCHPARA | PST.Set(STATUS)

--------------------------------
--Conversions
subtype U_NAT = NAT.NatValue
subtype U_SWI = SWI.SWITCHPARA
subtype U_PST = PST.Set(STATUS)


-- We first must define function value for each type within the spec
valueNAT(NAT.v) = v
valueSWI(SWI.v) = v
valuePST(PST.v) = v

-- We first must define function type for each type within the spec
typeNAT(x) = U_NAT
typeSWI(x) = U_SWI
typePST(x) = U_PST

-- We first must define function tag for each type within the spec
tagNAT(x) = NAT
tagSWI(x) = SWI
tagPST(x) = PST


--------------------------------
-- MEMORY
--------------------------------
-- then we must define a parametrised Memory function with bindings for each of the types, like b1, b2, b3.
Memory(b1,b2,b3) =
   ([] n:dom(b1) @ mget.n!(apply(b1,n)) -> Memory(b1,b2,b3))
   []  ([] n:dom(b2) @ mget.n!(apply(b2,n)) -> Memory(b1,b2,b3))
   []  ([] n:dom(b3) @ mget.n!(apply(b3,n)) -> Memory(b1,b2,b3))
   -- then make gets and sets for each of the b1, b2, b3, accordingly.
   [] ([] n:dom(b1) @ mset.n?x:typeNAT(n) -> Memory(over(b1,n,x),b2,b3))
   [] ([] n:dom(b2) @ mset.n?x:typeSWI(n) -> Memory(b1,over(b2,n,x),b3))
   [] ([] n:dom(b3) @ mset.n?x:typePST(n) -> Memory(b1,b2,over(b3,n,x)))
   [] terminate -> SKIP

-- and update the memorise function.
Memorise(P, b1,b2,b3) = 
    ((P; terminate -> SKIP) [| MEM_I |] Memory(b1,b2,b3)) \ MEM_I


-- Next, we define a datatype name with all names, but we also define
-- subtypes for each of the types, so we can then, below, match every bindings for each NAME x VALUE (regarding specific types)
datatype NAME = 
  sv_SysCmd_time_U_NAT | sv_SysCmd_swi_U_SWI | sv_SysCmd_phase_U_PST
subtype NAME_NAT = sv_SysCmd_time_U_NAT
subtype NAME_SWI = sv_SysCmd_swi_U_SWI
subtype NAME_PST = sv_SysCmd_phase_U_PST
--------------------------------
-- All possible bidings
NAMES_VALUES_NAT = seq({seq({(n,v) | v <- typeNAT(n)}) | n <- NAME_NAT})
NAMES_VALUES_SWI = seq({seq({(n,v) | v <- typeSWI(n)}) | n <- NAME_SWI})
NAMES_VALUES_PST = seq({seq({(n,v) | v <- typePST(n)}) | n <- NAME_PST})
BINDINGS_NAT = {set(b) | b <- set(distCartProd(NAMES_VALUES_NAT))}
BINDINGS_SWI = {set(b) | b <- set(distCartProd(NAMES_VALUES_SWI))}
BINDINGS_PST = {set(b) | b <- set(distCartProd(NAMES_VALUES_PST))}

channel mget, mset : NAME.UNIVERSE
channel terminate
MEM_I = {| mset,mget,terminate |}

MakeTick = 
	tick -> MakeTick

SysCmd = 
  -- then we define restrict functions for variables of each type.
	( let restrictNAT(bs) = dres(bs,{sv_SysCmd_time_U_NAT})
        restrictSWI(bs) = dres(bs,{sv_SysCmd_swi_U_SWI})
        restrictPST(bs) = dres(bs,{sv_SysCmd_phase_U_PST})
		within

    -- as well as BINDINGS for each type and then the main action works
    -- accordingly to the translated spec.
		|~| b1:BINDINGS_NAT, b2:BINDINGS_SWI,b3:BINDINGS_PST @ Memorise(start -> 
      ( mget.sv_SysCmd_swi_U_SWI?v_sv_SysCmd_swi_U_SWI:(typeSWI(sv_SysCmd_swi_U_SWI)) -> 
        mget.sv_SysCmd_time_U_NAT?v_sv_SysCmd_time_U_NAT:(typeNAT(sv_SysCmd_time_U_NAT)) -> 
        mget.sv_SysCmd_phase_U_PST?v_sv_SysCmd_phase_U_PST:(typePST(sv_SysCmd_phase_U_PST)) -> 
        mset.sv_SysCmd_swi_U_SWI.(SWI.(ON,0)) -> 
        mset.sv_SysCmd_time_U_NAT.(NAT.0) -> 
        mset.sv_SysCmd_phase_U_PST.(PST.{START}) -> SKIP ;
        mget.sv_SysCmd_time_U_NAT?v_sv_SysCmd_time_U_NAT:(typeNAT(sv_SysCmd_time_U_NAT)) -> 
        (let XClock = (valueNAT(v_sv_SysCmd_time_U_NAT) <= 2 & 
                   ( ( tick -> 
                     mset.sv_SysCmd_time_U_NAT.(NAT.(valueNAT(v_sv_SysCmd_time_U_NAT) + 1)) -> 
                     mset.sv_SysCmd_phase_U_PST.(PST.{RUNNING,IDLE}) ->  XClock )
                   [] valueNAT(v_sv_SysCmd_time_U_NAT) > 2 & 
                     ( mset.sv_SysCmd_time_U_NAT.(NAT.0) -> 
                     mset.sv_SysCmd_swi_U_SWI.(SWI.(OFF,1)) -> 
                     mset.sv_SysCmd_phase_U_PST.(PST.{INTERRUPT}) -> SKIP ; 
                     stop -> XClock ))) within XClock) ), restrictNAT(b1), restrictSWI(b2), restrictPST(b3))
)
channel tick
channel getCurrentTime : NatValue
channel start, stop


Clock = 
  (SysCmd \ {|mget,mset,terminate,getCurrentTime,start,stop|}) 
  [| {|tick|} |] MakeTick 

assert Clock [FD= MakeTick

MyHDMACHINE = let X = Clock; X within X
assert MyHDMACHINE :[ deadlock free [FD] ]
assert Clock :[ livelock free ]
assert Clock :[ deterministic [F] ]
