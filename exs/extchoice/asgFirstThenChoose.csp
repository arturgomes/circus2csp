include "sequence_aux.csp"
include "function_aux.csp"


RANGE = {0..2}
channel a, b
--------------------------------
-- The universe of values
 datatype UNIVERSE = RAN.RANGE
--Conversions
valueRAN(RAN.v) = v

typeRAN(x) = U_RAN

tagRAN(x) = RAN

-- subtypes of UNIVERSE for RAN
subtype U_RAN = RAN.RANGE

-- definition of NAME for the entire spec
datatype NAME = sv_x | sv_y

-- Subtype definition for RAN
b_RAN1 = {(sv_x, RAN.0),(sv_y, RAN.0)}
subtype NAME_RAN = sv_x | sv_y



--------------------------------
 -- mget, mset and terminate --
--------------------------------
channel mget, mset : NAME.UNIVERSE
channel terminate

--------------------------------
 -- MEMI --
--------------------------------
MEMI = {| mset,mget,terminate |}
channel lget, lset : NAME.UNIVERSE
channel lterminate
MEML = {| lset,lget,lterminate |}

ACF(b_RAN) =
  let
     Memory(b_RAN) =
      ( ( ( [] n : dom(b_RAN) @ mget.n.apply(b_RAN,n) -> Memory(b_RAN) )
      [] ( [] n : dom(b_RAN) @ mset.n?nv:typeRAN(n) -> Memory(over(b_RAN,n,nv)) ))
      [] terminate -> SKIP)

     MemoryMerge(b_RAN,ns) =
      ( ( ( [] n : dom(b_RAN) @ lget.n.apply(b_RAN,n) -> MemoryMerge(b_RAN,ns) )
      [] ( [] n : dom(b_RAN) @ lset.n?nv:typeRAN(n) -> MemoryMerge(over(b_RAN,n,nv),ns) ))
      [] lterminate -> (  ; bd : <b_RAN> @   ; n : <y | y <- ns> @  mset.n.apply(bd,n) -> SKIP ))
  within
     let  restrictRAN(bs) = dres(bs,{sv_x, sv_y})
     within( ( (
      ( ( ( ( ( a -> lset.sv_x.(RAN.1) -> SKIP [] b -> lset.sv_y.(RAN.1) -> SKIP); lterminate -> SKIP )
      [| MEML |] MemoryMerge({(sv_x,(RAN.1)),(sv_y,(RAN.1))},<sv_x,sv_y>) ) \ MEML )
      [| {| a,b |} |]
      ( ( ( ( a -> lset.sv_y.(RAN.1) -> SKIP [] b -> lset.sv_x.(RAN.1) -> SKIP); lterminate -> SKIP )
      [| MEML |]  MemoryMerge({(sv_x,(RAN.1)),(sv_y,(RAN.1))},<sv_x,sv_y>) ) \ MEML ) );
      terminate -> SKIP )
      [| MEMI |] Memory(restrictRAN(b_RAN)))\MEMI )


AC2(b_RAN) =
  let
     Memory(b_RAN) =
        ( ( ( [] n : dom(b_RAN) @ mget.n.apply(b_RAN,n) ->
      Memory(b_RAN) )
      [] ( [] n : dom(b_RAN) @ mset.n?nv:typeRAN(n) ->
      Memory(over(b_RAN,n,nv)) ))
      [] terminate -> SKIP)
  within
     let  restrictRAN(bs) = dres(bs,{sv_x, sv_y})
     within( ( ( mget.sv_x?v_sv_x:(typeRAN(sv_x)) ->
      ( a ->
      mset.sv_x.(RAN.1) -> SKIP
      [] b ->
      mset.sv_y.(RAN.1) -> SKIP);
      terminate -> SKIP )
      [| MEMI |] Memory(restrictRAN(b_RAN)))\MEMI )


AC1(b_RAN) =
  let
     Memory(b_RAN) =
        ( ( ( [] n : dom(b_RAN) @ mget.n.apply(b_RAN,n) ->
      Memory(b_RAN) )
      [] ( [] n : dom(b_RAN) @ mset.n?nv:typeRAN(n) ->
      Memory(over(b_RAN,n,nv)) ))
      [] terminate -> SKIP)
  within
     let  restrictRAN(bs) = dres(bs,{sv_x, sv_y})
     within( ( (
      ( a -> mset.sv_x.(RAN.1) -> SKIP [] b -> mset.sv_y.(RAN.2) -> SKIP); terminate -> SKIP )
      [| MEMI |] Memory(restrictRAN(b_RAN)))\MEMI )
