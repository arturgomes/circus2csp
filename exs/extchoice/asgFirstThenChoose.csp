include "sequence_aux.csp"
include "function_aux.csp"


RANGE = {0..2}
channel a, c
channel a1, b1 : RANGE

P(b) =
  let
     Memory(b) =
        ( ( ( [] n : dom(b) @ mget.n.apply(b,n) ->
      Memory(b) )
      [] ( [] n : dom(b) @ mset.n?nv:typeRAN(n) ->
      Memory(over(b,n,nv)) ))
      [] terminate -> SKIP)

  within ( ( ( SKIP;
      terminate -> SKIP )
      [| MEMI |] Memory(b))\MEMI )
--------------------------------
-- The universe of values
 datatype UNIVERSE = RAN.RANGE
--Conversions
valueRAN(RAN.v) = v

typeRAN(x) = U_RAN

tagRAN(x) = RAN

-- subtypes of UNIVERSE for RAN
subtype U_RAN = RAN.RANGE

-- definition of NAME for the entire spec
datatype NAME = sv_x | sv_y

-- Subtype definition for RAN
b_RAN1 = {(sv_x, RAN.0),(sv_y, RAN.0)}
subtype NAME_RAN = sv_x | sv_y
NAMES_VALUES_RAN = seq({seq({(n,v) | v <- typeRAN(n)}) | n <- NAME_RAN})

-- Bindings definitions for RAN
BINDINGS_RAN = {set(b) | b <- set(distCartProd(NAMES_VALUES_RAN))}


--------------------------------
 -- mget, mset and terminate --
--------------------------------
channel mget, mset : NAME.UNIVERSE
channel terminate

--------------------------------
 -- MEMI --
--------------------------------
MEMI = {| mset,mget,terminate |}
channel lget, lset : NAME.UNIVERSE
channel lterminate
MEML = {| lset,lget,lterminate |}

ACOut1(b_RAN) =
  let
     Memory(b_RAN) =
        ( ( ( [] n : dom(b_RAN) @ mget.n.apply(b_RAN,n) ->
      Memory(b_RAN) )
      [] ( [] n : dom(b_RAN) @ mset.n?nv:typeRAN(n) ->
      Memory(over(b_RAN,n,nv)) ))
      [] terminate -> SKIP)
     MemoryMerge(b_RAN,ns) =
        ( ( ( [] n : dom(b_RAN) @ lget.n.apply(b_RAN,n) ->
      MemoryMerge(b_RAN,ns) )
      [] ( [] n : dom(b_RAN) @ lset.n?nv:typeRAN(n) ->
      MemoryMerge(over(b_RAN,n,nv),ns) ))
      [] lterminate ->
      (  ; bd : <b_RAN> @   ; n : <y | y <- ns> @  mset.n.apply(bd,n) -> SKIP ))

  within ( ( ( mget.sv_x?v_sv_x:(typeRAN(sv_x)) ->
      mget.sv_y?v_sv_y:(typeRAN(sv_y)) ->
      ( mset.sv_x.(RAN.(valueRAN(v_sv_x) + 1)) ->
      mget.sv_x?v_sv_x:(typeRAN(sv_x)) ->
      a1.valueRAN(v_sv_x) -> SKIP
      [] mset.sv_y.(RAN.(valueRAN(v_sv_x) - 1)) ->
      mget.sv_x?v_sv_x:(typeRAN(sv_x)) ->
      b1.valueRAN(v_sv_x) -> SKIP);
      terminate -> SKIP )
      [| MEMI |] Memory(b_RAN))\MEMI )

AC1(b_RAN) =
  let
     Memory(b_RAN) =
        ( ( ( [] n : dom(b_RAN) @ mget.n.apply(b_RAN,n) ->
      Memory(b_RAN) )
      [] ( [] n : dom(b_RAN) @ mset.n?nv:typeRAN(n) ->
      Memory(over(b_RAN,n,nv)) ))
      [] terminate -> SKIP)
     MemoryMerge(b_RAN,ns) =
        ( ( ( [] n : dom(b_RAN) @ lget.n.apply(b_RAN,n) ->
      MemoryMerge(b_RAN,ns) )
      [] ( [] n : dom(b_RAN) @ lset.n?nv:typeRAN(n) ->
      MemoryMerge(over(b_RAN,n,nv),ns) ))
      [] lterminate ->
      (  ; bd : <b_RAN> @   ; n : <y | y <- ns> @  mset.n.apply(bd,n) -> SKIP ))

  within ( ( ( mget.sv_x?v_sv_x:(typeRAN(sv_x)) ->
      ( a ->
      mset.sv_x.(RAN.0) -> SKIP
      [] c ->
      mset.sv_x.(RAN.1) -> SKIP);
      terminate -> SKIP )
      [| MEMI |] Memory(b_RAN))\MEMI )

AC(b_RAN) =
  let
     Memory(b_RAN) =
        ( ( ( [] n : dom(b_RAN) @ mget.n.apply(b_RAN,n) ->
      Memory(b_RAN) )
      [] ( [] n : dom(b_RAN) @ mset.n?nv:typeRAN(n) ->
      Memory(over(b_RAN,n,nv)) ))
      [] terminate -> SKIP)
     MemoryMerge(b_RAN,ns) =
        ( ( ( [] n : dom(b_RAN) @ lget.n.apply(b_RAN,n) ->
      MemoryMerge(b_RAN,ns) )
      [] ( [] n : dom(b_RAN) @ lset.n?nv:typeRAN(n) ->
      MemoryMerge(over(b_RAN,n,nv),ns) ))
      [] lterminate ->
      (  ; bd : <b_RAN> @   ; n : <y | y <- ns> @  mset.n.apply(bd,n) -> SKIP ))

  within ( ( ( mget.sv_x?v_sv_x:(typeRAN(sv_x)) ->
      mget.sv_y?v_sv_y:(typeRAN(sv_y)) ->
      ( a ->
      mset.sv_x.(RAN.1) -> SKIP
      [] c ->
      mset.sv_y.(RAN.2) -> SKIP);
      terminate -> SKIP )
      [| MEMI |] Memory(b_RAN))\MEMI )
