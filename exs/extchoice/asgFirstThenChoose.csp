include "sequence_aux.csp"
include "function_aux.csp"


RANGE = {0..2}
channel a, b
--------------------------------
-- The universe of values
 datatype UNIVERSE = RAN.RANGE
--Conversions
valueRAN(RAN.v) = v

typeRAN(x) = U_RAN

tagRAN(x) = RAN

-- subtypes of UNIVERSE for RAN
subtype U_RAN = RAN.RANGE

-- definition of NAME for the entire spec 
datatype NAME = sv_x | sv_y

-- Subtype definition for RAN
b_RAN1 = {(sv_x, RAN.0),(sv_y, RAN.0)}
subtype NAME_RAN = sv_x | sv_y
NAMES_VALUES_RAN = seq({seq({(n,v) | v <- typeRAN(n)}) | n <- NAME_RAN})

-- Bindings definitions for RAN
BINDINGS_RAN = {set(b) | b <- set(distCartProd(NAMES_VALUES_RAN))}


--------------------------------
 -- mget, mset and terminate -- 
--------------------------------
channel mget, mset : NAME.UNIVERSE
channel terminate

--------------------------------
 -- MEMI -- 
--------------------------------
MEMI = {| mset,mget,terminate |}
channel lget, lset : NAME.UNIVERSE
channel lterminate
MEML = {| lset,lget,lterminate |}

AC(b_RAN) =
  let
     Memory(b_RAN) =
        ( ( ( [] n : dom(b_RAN) @ mget.n.apply(b_RAN,n) ->
      Memory(b_RAN) )
      [] ( [] n : dom(b_RAN) @ mset.n?nv:typeRAN(n) ->
      Memory(over(b_RAN,n,nv)) ))
      [] terminate -> SKIP)
     MemoryMerge(b_RAN,ns) =
        ( ( ( [] n : dom(b_RAN) @ lget.n.apply(b_RAN,n) ->
      MemoryMerge(b_RAN,ns) )
      [] ( [] n : dom(b_RAN) @ lset.n?nv:typeRAN(n) ->
      MemoryMerge(over(b_RAN,n,nv),ns) ))
      [] lterminate ->
      (  ; bd : <b_RAN> @   ; n : <y | y <- ns> @  mset.n.apply(bd,n) -> SKIP ))
     
  within 
     let  restrictRAN(bs) = dres(bs,{sv_x, sv_y})
     within( ( ( mget.sv_x?v_sv_x:(typeRAN(sv_x)) ->
      mget.sv_y?v_sv_y:(typeRAN(sv_y)) ->
      ( mset.sv_x.(RAN.1) ->
      a -> SKIP
      [] mset.sv_y.(RAN.2) ->
      a -> SKIP);
      terminate -> SKIP )
      [| MEMI |] Memory(restrictRAN(b_RAN)))\MEMI )
