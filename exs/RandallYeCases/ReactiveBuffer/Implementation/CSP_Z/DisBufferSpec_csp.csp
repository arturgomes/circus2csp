-- This file is automatically generated by the Circus2ZCSP Translator V0.5
-- on Wed Jul 20 11:15:02 BST 2016
-- See https://github.com/RandallYe/Circus2ZCSP for more information.

-- Minimum and maximum integers for model checking. Make sure they are set in advance.
MININT = 0
MAXINT = 3

-- Maximum instances generated for iseq.  Make sure it is set in advance.
MAXINS = 5

-- include a set of libraries
include "lib_basic.csp"
include "lib_num.csp"
include "lib_card.csp"
include "lib_log.csp"
include "lib_set.csp"
include "lib_rel.csp"
include "lib_fun.csp"
include "lib_seq.csp"


-- Axiomatic definition (Constant)
-- They should be assigned manually to meet its type and predicate restriction
-- and match the values assigned in Z as well
-- The variables defined below should meet the predicate below
--       ((maxring == (maxbuff - 1) and maxbuff == 5) and maxring == 4)
maxbuff = 5
maxring = 4

-- type
RingIndex = {1 .. maxring}



-- channel declarations
channel div
channel input,output : Nat
channel read,write : RingIndex.Nat
channel rd,wrt : Nat
channel rd_i,wrt_i : RingIndex.Nat
channel Controller_ControllerInit-- 
channel Controller_ControllerInit_fOp -- 
channel Controller_CacheInput: Nat-- !x
channel Controller_CacheInput_fOp: Nat -- !x
channel Controller_StoreInputController-- 
channel Controller_StoreInputController_fOp -- 
channel Controller_StoreNewCacheController: Nat-- !x
channel Controller_StoreNewCacheController_fOp: Nat -- !x
channel Controller_NoNewCache-- 
channel Controller_NoNewCache_fOp -- 
channel RingCell_CellWrite: Nat-- !x
channel RingCell_CellWrite_fOp: Nat -- !x
channel IRCell_2_CellWrite: Nat-- !x
channel IRCell_2_CellWrite_fOp: Nat -- !x
channel IRCell_4_CellWrite: Nat-- !x
channel IRCell_4_CellWrite_fOp: Nat -- !x
channel IRCell_3_CellWrite: Nat-- !x
channel IRCell_3_CellWrite_fOp: Nat -- !x
channel IRCell_1_CellWrite: Nat-- !x
channel IRCell_1_CellWrite_fOp: Nat -- !x
channel Controller_OP_size : {0 .. maxbuff}
channel Controller_OP_top : RingIndex
channel Controller_OP_cache : Nat
channel Controller_OP_bot : RingIndex
channel RingCell_OP_v : Nat
channel IRCell_2_OP_v : Nat
channel IRCell_4_OP_v : Nat
channel IRCell_3_OP_v : Nat
channel IRCell_1_OP_v : Nat


-- hidden event
HIDE_CSPB = {|Controller_OP_size, Controller_OP_top, Controller_OP_cache, Controller_OP_bot, RingCell_OP_v, IRCell_2_OP_v, IRCell_4_OP_v, IRCell_3_OP_v, IRCell_1_OP_v, Controller_ControllerInit, Controller_ControllerInit_fOp, Controller_CacheInput, Controller_CacheInput_fOp, Controller_StoreInputController, Controller_StoreInputController_fOp, Controller_StoreNewCacheController, Controller_StoreNewCacheController_fOp, Controller_NoNewCache, Controller_NoNewCache_fOp, RingCell_CellWrite, RingCell_CellWrite_fOp, IRCell_2_CellWrite, IRCell_2_CellWrite_fOp, IRCell_4_CellWrite, IRCell_4_CellWrite_fOp, IRCell_3_CellWrite, IRCell_3_CellWrite_fOp, IRCell_1_CellWrite, IRCell_1_CellWrite_fOp|}

-- processes for variable storing and retrieving 

-- processes 
-- Divergent Process 
DIV = div -> STOP


Controller = 
   (
  (   Controller_ControllerInit ->  SKIP
   [] Controller_ControllerInit_fOp -> DIV
  ) ; 
  let X = 
     (Controller_OP_cache?cache -> Controller_OP_size?size -> 
    (   ((size < maxbuff) & input?x -> Controller_OP_top?top -> Controller_OP_size?size -> 
      (   (size == 0 & 
        (   Controller_CacheInput!x ->  SKIP
         [] Controller_CacheInput_fOp!x -> DIV
        ))
       [] ((size > 0) & write.(top).(x) -> 
        (   Controller_StoreInputController ->  SKIP
         [] Controller_StoreInputController_fOp -> DIV
        ))
      ))
     [] ((size > 0) & output.(cache) -> Controller_OP_bot?bot -> Controller_OP_size?size -> 
      (   ((size > 1) & read.(bot)?x -> 
        (   Controller_StoreNewCacheController!x ->  SKIP
         [] Controller_StoreNewCacheController_fOp!x -> DIV
        ))
       [] (size == 1 & 
        (   Controller_NoNewCache ->  SKIP
         [] Controller_NoNewCache_fOp -> DIV
        ))
      ))
    ) ; X) 
  within X) 

RingCell = 
  let X = 
     (RingCell_OP_v?v -> 
    (   rd.(v) -> SKIP
     [] wrt?x -> 
      (   RingCell_CellWrite!x ->  SKIP
       [] RingCell_CellWrite_fOp!x -> DIV
      )
    ) ; X) 
  within X

Ring =  ||| i:RingIndex @ (i == 4 & IRCell_4 [] (i == 1 & IRCell_1 [] (i == 3 & IRCell_3 [] i == 2 & IRCell_2)))

Buffer = ( Controller [| {| read, write |} |] Ring ) \ {| read, write |}

IRCell_2 = 
  let X = 
     (IRCell_2_OP_v?v -> 
    (   read.(2).(v) -> SKIP
     [] write.(2)?x -> 
      (   IRCell_2_CellWrite!x ->  SKIP
       [] IRCell_2_CellWrite_fOp!x -> DIV
      )
    ) ; X) 
  within X

IRCell_4 = 
  let X = 
     (IRCell_4_OP_v?v -> 
    (   read.(4).(v) -> SKIP
     [] write.(4)?x -> 
      (   IRCell_4_CellWrite!x ->  SKIP
       [] IRCell_4_CellWrite_fOp!x -> DIV
      )
    ) ; X) 
  within X

IRCell_3 = 
  let X = 
     (IRCell_3_OP_v?v -> 
    (   read.(3).(v) -> SKIP
     [] write.(3)?x -> 
      (   IRCell_3_CellWrite!x ->  SKIP
       [] IRCell_3_CellWrite_fOp!x -> DIV
      )
    ) ; X) 
  within X

IRCell_1 = 
  let X = 
     (IRCell_1_OP_v?v -> 
    (   read.(1).(v) -> SKIP
     [] write.(1)?x -> 
      (   IRCell_1_CellWrite!x ->  SKIP
       [] IRCell_1_CellWrite_fOp!x -> DIV
      )
    ) ; X) 
  within X

MAIN = Buffer


-- assertions 
assert MAIN :[ livelock free ]
assert MAIN :[ deadlock free [F] ]
assert MAIN :[ deadlock free [FD] ]

