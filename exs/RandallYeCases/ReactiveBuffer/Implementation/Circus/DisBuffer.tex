\documentclass{article} %
\usepackage{circus}
%
\begin{document}

% Distributed Buffer Processes

\begin{zed}
    maxbuff == 2 \\
    maxring == maxbuff - 1 \\
    maxring == maxbuff - 1 \\
    NatValue == 0 \upto maxbuff \\
    RingIndex == 1 \upto maxring
    \also sNatValue == \seq NatValue
    \also Direction ::= req | ack
\end{zed}

\begin{circus}
	\circchannel\ input, output: NatValue \\
	\circchannel\ read, write: (RingIndex) \cross Direction \cross NatValue \\
	\circchannel\ rdi, wrti: (RingIndex) \cross Direction \cross NatValue \\
  \circchannel\ rrd, wrt: Direction \cross NatValue
  % these channels are implicitly declared.
	% \circchannel\ rdi, wrti: (RingIndex) \cross NatValue
\end{circus}


\begin{circus}
	\circprocess\ Buffer \circdef \circbegin \\
    	\t1 \circstate\ BufferState \defs [~ buff: sNatValue; size: NatValue | \\
            \t2 size = \#buff \leq maxbuff ~] \\
    	\t1	BufferInit \defs [~ BufferState' | buff' = \langle\rangle ; size' = 0 ~] \\
		\t1 InputCmd \defs [~ \Delta BufferState; x? : NatValue | size < maxbuff \land \\
            \t2 buff' = buff \cat \langle x? \rangle ; size' = size + 1 ~] \\
        \t1 Input \circdef \lcircguard size < maxbuff \rcircguard \circguard input?x \then \lschexpract InputCmd \rschexpract \\
		\t1 OutputCmd \defs [~ \Delta BufferState | size > 0 ; buff' = tail~buff ; \\
            \t2 size' = size - 1 ~] \\
        \t1 Output \circdef \lcircguard size > 0 \rcircguard \circguard output!(head~buff) \then \lschexpract OutputCmd \rschexpract \\
	\t1 \circspot \lschexpract BufferInit \rschexpract \circseq (\circmu X \circspot (Input \extchoice Output) \circseq X) \\
	\circend
\end{circus}


\begin{circus}
	\circprocess\ Controller \circdef \circbegin \\
        \t1 \circstate\ ControllerState \defs [ size: NatValue; ringsize: RingIndex;  cache: NatValue;  top,bot: RingIndex ~] \\

  \t1	ControllerInit \defs [ ControllerState' | top' = 1 ; bot' = 1 ; size' = 0 ~] \\

  \t1 CacheInput \defs [~ \Delta ControllerState; x? : NatValue |  size = 0 ; size' = 1 ;  cache' = x? ; bot' = bot ; top' = top ~] \\

  \t1 StoreInputController \defs [~ \Delta ControllerState | \\
    \t2 0 < size ; size < maxbuff ; size' = size + 1 ; \\
    \t2 cache' = cache ; bot' = bot ; top' = (top \mod maxring) + 1 ~] \\

  \t1 InputController \circdef \lcircguard size < maxbuff \rcircguard \circguard input?x \then \\
    \t2 (\lcircguard size = 0 \rcircguard \circguard \lschexpract CacheInput \rschexpract \extchoice \\
    \t2 \lcircguard size > 0 \rcircguard \circguard write.top.req!x \thenwrite.top.ack?dumb \then \lschexpract StoreInputController \rschexpract) \\

  \t1 NoNewCache \defs [~ \Delta ControllerState | \\
        \t2 size = 1 ; size' = 0 ; \\
        \t2 cache' = cache ; bot' = bot ; top' = top ~] \\

  \t1 StoreNewCacheController \defs [~ \Delta ControllerState; x?: NatValue | \\
        \t2 size > 1 ; size' = size - 1 ; \\
        \t2 cache' = x? ; bot' = (bot \mod maxring) + 1 ; \\
        \t2 top' = top ~] \\

  \t1 OutputController \circdef \lcircguard size > 0 \rcircguard \circguard output!(cache) \then \\
    \t2 (\lcircguard size > 1 \rcircguard \circguard (\Intchoice dumb:NatValue \circspot read.bot.req.dumb \then read.bot.ack?x \then \lschexpract StoreNewCacheController \rschexpract) \extchoice \\
    \t2 \lcircguard size = 1 \rcircguard \circguard \lschexpract NoNewCache \rschexpract) \\

  \t1 \circspot \lschexpract ControllerInit \rschexpract \circseq (\circmu X \circspot (InputController \extchoice OutputController) \circseq X) \\
	\circend
\end{circus}

%%%%%%%% Definition 1: indexed process %%%%%%%%%%
\begin{circus}
	\circprocess\ RingCell \circdef \circbegin \\
        \t1 \circstate\ CellState \defs [~ v: NatValue | true ~] \\
        \t1 CellWrite \defs [~ \Delta CellState; x?: NatValue | v' = x? ~] \\
        \t1 Read \circdef rrd.req?dumb \then rrd.ack!v \then \Skip \\
        \t1 Write \circdef wrt.req?x \then wrt.ack?dumb\then \lschexpract CellWrite \rschexpract \\
        \t1 \circspot (\circmu X \circspot (Read \extchoice Write) \circseq X) \\
	\circend
\end{circus}
%
% \begin{circus}
%     \circprocess\ IRCell \circdef ~i: RingIndex \circindex RingCell [rdi, wrti := read, write]\\
% \end{circus}
%
% \begin{circus}
% 	\circprocess\ Ring \circdef (~ \Interleave i: RingIndex \circspot IRCell(i)~)\\
% \end{circus}
%
% \begin{circus}
% 	\circprocess\ ABuffer \circdef ((~ Controller \lpar \lchanset read, write \rchanset  \rpar Ring ~) \circhide \lchanset read, write \rchanset)
% \end{circus}

\begin{assert}
"IRCell(i) = RingCell(b_NAT1)[[rrd <- rdi.i, wrt <- wrti.i]]"
\also "CtrI = {| rdi,wrti |}"
\also "Ring = |||i : RingIndex @ IRCell(i)"
\also "ControllerR = Controller(b_NAT1,b_RIN1)[[read <- rdi, write <- wrti]]"
\also "DBuffer = ( ( ControllerR [| CtrI |] Ring ) \ CtrI )"
% \also "assert Buffer(b_SNA1,b_NAT1) :[deadlock free]"
% \also "assert ABuffer :[deadlock free]"
\also "assert DBuffer [FD= Buffer(b_SNA1,b_NAT1)"
\also "assert Buffer(b_SNA1,b_NAT1) [FD= DBuffer"
\end{assert}
\end{document}
