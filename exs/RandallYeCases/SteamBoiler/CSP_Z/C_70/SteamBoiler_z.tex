% This file is automatically generated by the Circus2ZCSP Translator V0.5
% on Wed Jul 20 11:38:07 BST 2016
% See https://github.com/RandallYe/Circus2ZCSP for more information.

\documentclass{article}
\usepackage{fuzz}

\begin{document}

%\begin{zsection}	 \SECTION SteamBoiler \parents~standard\_toolkit
%\end{zsection}

\begin{zed}
	Timer\_cycletime == 5
\end{zed}

\begin{zed}
	Timer\_cyclelimit == Timer\_cycletime - 1
\end{zed}

\begin{zed}
	Timer\_Time == 0 \upto Timer\_cyclelimit
\end{zed}

\begin{zed}
	Timer\_TimeState \defs [~  Timer\_time : Timer\_Time  ~]
\end{zed}

\begin{axdef}
	MAX\_NUM : \nat 
\where
 MAX\_NUM = 70
\end{axdef}

\begin{zed}
	NUMS == 0 \upto MAX\_NUM
\end{zed}

\begin{axdef}
	C , P , U\_1 , U\_2 , W : NUMS 
\where
 C = 70 \\
 P = 1 \\
 U\_1 = 1 \\
 U\_2 = 1 \\
 W = 10
\end{axdef}

\begin{axdef}
	M\_1 , N\_1 , N\_2 , M\_2 : NUMS 
\where
 M\_1 \leq N\_1 \leq N\_2 \leq M\_2 \\
 M\_1 = 7 \\
 N\_1 = 14 \\
 N\_2 = 56 \\
 M\_2 = 63
\end{axdef}

\begin{zed}
	SState ::= sokay | sfailed
\end{zed}

\begin{zed}
	PState ::= popen | pwaiting | pclosed | pfailed
\end{zed}

\begin{zed}
	PCState ::= pcflow | pcnoflow | pcfailed
\end{zed}

\begin{zed}
	PumpIndex == 1 \upto 4
\end{zed}

\begin{zed}
	VState ::= vopen | vclosed
\end{zed}

\begin{zed}
	VAction ::= openv | closev | VNoChange
\end{zed}

\begin{zed}
	InputPState == \{ popen , pclosed \}
\end{zed}

\begin{zed}
	InputPCState == \{ pcflow , pcnoflow \}
\end{zed}

\begin{zed}
	UnitFailure ::= qfail | vfail | pfail \ldata PumpIndex \rdata | pcfail \ldata PumpIndex \rdata
\end{zed}

\begin{zed}
	InputSignal ::= stop | steamBoilerWaiting | physicalUnitsReady | transmissionFailure
\end{zed}

\begin{zed}
	SchExpr\_22 \defs [~  a\_1 , a\_2 : NUMS ; st : SState | a\_1 \leq a\_2  ~]
\end{zed}

\begin{zed}
	Analyser\_QSensor \defs SchExpr\_22 [ Analyser\_qa\_1 / a\_1 , Analyser\_qa\_2 / a\_2 , Analyser\_qst / st ]
\end{zed}

\begin{zed}
	Analyser\_InitQSensor \defs [~  Analyser\_QSensor' | Analyser\_qa\_1' = 0 \land Analyser\_qa\_2' = C \land Analyser\_qst' = sokay  ~]
\end{zed}

\begin{zed}
	SchExpr\_23 \defs [~  a\_1 , a\_2 : NUMS ; st : SState | a\_1 \leq a\_2  ~]
\end{zed}

\begin{zed}
	Analyser\_VSensor \defs SchExpr\_23 [ Analyser\_va\_1 / a\_1 , Analyser\_va\_2 / a\_2 , Analyser\_vst / st ]
\end{zed}

\begin{zed}
	Analyser\_InitVSensor \defs [~  Analyser\_VSensor' | Analyser\_va\_1' = 0 \land Analyser\_va\_2' = 0 \land Analyser\_vst' = sokay  ~]
\end{zed}

\begin{zed}
	Analyser\_Pump0 \defs [~  pa\_1 , pa\_2 : \{ 0 , P \} ; pst : PState | pa\_1 \leq pa\_2  ~]
\end{zed}

\begin{zed}
	Analyser\_PumpOpen \defs [~  Analyser\_Pump0 | pst = popen \implies ( pa\_1 = P \land pa\_2 = P )  ~]
\end{zed}

\begin{zed}
	Analyser\_PumpWaitingOrClosed \defs [~  Analyser\_Pump0 | ( pst = pwaiting \lor pst = pclosed ) \implies ( pa\_1 = 0 \land pa\_2 = 0 )  ~]
\end{zed}

\begin{zed}
	Analyser\_Pump \defs Analyser\_PumpOpen \land Analyser\_PumpWaitingOrClosed
\end{zed}

\begin{zed}
	Analyser\_InitPump \defs [~  Analyser\_PumpWaitingOrClosed' | pst' = pclosed  ~]
\end{zed}

\begin{zed}
	Analyser\_PumpCtr0 \defs [~  Analyser\_Pump ; pcst : PCState  ~]
\end{zed}

\begin{zed}
	Analyser\_POpenPCFlowOrFailed \defs [~  Analyser\_PumpCtr0 | pst = popen \implies ( pcst = pcflow \lor pcst = pcfailed )  ~]
\end{zed}

\begin{zed}
	Analyser\_PWaitingPCNoFlowOrFailed \defs [~  Analyser\_PumpCtr0 | pst = pwaiting \implies ( pcst = pcnoflow \lor pcst = pcfailed )  ~]
\end{zed}

\begin{zed}
	Analyser\_PClosedPCNoFlowOrFailed \defs [~  Analyser\_PumpCtr0 | pst = pclosed \implies ( pcst = pcnoflow \lor pcst = pcfailed )  ~]
\end{zed}

\begin{zed}
	Analyser\_PFailedPCFlow \defs [~  Analyser\_PumpCtr0 | ( pst = pfailed \land pcst = pcflow ) \implies ( pa\_1 = P \land pa\_2 = P )  ~]
\end{zed}

\begin{zed}
	Analyser\_PFailedPCNoFlow \defs [~  Analyser\_PumpCtr0 | ( pst = pfailed \land pcst = pcnoflow ) \implies ( pa\_1 = 0 \land pa\_2 = 0 )  ~]
\end{zed}

\begin{zed}
	Analyser\_PFailedPCFailed \defs [~  Analyser\_PumpCtr0 | ( pst = pfailed \land pcst = pcfailed ) \implies ( pa\_1 = 0 \land pa\_2 = P )  ~]
\end{zed}

\begin{zed}
	Analyser\_PumpCtr \defs Analyser\_POpenPCFlowOrFailed \land Analyser\_PWaitingPCNoFlowOrFailed \land Analyser\_PClosedPCNoFlowOrFailed \land Analyser\_PFailedPCFlow \land Analyser\_PFailedPCNoFlow \land Analyser\_PFailedPCFailed
\end{zed}

\begin{zed}
	Analyser\_InitPumpCtr \defs [~  Analyser\_PumpCtr' | Analyser\_InitPump \land pcst' = pcnoflow  ~]
\end{zed}

\begin{schema}{Analyser\_PumpCtrSystem}

 Analyser\_pumpctr : PumpIndex \fun Analyser\_PumpCtr \\
 Analyser\_pta\_1 , Analyser\_pta\_2 : \{ 0 , P , 2 * P , 3 * P , 4 * P \} 
\where
 Analyser\_pta\_1 = ( Analyser\_pumpctr~1 ) . pa\_1 + ( Analyser\_pumpctr~2 ) . pa\_1 + ( Analyser\_pumpctr~3 ) . pa\_1 + ( Analyser\_pumpctr~4 ) . pa\_1 \\
 Analyser\_pta\_2 = ( Analyser\_pumpctr~1 ) . pa\_2 + ( Analyser\_pumpctr~2 ) . pa\_2 + ( Analyser\_pumpctr~3 ) . pa\_2 + ( Analyser\_pumpctr~4 ) . pa\_2
\end{schema}

\begin{schema}{Analyser\_InitPumpCtrSystem}

 Analyser\_PumpCtrSystem' 
\where
 \exists Analyser\_InitPumpCtr @ \forall i : PumpIndex @ Analyser\_pumpctr'~i = \theta Analyser\_PumpCtr'
\end{schema}

\begin{zed}
	Analyser\_Valve \defs [~  Analyser\_valve : VState  ~]
\end{zed}

\begin{zed}
	Analyser\_InitValve \defs [~  Analyser\_Valve' | Analyser\_valve' = vclosed  ~]
\end{zed}

\begin{zed}
	Analyser\_SetValveState \defs [~  \Delta Analyser\_Valve ; vstate? : VAction | ( vstate? = VNoChange \implies Analyser\_valve' = Analyser\_valve ) \land ( vstate? = openv \implies Analyser\_valve' = vopen ) \land ( vstate? = closev \implies Analyser\_valve' = vclosed )  ~]
\end{zed}

\begin{zed}
	Analyser\_CValues \defs [~  Analyser\_qc\_1 , Analyser\_qc\_2 , Analyser\_vc\_1 , Analyser\_vc\_2 : NUMS  ~]
\end{zed}

\begin{zed}
	Analyser\_InitCValues \defs [~  Analyser\_CValues' | Analyser\_qc\_1' = 0 \land Analyser\_qc\_2' = C \land Analyser\_vc\_1' = 0 \land Analyser\_vc\_2' = W  ~]
\end{zed}

\begin{zed}
	Analyser\_QLowerBoundValveOpen \defs [~  Analyser\_CValues ; Analyser\_Valve | Analyser\_valve = vopen \land Analyser\_qc\_1 = 0  ~]
\end{zed}

\begin{zed}
	Analyser\_QLowerBoundValveClosed \defs [~  Analyser\_CValues ; Analyser\_QSensor ; Analyser\_VSensor ; Analyser\_PumpCtrSystem ; Analyser\_Valve | Analyser\_valve = vclosed \land Analyser\_qc\_1 = max \{ 0 , Analyser\_qa\_1 - ( 5 * Analyser\_va\_2 ) - ( 12 * U\_1 ) + ( 5 * Analyser\_pta\_1 ) \}  ~]
\end{zed}

\begin{zed}
	Analyser\_QUpperBound \defs [~  Analyser\_CValues ; Analyser\_QSensor ; Analyser\_VSensor ; Analyser\_PumpCtrSystem | Analyser\_qc\_2 = max \{ 0 , min \{ C , Analyser\_qa\_2 - ( 5 * Analyser\_va\_1 ) + ( 12 * U\_2 ) + ( 5 * Analyser\_pta\_2 ) \} \}  ~]
\end{zed}

\begin{zed}
	Analyser\_VLowerBound \defs [~  Analyser\_CValues ; Analyser\_VSensor | Analyser\_vc\_1 = max \{ 0 , Analyser\_va\_1 - ( 5 * U\_2 ) \}  ~]
\end{zed}

\begin{zed}
	Analyser\_VUpperBound \defs [~  Analyser\_CValues ; Analyser\_VSensor | ( Analyser\_vc\_2 = min \{ W , Analyser\_va\_2 + ( 5 * U\_1 ) \} )  ~]
\end{zed}

\begin{schema}{Analyser\_ExpectedPumpStates}

 Analyser\_expectedp : PumpIndex \fun InputPState \\
 Analyser\_expectedpc : PumpIndex \fun InputPCState
\end{schema}

\begin{schema}{Analyser\_InitExpectedPumpStates}

 Analyser\_ExpectedPumpStates' 
\where
 Analyser\_expectedp' = \{ 1 \mapsto pclosed , 2 \mapsto pclosed , 3 \mapsto pclosed , 4 \mapsto pclosed \} \\
 Analyser\_expectedpc' = \{ 1 \mapsto pcflow , 2 \mapsto pcflow , 3 \mapsto pcflow , 4 \mapsto pcflow \}
\end{schema}

\begin{schema}{Analyser\_CalcExpectedPumpState}

 \Delta Analyser\_ExpectedPumpStates \\
 \Delta Analyser\_PumpCtrSystem \\
 pumpstate? : PumpIndex \fun InputPState 
\where
 \forall i : PumpIndex @ ( ( Analyser\_expectedp'~i = pumpstate?~i ) \land ( ( pumpstate?~i = popen \land Analyser\_expectedpc'~i = pcflow ) \lor ( pumpstate?~i = pclosed \land Analyser\_expectedpc'~i = pcnoflow ) ) ) \land ( ( ( Analyser\_pumpctr'~i ) . pst = \IF ( Analyser\_expectedp~i = pclosed \land pumpstate?~i = popen \land ( Analyser\_pumpctr~i ) . pst = pclosed ) \THEN pwaiting \ELSE ( Analyser\_pumpctr~i ) . pst ) \land ( Analyser\_pumpctr'~i ) . pcst = ( Analyser\_pumpctr~i ) . pcst )
\end{schema}

\begin{zed}
	Analyser\_Equipment0 \defs Analyser\_QSensor \land Analyser\_VSensor \land Analyser\_PumpCtrSystem \land Analyser\_Valve \land Analyser\_CValues \land Analyser\_ExpectedPumpStates
\end{zed}

\begin{zed}
	Analyser\_QFailed \defs [~  Analyser\_QSensor | Analyser\_qst = sfailed  ~]
\end{zed}

\begin{zed}
	Analyser\_VFailed \defs [~  Analyser\_VSensor | Analyser\_vst = sfailed  ~]
\end{zed}

\begin{zed}
	Analyser\_PFailed \defs [~  Analyser\_PumpCtrSystem | ( \exists i : PumpIndex @ ( Analyser\_pumpctr~i ) . pst = pfailed )  ~]
\end{zed}

\begin{zed}
	Analyser\_PCFailed \defs [~  Analyser\_PumpCtrSystem | ( \exists i : PumpIndex @ ( Analyser\_pumpctr~i ) . pcst = pcfailed )  ~]
\end{zed}

\begin{zed}
	Analyser\_Failures \defs [~  Analyser\_failures , Analyser\_noacks : \power UnitFailure | Analyser\_noacks \subseteq Analyser\_failures  ~]
\end{zed}

\begin{schema}{Analyser\_EquipmentFailures}

 Analyser\_Equipment0 \\
 Analyser\_Failures 
\where
 Analyser\_failures = \{ u : UnitFailure ; i : PumpIndex | ( u = qfail \land Analyser\_QFailed ) \lor ( u = vfail \land Analyser\_VFailed ) \lor ( u = pfail~i \land ( Analyser\_pumpctr~i ) . pst = pfailed ) \lor ( u = pcfail~i \land ( Analyser\_pumpctr~i ) . pcst = pcfailed ) @ u \}
\end{schema}

\begin{zed}
	Analyser\_InitFailures \defs [~  Analyser\_Failures' | Analyser\_failures' =~\emptyset \land Analyser\_noacks' =~\emptyset  ~]
\end{zed}

\begin{zed}
	Analyser\_FailuresExpected \defs [~  Analyser\_Failures ; Analyser\_failureacks : \power UnitFailure | Analyser\_failureacks \subseteq Analyser\_noacks  ~]
\end{zed}

\begin{zed}
	Analyser\_RepairsExpected \defs [~  Analyser\_Failures ; Analyser\_repairs : \power UnitFailure | Analyser\_repairs \subseteq Analyser\_failures  ~]
\end{zed}

\begin{schema}{Analyser\_UpdateFailuresAck}

 \Delta Analyser\_Failures \\
 Analyser\_failureacks? : \power UnitFailure \\
 Analyser\_repairs? : \power UnitFailure 
\where
 \exists newnoacks : \power UnitFailure @ ( ( newnoacks = Analyser\_noacks \cup ( Analyser\_failures' \setminus Analyser\_failures ) ) \land ( ( ( Analyser\_failureacks? \subseteq Analyser\_noacks \land Analyser\_repairs? \subseteq Analyser\_failures ) \implies ( Analyser\_noacks' = newnoacks \setminus ( Analyser\_failureacks? \cup Analyser\_repairs? ) ) ) \land ( ( Analyser\_failureacks? \subseteq Analyser\_noacks \land \lnot Analyser\_repairs? \subseteq Analyser\_failures ) \implies ( Analyser\_noacks' = newnoacks \setminus Analyser\_failureacks? ) ) \land ( ( \lnot Analyser\_failureacks? \subseteq Analyser\_noacks \land Analyser\_repairs? \subseteq Analyser\_failures ) \implies ( Analyser\_noacks' = newnoacks \setminus Analyser\_repairs? ) ) \land ( ( \lnot Analyser\_failureacks? \subseteq Analyser\_noacks \land \lnot Analyser\_repairs? \subseteq Analyser\_failures ) \implies ( Analyser\_noacks' = newnoacks ) ) ) )
\end{schema}

\begin{zed}
	Analyser\_Equipment \defs ( Analyser\_QLowerBoundValveOpen \lor Analyser\_QLowerBoundValveClosed ) \land Analyser\_QUpperBound \land Analyser\_VLowerBound \land Analyser\_VUpperBound \land Analyser\_ExpectedPumpStates \land Analyser\_EquipmentFailures
\end{zed}

\begin{zed}
	Analyser\_InitEquipment \defs Analyser\_Equipment0' \land Analyser\_InitQSensor \land Analyser\_InitVSensor \land Analyser\_InitPumpCtrSystem \land Analyser\_InitCValues \land Analyser\_InitFailures \land Analyser\_InitExpectedPumpStates \land Analyser\_InitValve
\end{zed}

\begin{schema}{Analyser\_RepairQSensor}

 \Delta Analyser\_QSensor \\
 Analyser\_repairs? : \power UnitFailure 
\where
 Analyser\_qa\_1' = Analyser\_qa\_1 \\
 Analyser\_qa\_2' = Analyser\_qa\_2 \\
 qfail \in Analyser\_repairs? \implies Analyser\_qst' = sokay \\
 qfail \notin Analyser\_repairs? \implies Analyser\_qst' = Analyser\_qst
\end{schema}

\begin{schema}{Analyser\_RepairVSensor}

 \Delta Analyser\_VSensor \\
 Analyser\_repairs? : \power UnitFailure 
\where
 Analyser\_va\_1' = Analyser\_va\_1 \\
 Analyser\_va\_2' = Analyser\_va\_2 \\
 vfail \in Analyser\_repairs? \implies Analyser\_vst' = sokay \\
 vfail \notin Analyser\_repairs? \implies Analyser\_vst' = Analyser\_vst
\end{schema}

\begin{schema}{Analyser\_RepairAPumpCtr}

 \Delta Analyser\_PumpCtr 
\where
 pst' = pst \\
 pst = popen \implies pcst' = pcflow \\
 pst \neq popen \implies pcst' = pcnoflow
\end{schema}

\begin{schema}{Analyser\_RepairAPump}

 \Delta Analyser\_PumpCtr 
\where
 pst' = pclosed \\
 pcst' = pcst
\end{schema}

\begin{schema}{Analyser\_RepairPumpCtrAndPump}

 \Delta Analyser\_PumpCtr 
\where
 pst' = pclosed \\
 pcst' = pcnoflow
\end{schema}

\begin{schema}{Analyser\_RepairPumps}

 \Delta Analyser\_PumpCtrSystem \\
 Analyser\_repairs? : \power UnitFailure 
\where
 \forall i : PumpIndex @ \exists Analyser\_PumpCtr ; Analyser\_PumpCtr' @ ( ( \theta Analyser\_PumpCtr' = Analyser\_pumpctr'~i ) \land ( \theta Analyser\_PumpCtr = Analyser\_pumpctr~i ) \land ( ( pfail~i \in Analyser\_repairs? \land pcfail~i \notin Analyser\_repairs? ) \implies Analyser\_RepairAPump ) \land ( ( pfail~i \notin Analyser\_repairs? \land pcfail~i \in Analyser\_repairs? ) \implies Analyser\_RepairAPumpCtr ) \land ( ( pfail~i \in Analyser\_repairs? \land pcfail~i \in Analyser\_repairs? ) \implies Analyser\_RepairPumpCtrAndPump ) \land ( ( pfail~i \notin Analyser\_repairs? \land pcfail~i \notin Analyser\_repairs? ) \implies \theta Analyser\_PumpCtr' = \theta Analyser\_PumpCtr ) )
\end{schema}

\begin{zed}
	Analyser\_RepairEquipments \defs ( Analyser\_RepairsExpected [ Analyser\_repairs? / Analyser\_repairs ] \land Analyser\_RepairPumps \land Analyser\_RepairQSensor \land Analyser\_RepairVSensor ) \lor ( ( \lnot Analyser\_RepairsExpected [ Analyser\_repairs? / Analyser\_repairs ] ) \land \Xi Analyser\_PumpCtrSystem \land \Xi Analyser\_QSensor \land \Xi Analyser\_VSensor )
\end{zed}

\begin{zed}
	Analyser\_EmergenyCond \defs [~  Analyser\_emergencyCond : \{ 0 , 1 \}  ~]
\end{zed}

\begin{zed}
	Analyser\_MarkEmergencyCond \defs [~  \Delta Analyser\_EmergenyCond | Analyser\_emergencyCond' = 1  ~]
\end{zed}

\begin{zed}
	Analyser\_ClearEmergencyCond \defs [~  \Delta Analyser\_EmergenyCond | Analyser\_emergencyCond' = 0  ~]
\end{zed}

\begin{zed}
	Analyser\_EvalRepairFailureAck \defs ( Analyser\_RepairsExpected [ Analyser\_repairs? / Analyser\_repairs ] \land Analyser\_FailuresExpected [ Analyser\_failureacks? / Analyser\_failureacks ] \land Analyser\_ClearEmergencyCond ) \lor ( ( \lnot Analyser\_RepairsExpected [ Analyser\_repairs? / Analyser\_repairs ] \lor \lnot Analyser\_FailuresExpected [ Analyser\_failureacks? / Analyser\_failureacks ] ) \land Analyser\_MarkEmergencyCond )
\end{zed}

\begin{schema}{Analyser\_UnitState}

 Analyser\_pumpState : PumpIndex \fun InputPState \\
 Analyser\_pumpCtrState : PumpIndex \fun InputPCState \\
 Analyser\_q , Analyser\_v : NUMS
\end{schema}

\begin{schema}{Analyser\_InputMsg}

 Analyser\_signals : \power InputSignal \\
 Analyser\_UnitState \\
 Analyser\_failureacks , Analyser\_repairs : \power UnitFailure
\end{schema}

\begin{zed}
	Analyser\_Expected \defs [~  x? , c\_1 , c\_2 : NUMS | c\_1 \leq x? \leq c\_2  ~]
\end{zed}

\begin{zed}
	Analyser\_Unexpected \defs~\lnot Analyser\_Expected
\end{zed}

\begin{zed}
	Analyser\_SchInstRef\_0 \defs [~  a\_1 , a\_2 : NUMS ; st : SState | a\_1 \leq a\_2  ~]
\end{zed}

\begin{zed}
	Analyser\_Sensor \defs [~  \Delta Analyser\_SchInstRef\_0 ; c\_1 , c\_2 , c\_1' , c\_2' , x? : NUMS  ~]
\end{zed}

\begin{schema}{Analyser\_CheckAndAdjustSensor}

 Analyser\_Sensor 
\where
 Analyser\_Expected \implies st' = st \\
 Analyser\_Unexpected \implies st' = sfailed \\
 st' = sokay \implies a\_1' = x? \land a\_2' = x? \\
 st' = sfailed \implies a\_1' = c\_1 \land a\_2' = c\_2
\end{schema}

\begin{zed}
	Analyser\_CheckAndAdjustQ \defs Analyser\_QSensor \land Analyser\_CheckAndAdjustSensor [ Analyser\_q? / x? , Analyser\_qa\_1 / a\_1 , Analyser\_qa\_2 / a\_2 , Analyser\_qc\_1 / c\_1 , Analyser\_qc\_2 / c\_2 , Analyser\_qst / st , Analyser\_qa\_1' / a\_1' , Analyser\_qa\_2' / a\_2' , Analyser\_qc\_1' / c\_1' , Analyser\_qc\_2' / c\_2' , Analyser\_qst' / st' ]
\end{zed}

\begin{zed}
	Analyser\_CheckAndAdjustV \defs Analyser\_VSensor \land Analyser\_CheckAndAdjustSensor [ Analyser\_v? / x? , Analyser\_va\_1 / a\_1 , Analyser\_va\_2 / a\_2 , Analyser\_vc\_1 / c\_1 , Analyser\_vc\_2 / c\_2 , Analyser\_vst / st , Analyser\_va\_1' / a\_1' , Analyser\_va\_2' / a\_2' , Analyser\_vc\_1' / c\_1' , Analyser\_vc\_2' / c\_2' , Analyser\_vst' / st' ]
\end{zed}

\begin{schema}{Analyser\_ExpectedPumpStateTBD}

 exppst : InputPState \\
 exppcst : InputPCState 
\where
 exppst = pclosed \\
 exppcst = pcflow
\end{schema}

\begin{schema}{Analyser\_CheckAndAdjustPumpTBD}

 \Delta Analyser\_PumpCtr \\
 pst? , exppst : InputPState \\
 pcst? , exppcst : InputPCState 
\where
 ( ( pst? = popen \land pcst? = pcflow ) \lor ( pst? = pclosed \land pcst? = pcnoflow ) ) \implies ( pst' = pst? \land pcst' = pcst? ) \\
 ( pst? = popen \land pcst? = pcnoflow ) \implies ( pst' = pfailed \land pcst' = pcnoflow ) \\
 ( pst? = pclosed \land pcst? = pcflow ) \implies ( pst' = pfailed \land pcst' = pcflow )
\end{schema}

\begin{schema}{Analyser\_CheckAndAdjustPump}

 \Delta Analyser\_PumpCtr \\
 pst? , exppst : InputPState \\
 pcst? , exppcst : InputPCState 
\where
 ( ( pst = pfailed \land pst' = pst ) \lor ( pst \neq pfailed \land ( pst? = exppst \implies pst' = pst? ) \land ( pst? \neq exppst \implies pst' = pfailed ) ) ) \\
 ( ( pcst = pcfailed \land pcst' = pcst ) \lor ( pcst \neq pcfailed \land ( pcst? = exppcst \implies pcst' = pcst? ) \land ( pcst? \neq exppcst \implies pcst' = pcfailed ) ) )
\end{schema}

\begin{schema}{Analyser\_PromotePumpCheck}

 \Delta Analyser\_PumpCtr \\
 \Delta Analyser\_PumpCtrSystem \\
 Analyser\_ExpectedPumpStates \\
 pst? , exppst : InputPState \\
 pcst? , exppcst : InputPCState \\
 Analyser\_pumpState? : PumpIndex \fun InputPState \\
 Analyser\_pumpCtrState? : PumpIndex \fun InputPCState \\
 i : PumpIndex 
\where
 \theta Analyser\_PumpCtr = Analyser\_pumpctr~i \\
 \theta Analyser\_PumpCtr' = Analyser\_pumpctr'~i \\
 pst? = Analyser\_pumpState?~i \\
 pcst? = Analyser\_pumpCtrState?~i \\
 exppst = Analyser\_expectedp~i \\
 exppcst = Analyser\_expectedpc~i
\end{schema}

\begin{zed}
	Analyser\_SetPumpCtr \defs~\forall i : PumpIndex @ \exists Analyser\_PumpCtr ; Analyser\_PumpCtr' ; pst? , exppst : PState ; pcst? , exppcst : PCState @ ( Analyser\_PromotePumpCheck \land ( ( Analyser\_CheckAndAdjustPumpTBD \land Analyser\_ExpectedPumpStateTBD ) \lor ( Analyser\_CheckAndAdjustPump \land \lnot Analyser\_ExpectedPumpStateTBD ) ) )
\end{zed}

\begin{schema}{Analyser\_StopPresent}

 Analyser\_signals? : \power InputSignal \\
 Analyser\_stops , Analyser\_stops' : NUMS 
\where
 stop \in Analyser\_signals? \\
 ( ( Analyser\_stops + 1 > MAX\_NUM \land Analyser\_stops' = Analyser\_stops ) \lor ( Analyser\_stops' = Analyser\_stops + 1 ) )
\end{schema}

\begin{schema}{Analyser\_StopNotPresent}

 Analyser\_signals? : \power InputSignal \\
 Analyser\_stops , Analyser\_stops' : NUMS 
\where
 stop \notin Analyser\_signals? \land Analyser\_stops < 3 \\
 Analyser\_stops' = 0
\end{schema}

\begin{schema}{Analyser\_TooManyStops}

 Analyser\_signals? : \power InputSignal \\
 Analyser\_stops , Analyser\_stops' : NUMS 
\where
 stop \notin Analyser\_signals? \land Analyser\_stops \geq 3 \\
 Analyser\_stops' = Analyser\_stops
\end{schema}

\begin{zed}
	Analyser\_AdjustStops \defs Analyser\_StopPresent \lor Analyser\_StopNotPresent \lor Analyser\_TooManyStops
\end{zed}

\begin{zed}
	Analyser\_AnalyserState \defs [~  Analyser\_Equipment0 ; Analyser\_Failures ; Analyser\_InputMsg ; Analyser\_stops : NUMS ; Analyser\_signalhistory : \power InputSignal ; Analyser\_EmergenyCond  ~]
\end{zed}

\begin{zed}
	Mode ::= initialisation | normal | degraded | rescue | emergencyStop
\end{zed}

\begin{zed}
	Nonemergency == \{ initialisation , normal , degraded , rescue \}
\end{zed}

\begin{zed}
	Controller\_ModeState \defs [~  Controller\_mode : Mode  ~]
\end{zed}

\begin{zed}
	OutputSignal ::= programReady | openValve | closeValve | levelFailureDetection | steamFailureDetection | levelRepairedAcknowledgement | steamRepairedAcknowledgement
\end{zed}

\begin{schema}{Reporter\_OutputMsg}

 Reporter\_mode : Mode \\
 Reporter\_signals : \power OutputSignal \\
 Reporter\_pumpState : PumpIndex \fun InputPState \\
 Reporter\_pumpFailureDetection : \power UnitFailure \\
 Reporter\_pumpCtrFailureDetection : \power UnitFailure \\
 Reporter\_pumpRepairedAcknowledgement : \power UnitFailure \\
 Reporter\_pumpCtrRepairedAcknowledgement : \power UnitFailure
\end{schema}

\begin{zed}
	Reporter\_ReporterState \defs [~  Reporter\_OutputMsg ; Reporter\_valveSt : VAction | true  ~]
\end{zed}

\begin{zed}
	State \defs Timer\_TimeState \land Analyser\_AnalyserState \land Controller\_ModeState \land Reporter\_ReporterState
\end{zed}

\begin{zed}
	Init \defs [~  State' | Timer\_time' = Timer\_cyclelimit \land Analyser\_InitEquipment \land Analyser\_stops' = 0 \land Analyser\_signalhistory' =~\emptyset \land \theta Analyser\_InputMsg' = ((( \LET Analyser\_signals ==~\emptyset ; Analyser\_pumpState == \{ 1 \mapsto pclosed , 2 \mapsto pclosed , 3 \mapsto pclosed , 4 \mapsto pclosed \} ; Analyser\_pumpCtrState == \{ 1 \mapsto pcnoflow , 2 \mapsto pcnoflow , 3 \mapsto pcnoflow , 4 \mapsto pcnoflow \} ; Analyser\_q == 0 ; Analyser\_v == 0 ; Analyser\_failureacks ==~\emptyset ; Analyser\_repairs ==~\emptyset @ \theta Analyser\_InputMsg ))) \land Analyser\_emergencyCond' = 0 \land Controller\_mode' = initialisation \land Reporter\_valveSt' = VNoChange \land \theta Reporter\_OutputMsg' = ((( \LET Reporter\_mode == initialisation ; Reporter\_signals ==~\emptyset ; Reporter\_pumpState == \{ 1 \mapsto pclosed , 2 \mapsto pclosed , 3 \mapsto pclosed , 4 \mapsto pclosed \} ; Reporter\_pumpFailureDetection ==~\emptyset ; Reporter\_pumpCtrFailureDetection ==~\emptyset ; Reporter\_pumpRepairedAcknowledgement ==~\emptyset ; Reporter\_pumpCtrRepairedAcknowledgement ==~\emptyset @ \theta Reporter\_OutputMsg )))  ~]
\end{zed}

\begin{zed}
	Timer\_InitTimer \defs [~  Timer\_TimeState' ; Timer\_time : Timer\_Time ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Timer\_time' = Timer\_cyclelimit  ~]
\end{zed}

\begin{zed}
	Timer\_TimeOp \defs [~  \Delta Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Timer\_time' \geq Timer\_time  ~]
\end{zed}

\begin{zed}
	Timer\_OP\_time \defs [~  \Xi Timer\_TimeState ; Timer\_time! : Timer\_Time ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Timer\_time! = Timer\_time  ~]
\end{zed}

\begin{zed}
	Timer\_InitTimer\_fOp \defs [~  \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | \lnot \pre Timer\_InitTimer  ~]
\end{zed}

\begin{zed}
	Timer\_AssgnOp1 \defs [~  \Delta Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Timer\_time' = ( Timer\_time + 1 ) \mod Timer\_cycletime  ~]
\end{zed}

\begin{zed}
	Analyser\_StopSignalHis \defs [~  Analyser\_stops : NUMS ; Analyser\_signalhistory : \power InputSignal  ~]
\end{zed}

\begin{zed}
	Analyser\_PumpOp \defs \Xi Analyser\_QSensor \land \Xi Analyser\_VSensor \land \Xi Analyser\_Valve \land \Xi Analyser\_CValues \land \Xi Analyser\_Failures \land \Xi Analyser\_ExpectedPumpStates \land \Xi Analyser\_InputMsg \land \Xi Analyser\_StopSignalHis \land \Xi Analyser\_EmergenyCond
\end{zed}

\begin{zed}
	Analyser\_InitAnalyserState \defs [~  Analyser\_AnalyserState' ; Analyser\_signals : \power InputSignal ; Analyser\_signalhistory : \power InputSignal ; Analyser\_v : NUMS ; Analyser\_qa\_1 : NUMS ; Analyser\_qa\_2 : NUMS ; Analyser\_repairs : \power UnitFailure ; Analyser\_pumpState : PumpIndex \fun InputPState ; Analyser\_qc\_1 : NUMS ; Analyser\_q : NUMS ; Analyser\_qc\_2 : NUMS ; Analyser\_stops : NUMS ; Analyser\_va\_1 : NUMS ; Analyser\_valve : VState ; Analyser\_va\_2 : NUMS ; Analyser\_vc\_1 : NUMS ; Analyser\_pumpctr : PumpIndex \fun Analyser\_PumpCtr ; Analyser\_failureacks : \power UnitFailure ; Analyser\_pta\_2 : \{ 0 , P , 2 * P , 3 * P , 4 * P \} ; Analyser\_qst : SState ; Analyser\_expectedpc : PumpIndex \fun InputPCState ; Analyser\_vc\_2 : NUMS ; Analyser\_vst : SState ; Analyser\_emergencyCond : \{ 0 , 1 \} ; Analyser\_noacks : \power UnitFailure ; Analyser\_failures : \power UnitFailure ; Analyser\_pta\_1 : \{ 0 , P , 2 * P , 3 * P , 4 * P \} ; Analyser\_pumpCtrState : PumpIndex \fun InputPCState ; Analyser\_expectedp : PumpIndex \fun InputPState ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_InitEquipment \land Analyser\_stops' = 0 \land Analyser\_signalhistory' =~\emptyset \land \theta Analyser\_InputMsg' = ((( \LET Analyser\_signals ==~\emptyset ; Analyser\_pumpState == \{ 1 \mapsto pclosed , 2 \mapsto pclosed , 3 \mapsto pclosed , 4 \mapsto pclosed \} ; Analyser\_pumpCtrState == \{ 1 \mapsto pcnoflow , 2 \mapsto pcnoflow , 3 \mapsto pcnoflow , 4 \mapsto pcnoflow \} ; Analyser\_q == 0 ; Analyser\_v == 0 ; Analyser\_failureacks ==~\emptyset ; Analyser\_repairs ==~\emptyset @ \theta Analyser\_InputMsg ))) \land Analyser\_emergencyCond' = 0  ~]
\end{zed}

\begin{zed}
	Analyser\_Analyse \defs [~  \Delta Analyser\_AnalyserState ; Analyser\_InputMsg~? ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | \theta Analyser\_InputMsg' = \theta Analyser\_InputMsg~? \land Analyser\_CheckAndAdjustQ \land Analyser\_CheckAndAdjustV \land Analyser\_AdjustStops \land Analyser\_signalhistory' = Analyser\_signalhistory \cup Analyser\_signals? \land Analyser\_UpdateFailuresAck \land \Xi Analyser\_PumpCtrSystem \land \Xi Analyser\_ExpectedPumpStates \land \Xi Analyser\_Valve \land Analyser\_Equipment' \land \Xi Analyser\_EmergenyCond  ~]
\end{zed}

\begin{zed}
	Analyser\_DangerZone \defs [~  Analyser\_AnalyserState | Analyser\_qa\_1 \geq M\_1 \land Analyser\_qa\_2 \leq M\_2 \implies Analyser\_qa\_1 < N\_1 \land N\_2 < Analyser\_qa\_2  ~]
\end{zed}

\begin{zed}
	Analyser\_EmergencyStopCond \defs [~  Analyser\_AnalyserState | Analyser\_stops \geq 3 \lor Analyser\_DangerZone \lor Analyser\_emergencyCond = 1 \lor transmissionFailure \in Analyser\_signals  ~]
\end{zed}

\begin{zed}
	Analyser\_LevelBelowMin \defs [~  Analyser\_AnalyserState | M\_1 \leq Analyser\_qa\_1 < N\_1 \land Analyser\_qa\_2 \leq N\_2  ~]
\end{zed}

\begin{zed}
	Analyser\_LevelAboveMax \defs [~  Analyser\_AnalyserState | N\_1 \leq Analyser\_qa\_1 \land N\_2 < Analyser\_qa\_2 \leq M\_2  ~]
\end{zed}

\begin{zed}
	Analyser\_LevelInRange \defs [~  Analyser\_AnalyserState | N\_1 \leq Analyser\_qa\_1 \land Analyser\_qa\_2 \leq N\_2  ~]
\end{zed}

\begin{zed}
	Analyser\_RateZero \defs [~  Analyser\_VSensor | Analyser\_va\_1 = 0 \land Analyser\_va\_2 = 0  ~]
\end{zed}

\begin{zed}
	Analyser\_AllPhysicalUnitsOkay \defs [~  Analyser\_AnalyserState | \lnot Analyser\_QFailed \land \lnot Analyser\_VFailed \land \lnot Analyser\_PFailed \land \lnot Analyser\_PCFailed  ~]
\end{zed}

\begin{zed}
	Analyser\_OtherPhysicalUnitsFail \defs~\lnot Analyser\_QFailed \land \lnot Analyser\_AllPhysicalUnitsOkay
\end{zed}

\begin{zed}
	Analyser\_SteamBoilerWaiting \defs [~  Analyser\_AnalyserState | steamBoilerWaiting \in Analyser\_signalhistory  ~]
\end{zed}

\begin{zed}
	Analyser\_PhysicalUnitsReady \defs [~  Analyser\_AnalyserState | physicalUnitsReady \in Analyser\_signalhistory  ~]
\end{zed}

\begin{zed}
	Analyser\_HandleRepair \defs Analyser\_RepairEquipments \land Analyser\_EvalRepairFailureAck \land \Xi Analyser\_CValues \land \Xi Analyser\_Failures \land \Xi Analyser\_InputMsg \land \Xi Analyser\_StopSignalHis \land \Xi Analyser\_Valve \land \Xi Analyser\_ExpectedPumpStates \land \Xi Timer\_TimeState \land \Xi Controller\_ModeState \land \Xi Reporter\_ReporterState
\end{zed}

\begin{zed}
	Analyser\_PumpOp2 \defs \Xi Analyser\_QSensor \land \Xi Analyser\_VSensor \land \Xi Analyser\_CValues \land \Xi Analyser\_Failures \land \Xi Analyser\_InputMsg \land \Xi Analyser\_StopSignalHis \land \Xi Analyser\_EmergenyCond
\end{zed}

\begin{zed}
	Analyser\_SetExpectedPumpState \defs Analyser\_CalcExpectedPumpState \land Analyser\_SetValveState \land Analyser\_PumpOp2 \land \Xi Timer\_TimeState \land \Xi Controller\_ModeState \land \Xi Reporter\_ReporterState
\end{zed}

\begin{zed}
	Analyser\_OP\_valve \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_valve! : VState ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_valve! = Analyser\_valve  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_noacks \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_noacks! : \power UnitFailure ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_noacks! = Analyser\_noacks  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_pumpctr \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_pumpctr! : PumpIndex \fun Analyser\_PumpCtr ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_pumpctr! = Analyser\_pumpctr  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_qa\_2 \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_qa\_2! : NUMS ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_qa\_2! = Analyser\_qa\_2  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_repairs \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_repairs! : \power UnitFailure ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_repairs! = Analyser\_repairs  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_qst \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_qst! : SState ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_qst! = Analyser\_qst  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_vc\_1 \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_vc\_1! : NUMS ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_vc\_1! = Analyser\_vc\_1  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_signals \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_signals! : \power InputSignal ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_signals! = Analyser\_signals  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_failureacks \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_failureacks! : \power UnitFailure ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_failureacks! = Analyser\_failureacks  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_signalhistory \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_signalhistory! : \power InputSignal ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_signalhistory! = Analyser\_signalhistory  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_q \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_q! : NUMS ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_q! = Analyser\_q  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_pumpCtrState \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_pumpCtrState! : PumpIndex \fun InputPCState ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_pumpCtrState! = Analyser\_pumpCtrState  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_stops \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_stops! : NUMS ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_stops! = Analyser\_stops  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_va\_1 \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_va\_1! : NUMS ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_va\_1! = Analyser\_va\_1  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_qc\_2 \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_qc\_2! : NUMS ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_qc\_2! = Analyser\_qc\_2  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_vc\_2 \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_vc\_2! : NUMS ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_vc\_2! = Analyser\_vc\_2  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_expectedp \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_expectedp! : PumpIndex \fun InputPState ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_expectedp! = Analyser\_expectedp  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_qa\_1 \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_qa\_1! : NUMS ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_qa\_1! = Analyser\_qa\_1  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_expectedpc \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_expectedpc! : PumpIndex \fun InputPCState ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_expectedpc! = Analyser\_expectedpc  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_pta\_2 \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_pta\_2! : \{ 0 , P , 2 * P , 3 * P , 4 * P \} ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_pta\_2! = Analyser\_pta\_2  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_v \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_v! : NUMS ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_v! = Analyser\_v  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_vst \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_vst! : SState ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_vst! = Analyser\_vst  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_pumpState \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_pumpState! : PumpIndex \fun InputPState ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_pumpState! = Analyser\_pumpState  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_pta\_1 \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_pta\_1! : \{ 0 , P , 2 * P , 3 * P , 4 * P \} ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_pta\_1! = Analyser\_pta\_1  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_failures \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_failures! : \power UnitFailure ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_failures! = Analyser\_failures  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_qc\_1 \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_qc\_1! : NUMS ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_qc\_1! = Analyser\_qc\_1  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_va\_2 \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_va\_2! : NUMS ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_va\_2! = Analyser\_va\_2  ~]
\end{zed}

\begin{zed}
	Analyser\_OP\_emergencyCond \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_emergencyCond! : \{ 0 , 1 \} ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | Analyser\_emergencyCond! = Analyser\_emergencyCond  ~]
\end{zed}

\begin{zed}
	Analyser\_InitAnalyserState\_fOp \defs [~  \Xi Analyser\_AnalyserState ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | \lnot \pre Analyser\_InitAnalyserState  ~]
\end{zed}

\begin{zed}
	Analyser\_HandleRepair\_fOp \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_failureacks? : \power UnitFailure ; Analyser\_repairs? : \power UnitFailure ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | \lnot \pre Analyser\_HandleRepair  ~]
\end{zed}

\begin{zed}
	SchExpr\_2 \defs Analyser\_SetPumpCtr \land Analyser\_PumpOp \land \Xi Timer\_TimeState \land \Xi Controller\_ModeState \land \Xi Reporter\_ReporterState
\end{zed}

\begin{zed}
	SchExpr\_2\_fOp \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_pumpCtrState? : PumpIndex \fun InputPCState ; Analyser\_pumpState? : PumpIndex \fun InputPState ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | \lnot \pre SchExpr\_2  ~]
\end{zed}

\begin{zed}
	Analyser\_Analyse\_fOp \defs [~  \Xi Analyser\_AnalyserState ; Analyser\_signals? : \power InputSignal ; Analyser\_repairs? : \power UnitFailure ; Analyser\_pumpState? : PumpIndex \fun InputPState ; Analyser\_pumpCtrState? : PumpIndex \fun InputPCState ; Analyser\_q? : NUMS ; Analyser\_failureacks? : \power UnitFailure ; Analyser\_v? : NUMS ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | \lnot \pre Analyser\_Analyse  ~]
\end{zed}

\begin{zed}
	Analyser\_SetExpectedPumpState\_fOp \defs [~  \Xi Analyser\_AnalyserState ; vstate? : VAction ; pumpstate? : PumpIndex \fun InputPState ; \Xi Timer\_TimeState ; \Xi Controller\_ModeState ; \Xi Reporter\_ReporterState | \lnot \pre Analyser\_SetExpectedPumpState  ~]
\end{zed}

\begin{zed}
	Controller\_InitController \defs [~  Controller\_ModeState' ; Controller\_mode : Mode ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Reporter\_ReporterState | Controller\_mode' = initialisation  ~]
\end{zed}

\begin{zed}
	Controller\_OP\_mode \defs [~  \Xi Controller\_ModeState ; Controller\_mode! : Mode ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Reporter\_ReporterState | Controller\_mode! = Controller\_mode  ~]
\end{zed}

\begin{zed}
	Controller\_InitController\_fOp \defs [~  \Xi Controller\_ModeState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Reporter\_ReporterState | \lnot \pre Controller\_InitController  ~]
\end{zed}

\begin{zed}
	Controller\_AssgnOp3 \defs [~  \Delta Controller\_ModeState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Reporter\_ReporterState | Controller\_mode' = emergencyStop  ~]
\end{zed}

\begin{zed}
	Controller\_AssgnOp4 \defs [~  \Delta Controller\_ModeState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Reporter\_ReporterState | Controller\_mode' = normal  ~]
\end{zed}

\begin{zed}
	Controller\_AssgnOp5 \defs [~  \Delta Controller\_ModeState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Reporter\_ReporterState | Controller\_mode' = degraded  ~]
\end{zed}

\begin{zed}
	Controller\_AssgnOp6 \defs [~  \Delta Controller\_ModeState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Reporter\_ReporterState | Controller\_mode' = emergencyStop  ~]
\end{zed}

\begin{zed}
	Controller\_AssgnOp7 \defs [~  \Delta Controller\_ModeState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Reporter\_ReporterState | Controller\_mode' = emergencyStop  ~]
\end{zed}

\begin{zed}
	Controller\_AssgnOp8 \defs [~  \Delta Controller\_ModeState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Reporter\_ReporterState | Controller\_mode' = emergencyStop  ~]
\end{zed}

\begin{zed}
	Controller\_AssgnOp9 \defs [~  \Delta Controller\_ModeState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Reporter\_ReporterState | Controller\_mode' = rescue  ~]
\end{zed}

\begin{zed}
	Controller\_AssgnOp10 \defs [~  \Delta Controller\_ModeState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Reporter\_ReporterState | Controller\_mode' = degraded  ~]
\end{zed}

\begin{zed}
	Controller\_AssgnOp11 \defs [~  \Delta Controller\_ModeState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Reporter\_ReporterState | Controller\_mode' = normal  ~]
\end{zed}

\begin{zed}
	Controller\_AssgnOp12 \defs [~  \Delta Controller\_ModeState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Reporter\_ReporterState | Controller\_mode' = rescue  ~]
\end{zed}

\begin{zed}
	Controller\_AssgnOp13 \defs [~  \Delta Controller\_ModeState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Reporter\_ReporterState | Controller\_mode' = normal  ~]
\end{zed}

\begin{zed}
	Controller\_AssgnOp14 \defs [~  \Delta Controller\_ModeState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Reporter\_ReporterState | Controller\_mode' = degraded  ~]
\end{zed}

\begin{zed}
	Reporter\_InitReporter \defs [~  Reporter\_ReporterState' ; Reporter\_pumpCtrFailureDetection : \power UnitFailure ; Reporter\_mode : Mode ; Reporter\_signals : \power OutputSignal ; Reporter\_pumpFailureDetection : \power UnitFailure ; Reporter\_pumpCtrRepairedAcknowledgement : \power UnitFailure ; Reporter\_pumpState : PumpIndex \fun InputPState ; Reporter\_pumpRepairedAcknowledgement : \power UnitFailure ; Reporter\_valveSt : VAction ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | Reporter\_valveSt' = VNoChange \land \theta Reporter\_OutputMsg' = ((( \LET Reporter\_mode == initialisation ; Reporter\_signals ==~\emptyset ; Reporter\_pumpState == \{ 1 \mapsto pclosed , 2 \mapsto pclosed , 3 \mapsto pclosed , 4 \mapsto pclosed \} ; Reporter\_pumpFailureDetection ==~\emptyset ; Reporter\_pumpCtrFailureDetection ==~\emptyset ; Reporter\_pumpRepairedAcknowledgement ==~\emptyset ; Reporter\_pumpCtrRepairedAcknowledgement ==~\emptyset @ \theta Reporter\_OutputMsg )))  ~]
\end{zed}

\begin{zed}
	Reporter\_FailuresRepairs \defs [~  \Delta Reporter\_ReporterState ; noacks? : ( \power UnitFailure ) ; repairs? : ( \power UnitFailure ) ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | ( Reporter\_signals' = Reporter\_signals \cup ( \IF ( qfail \in noacks? ) \THEN \{ levelFailureDetection \} \ELSE \emptyset ) \cup ( \IF ( vfail \in noacks? ) \THEN \{ steamFailureDetection \} \ELSE \emptyset ) \cup ( \IF ( qfail \in repairs? ) \THEN \{ levelRepairedAcknowledgement \} \ELSE \emptyset ) \cup ( \IF ( vfail \in repairs? ) \THEN \{ steamRepairedAcknowledgement \} \ELSE \emptyset ) ) \land Reporter\_pumpFailureDetection' = noacks? \cap \{ i : PumpIndex @ pfail~i \} \land Reporter\_pumpCtrFailureDetection' = noacks? \cap \{ i : PumpIndex @ pcfail~i \} \land Reporter\_pumpRepairedAcknowledgement' = repairs? \cap \{ i : PumpIndex @ pfail~i \} \land Reporter\_pumpCtrRepairedAcknowledgement' = repairs? \cap \{ i : PumpIndex @ pcfail~i \} \land Reporter\_mode' = Reporter\_mode \land Reporter\_valveSt' = Reporter\_valveSt \land Reporter\_pumpState' = Reporter\_pumpState  ~]
\end{zed}

\begin{zed}
	Reporter\_OP\_valveSt \defs [~  \Xi Reporter\_ReporterState ; Reporter\_valveSt! : VAction ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | Reporter\_valveSt! = Reporter\_valveSt  ~]
\end{zed}

\begin{zed}
	Reporter\_OP\_pumpState \defs [~  \Xi Reporter\_ReporterState ; Reporter\_pumpState! : PumpIndex \fun InputPState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | Reporter\_pumpState! = Reporter\_pumpState  ~]
\end{zed}

\begin{zed}
	Reporter\_OP\_pumpCtrFailureDetection \defs [~  \Xi Reporter\_ReporterState ; Reporter\_pumpCtrFailureDetection! : \power UnitFailure ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | Reporter\_pumpCtrFailureDetection! = Reporter\_pumpCtrFailureDetection  ~]
\end{zed}

\begin{zed}
	Reporter\_OP\_pumpCtrRepairedAcknowledgement \defs [~  \Xi Reporter\_ReporterState ; Reporter\_pumpCtrRepairedAcknowledgement! : \power UnitFailure ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | Reporter\_pumpCtrRepairedAcknowledgement! = Reporter\_pumpCtrRepairedAcknowledgement  ~]
\end{zed}

\begin{zed}
	Reporter\_OP\_mode \defs [~  \Xi Reporter\_ReporterState ; Reporter\_mode! : Mode ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | Reporter\_mode! = Reporter\_mode  ~]
\end{zed}

\begin{zed}
	Reporter\_OP\_pumpFailureDetection \defs [~  \Xi Reporter\_ReporterState ; Reporter\_pumpFailureDetection! : \power UnitFailure ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | Reporter\_pumpFailureDetection! = Reporter\_pumpFailureDetection  ~]
\end{zed}

\begin{zed}
	Reporter\_OP\_signals \defs [~  \Xi Reporter\_ReporterState ; Reporter\_signals! : \power OutputSignal ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | Reporter\_signals! = Reporter\_signals  ~]
\end{zed}

\begin{zed}
	Reporter\_OP\_pumpRepairedAcknowledgement \defs [~  \Xi Reporter\_ReporterState ; Reporter\_pumpRepairedAcknowledgement! : \power UnitFailure ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | Reporter\_pumpRepairedAcknowledgement! = Reporter\_pumpRepairedAcknowledgement  ~]
\end{zed}

\begin{zed}
	Reporter\_InitReporter\_fOp \defs [~  \Xi Reporter\_ReporterState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | \lnot \pre Reporter\_InitReporter  ~]
\end{zed}

\begin{zed}
	Reporter\_AssgnOp15 \defs [~  \Delta Reporter\_ReporterState ; m? : Nonemergency ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | Reporter\_mode' = m? \land Reporter\_pumpRepairedAcknowledgement' = Reporter\_pumpRepairedAcknowledgement \land Reporter\_pumpFailureDetection' = Reporter\_pumpFailureDetection \land Reporter\_pumpCtrRepairedAcknowledgement' = Reporter\_pumpCtrRepairedAcknowledgement \land Reporter\_valveSt' = Reporter\_valveSt \land Reporter\_signals' = Reporter\_signals \land Reporter\_pumpState' = Reporter\_pumpState \land Reporter\_pumpCtrFailureDetection' = Reporter\_pumpCtrFailureDetection  ~]
\end{zed}

\begin{zed}
	Reporter\_AssgnOp16 \defs [~  \Delta Reporter\_ReporterState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | Reporter\_signals' = Reporter\_signals \cup \{ programReady \} \land Reporter\_pumpRepairedAcknowledgement' = Reporter\_pumpRepairedAcknowledgement \land Reporter\_pumpFailureDetection' = Reporter\_pumpFailureDetection \land Reporter\_pumpCtrRepairedAcknowledgement' = Reporter\_pumpCtrRepairedAcknowledgement \land Reporter\_valveSt' = Reporter\_valveSt \land Reporter\_mode' = Reporter\_mode \land Reporter\_pumpState' = Reporter\_pumpState \land Reporter\_pumpCtrFailureDetection' = Reporter\_pumpCtrFailureDetection  ~]
\end{zed}

\begin{zed}
	Reporter\_AssgnOp17 \defs [~  \Delta Reporter\_ReporterState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | Reporter\_pumpState' = PumpIndex \cross \{ popen \} \land Reporter\_pumpRepairedAcknowledgement' = Reporter\_pumpRepairedAcknowledgement \land Reporter\_pumpFailureDetection' = Reporter\_pumpFailureDetection \land Reporter\_pumpCtrRepairedAcknowledgement' = Reporter\_pumpCtrRepairedAcknowledgement \land Reporter\_valveSt' = Reporter\_valveSt \land Reporter\_signals' = Reporter\_signals \land Reporter\_mode' = Reporter\_mode \land Reporter\_pumpCtrFailureDetection' = Reporter\_pumpCtrFailureDetection  ~]
\end{zed}

\begin{zed}
	Reporter\_AssgnOp18 \defs [~  \Delta Reporter\_ReporterState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | Reporter\_pumpState' = PumpIndex \cross \{ pclosed \} \land Reporter\_pumpRepairedAcknowledgement' = Reporter\_pumpRepairedAcknowledgement \land Reporter\_pumpFailureDetection' = Reporter\_pumpFailureDetection \land Reporter\_pumpCtrRepairedAcknowledgement' = Reporter\_pumpCtrRepairedAcknowledgement \land Reporter\_valveSt' = Reporter\_valveSt \land Reporter\_signals' = Reporter\_signals \land Reporter\_mode' = Reporter\_mode \land Reporter\_pumpCtrFailureDetection' = Reporter\_pumpCtrFailureDetection  ~]
\end{zed}

\begin{zed}
	Reporter\_AssgnOp19 \defs [~  \Delta Reporter\_ReporterState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | Reporter\_signals' = Reporter\_signals \cup \{ openValve \} \land Reporter\_valveSt' = openv \land Reporter\_pumpRepairedAcknowledgement' = Reporter\_pumpRepairedAcknowledgement \land Reporter\_pumpFailureDetection' = Reporter\_pumpFailureDetection \land Reporter\_pumpCtrRepairedAcknowledgement' = Reporter\_pumpCtrRepairedAcknowledgement \land Reporter\_mode' = Reporter\_mode \land Reporter\_pumpState' = Reporter\_pumpState \land Reporter\_pumpCtrFailureDetection' = Reporter\_pumpCtrFailureDetection  ~]
\end{zed}

\begin{zed}
	Reporter\_AssgnOp20 \defs [~  \Delta Reporter\_ReporterState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | Reporter\_signals' = Reporter\_signals \cup \{ closeValve \} \land Reporter\_valveSt' = closev \land Reporter\_pumpRepairedAcknowledgement' = Reporter\_pumpRepairedAcknowledgement \land Reporter\_pumpFailureDetection' = Reporter\_pumpFailureDetection \land Reporter\_pumpCtrRepairedAcknowledgement' = Reporter\_pumpCtrRepairedAcknowledgement \land Reporter\_mode' = Reporter\_mode \land Reporter\_pumpState' = Reporter\_pumpState \land Reporter\_pumpCtrFailureDetection' = Reporter\_pumpCtrFailureDetection  ~]
\end{zed}

\begin{zed}
	Reporter\_AssgnOp21 \defs [~  \Delta Reporter\_ReporterState ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | Reporter\_mode' = emergencyStop \land Reporter\_pumpRepairedAcknowledgement' = Reporter\_pumpRepairedAcknowledgement \land Reporter\_pumpFailureDetection' = Reporter\_pumpFailureDetection \land Reporter\_pumpCtrRepairedAcknowledgement' = Reporter\_pumpCtrRepairedAcknowledgement \land Reporter\_valveSt' = Reporter\_valveSt \land Reporter\_signals' = Reporter\_signals \land Reporter\_pumpState' = Reporter\_pumpState \land Reporter\_pumpCtrFailureDetection' = Reporter\_pumpCtrFailureDetection  ~]
\end{zed}

\begin{zed}
	Reporter\_FailuresRepairs\_fOp \defs [~  \Xi Reporter\_ReporterState ; noacks? : ( \power UnitFailure ) ; repairs? : ( \power UnitFailure ) ; \Xi Timer\_TimeState ; \Xi Analyser\_AnalyserState ; \Xi Controller\_ModeState | \lnot \pre Reporter\_FailuresRepairs  ~]
\end{zed}

\end{document}
