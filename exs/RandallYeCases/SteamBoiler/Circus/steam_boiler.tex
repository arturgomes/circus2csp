\documentclass{report} %

\usepackage{vmargin}
\setpapersize{A4}
\setmarginsrb{25mm}{20mm}{25mm}{20mm}{12pt}{11mm}{0pt}{10mm}

\usepackage[color]{circus}
\usepackage{savesym}
\savesymbol{Let}
\savesymbol{tick}
\savesymbol{Within}
\usepackage{cspsymb}
\restoresymbol{TXF}{Within}
\restoresymbol{TXF}{Let}
\restoresymbol{TXF}{tick}
\def\fuzz{{\large\it f\kern0.1em}{\normalsize\sc uzz}}
\renewcommand{\boolean}{{\mathbb B}}

\newcommand{\HandelC}{\textsf{\slshape Handel-C}}

\newcommand{\action}[1]{\mathsl{#1}}

\newcommand{\cbegin}{\mathbf{begin}}
\newcommand{\ccon}{\mathbf{con}}
\newcommand{\cend}{\mathbf{end}}
\newcommand{\chanevents}[1]{\{\!\mid #1 \mid\!\}}
\newcommand{\channelname}[1]{\mathsl{#1}}
\newcommand{\chan}{\mathbf{channel}}
\newcommand{\compresslist}{\itemsep=0pt \parskip=0pt}
\newcommand{\cprocess}{\mathbf{process}}
\newcommand{\cvar}{\mathbf{var}}
\newcommand{\eventname}[1]{\mathsl{#1}}
\newcommand{\processname}[1]{\mathsl{#1}}

\newcommand{\event}[1]{\mathsl{#1}}

\newcommand{\T}[1]{\texttt{#1}}

\newcommand{\B}[1]{\textbf{#1}}
\newcommand{\I}[1]{\textit{#1}}
\newcommand{\BI}[1]{\textit{\textbf{#1}}}
\newcommand{\TN}[1]{\textnormal{#1}}
\newcommand{\TTR}[1]{\textrm{#1}}
\newcommand{\mi}{\;|\;}
\newcommand{\ee}{&\quad::=\quad&}

\newcommand{\mrm}[1]{\mathrm{#1}} %Roman Font
\newcommand{\mbf}[1]{\mathbf{#1}} %Boldface Font
\newcommand{\msf}[1]{\mathsf{#1}} %Sans Serif Font
\newcommand{\mtt}[1]{\mathtt{#1}} %Typewriter Font
\newcommand{\miit}[1]{\mathit{#1}} %Italic Font
\newcommand{\mcl}[1]{\mathcal{#1}} %Calligraphic Front
\newcommand{\mnm}[1]{\mathnormal{#1}} %Normal Font

\begin{document}
\bibliographystyle{plain}

\title{The \Circus\ solution for the Steam Boiler Problem \\ (Corrected based on Jim Woodcock's original report)}
\author{Kangfeng Ye}
\date{\today}

\maketitle

\begin{abstract}
   \noindent This is a \Circus\ solution for the steam boiler control system problem. The specification is based on the original report back to 2002 by Jim Woodcock. Then we use the model checker to find errors and correct them afterwards. Therefore, it is the parsed, type-checked and model-checked version of \Circus\ solutions for the steam boiler problem. But by now, it is not completely model-checked, such as deadlock free, livelock free, and other properties due to the state space explosion problem.
\end{abstract}

\newpage %

\tableofcontents %

\newpage %
\chapter{Introduction}

This case study is based on the \Circus\ solution for the steam boiler control system problem~\cite{Abrial1995} from Jim Woodcock's original technical report~\cite{Woodcock2001a}. Additionally, I also read Leo Freitas's parsable steam boiler~\cite{Freitas2006} which is based on Jim Woodcock's original version as well. The purpose of this work is to formalise the solution by the model checking approach~\cite{Ye2015} we have proposed recently. It is worth noting that this document omits most of description of this model in the original version for brevity. Therefore, it can be better understood with references to the original document.

The steps to apply our approach to this case are listed below.
\begin{itemize}
    \item Step 1. Use $Circus2ZCSP$ translator to link this specification to the combination of CSP and Z---consequently two files named \emph{steam\_boiler\_z.tex} and \emph{steam\_boiler\_csp.csp} respectively.
    \item Step 2. Load the two files into modified ProB.
    \item Step 3. Then use ProB's model checking and animation functions to find errors. For errors, we modify this model to correct the problems, and then go back to ``Step 1'' again.
\end{itemize}

\section{Notes}
\begin{itemize}
    \item We rename all identifies with subscript digits to underline ($\_$) symbol. For example, $M_1$ to $M\_1$. That is due to the fact that subscript is not supported in CSP.
    \item According to Leo's version, for the appropriate typesetting of the expected text in Unicode, the freetype should be given a \LaTeX\ markup directives and a \LaTeX\ command. For brevity, this model omits this additional \LaTeX\ definitions.
\end{itemize}

\chapter{The $\mathsl{Timer}$}

The header of a \Circus\ model must include $circus\_toolkit$ as its parents.
\begin{zsection}
	\SECTION\ SteamBoiler \parents\ circus\_toolkit
\end{zsection}

\begin{circus}
    \circchannel\ clocktick, startcycle
\end{circus}

In the original model, the $time$ is initialised to $cyclelimit$ by an assignment $time := cyclelimit$. In this model, we modify it to a schema expression $\lschexpract InitTimer \rschexpract$. They are semantically equal. The reason of this modification is because, with this schema, in the final resultant $CSP \parallel Z$ model, $time$ is initialised in the early stage (during ``initialisation'' of the model) instead of in the later stage by the linked assignment in CSP. This will make the model checker easier to find the initial state.

The $\mod$ operator binds more tightly than $+$ operator (albeit, it is not the case in mathematics), thus
\[(~time := time + 1 \mod cycletime ~)\]
will not get the expected result. It is corrected by adding additional brackets.

\begin{circus}
\t1 cycletime == 5 \\ %
\t1 cyclelimit == cycletime - 1 \\ %
\t1 Time == 0 \upto cyclelimit \\
   \circprocess\ Timer ~\circdef~ \circbegin \\

     \t1 \circstate\ TimeState \defs [~ time: Time ~] \\ %
     \t1 InitTimer \defs [~ TimeState~' | time' = cyclelimit ~] \\
     \t1 TimeOp \defs [~ \Delta TimeState | time' \geq time ~] \\
     \t1 TCycle \circdef ((~time := (time + 1) \mod cycletime ~) \circseq \\ % rye: should not be time + 1 \mod cycletime
            \t2 ((\circif\ time = 0 \circthen startcycle \then \Skip\ \circelse\ time \neq 0 \circthen \Skip\ \circfi) \circseq \\ %
            \t2 (clocktick \then \lschexpract TCycle \rschexpract)))
            \\
      %\t1 \circspot time := cyclelimit \circseq TCycle \\
      \t1 \circspot \lschexpract InitTimer \rschexpract \circseq TCycle \\
   \circend
\end{circus}

\chapter{The $\mathsl{Analyser}$}
\section{Parameters}
$MAX\_NUM$ and $NUMS$ are introduced just for facilitating the animation.
\begin{zed}
  MAX\_NUM == \nat
\end{zed}

\begin{zed}
  NUMS == 0 \upto MAX\_NUM
\end{zed}

\begin{zed}
C == NUMS
\also
P == NUMS
\also
U\_1== NUMS
\also
U\_2 == NUMS
\also
W == NUMS
\end{zed}

\begin{zed}
M\_1~ == NUMS
\also
N\_1~ == NUMS
\also
N\_2~ == NUMS
\also
M\_2 == NUMS
% M\_1 \leq N\_1 \leq N\_2 \leq M\_2
% \where %
\end{zed}

\section{Sensor}

\begin{zed}
[X]
\also  Unit[X] \defs [~ a\_1~, a\_2: NUMS; st: X | a\_1 \leq a\_2 ~]
\end{zed}

\begin{zed}
  SState ::= sokay | sfailed
\end{zed}

\begin{zed}
  QSensor \defs Unit[SState][qa\_1~/a\_1~, qa\_2~/a\_2~, qst/st]
\end{zed}

\begin{zed}
  InitQSensor \defs [~ QSensor~' | qa\_1' = 0 \land qa\_2' = C \land qst' = sokay ~]
\end{zed}

\begin{zed}
  VSensor \defs Unit[SState][va\_1~/a\_1~, va\_2~/a\_2~, vst/st]
  \also %
  InitVSensor \defs [~ VSensor~' | va\_1' = 0 \land va\_2' = 0 \land vst' = sokay ~]
\end{zed}

\section{Pump}
\begin{zed}
  PState ::= popen | pwaiting | pclosed | pfailed
\end{zed}

$Pump0$ is rewritten to give a small size set $\set{0, P}$ as $pa$'s type to ease model checking. Since the values of $pa\_1$ and $pa\_2$ are implied from the pump state and not the input value from environment, it is safe to reduce the size of their type.
\begin{zed}
  % Pump0 == Unit[PState][pa\_1~/a\_1~, pa\_2~/a\_2~, pst/st]
  % rye: to decrease the size of set for pa
  Pump0 \defs [~ pa\_1~, pa\_2: \{0, P\}; pst: PState | pa\_1 \leq pa\_2 ~]
\end{zed}

\begin{zed}
  PumpOpen \defs [~ Pump0 | pst = popen \implies (pa\_1 = P \land pa\_2 = P) ~]
\end{zed}

\begin{zed}
  PumpWaitingOrClosed \defs [~ Pump0 | \\
      \t1 (pst = pwaiting \lor pst = pclosed) \implies (pa\_1 = 0 \land pa\_2 = 0) ~]
\end{zed}

\begin{zed}
  Pump \defs PumpOpen \land PumpWaitingOrClosed
\end{zed}

\begin{zed}
  InitPump \defs [~ PumpWaitingOrClosed~' | pst' = pclosed ~]
\end{zed}

\begin{zed}
  PCState ::= pcflow | pcnoflow | pcfailed \\
  PumpCtr0 \defs [~ Pump; pcst: PCState ~]
\end{zed}

\begin{zed}
  POpenPCFlowOrFailed \defs [~ PumpCtr0 | \\
      \t1 pst = popen \implies (pcst = pcflow \lor pcst = pcfailed) ~]
\end{zed}

\begin{zed}
  PWaitingPCNoFlowOrFailed \defs [~ PumpCtr0 | \\
      \t1 pst = pwaiting \implies (pcst = pcnoflow \lor pcst = pcfailed) ~]
\end{zed}

\begin{zed}
  PClosedPCNoFlowOrFailed \defs [~ PumpCtr0 | \\
      \t1 pst = pclosed \implies (pcst = pcnoflow \lor pcst = pcfailed) ~]
\end{zed}

\begin{zed}
  PFailedPCFlow \defs [~ PumpCtr0 | \\
      \t1 (pst = pfailed \land pcst = pcflow) \implies (pa\_1 = P \land pa\_2 = P) ~]
\end{zed}

\begin{zed}
  PFailedPCNoFlow \defs [~ PumpCtr0 | \\
      \t1 (pst = pfailed \land pcst = pcnoflow) \implies (pa\_1 = 0 \land pa\_2 = 0) ~]
\end{zed}

\begin{zed}
  PFailedPCFailed \defs [~ PumpCtr0 | \\
      \t1 (pst = pfailed \land pcst = pcfailed) \implies (pa\_1 = 0 \land pa\_2 = P) ~]
\end{zed}

\begin{zed}
  PumpCtr \defs \\ %
  \t1 POpenPCFlowOrFailed \land PWaitingPCNoFlowOrFailed \land \\ %
  \t1 PClosedPCNoFlowOrFailed \land PFailedPCFlow \land PFailedPCNoFlow \land  \\
  \t1 PFailedPCFailed
\end{zed}

\begin{zed}
  InitPumpCtr \defs [~ PumpCtr~' | InitPump \land pcst' = pcnoflow ~]
\end{zed}

\begin{zed}
  PumpIndex == 1 \upto 4
\end{zed}

The names of $pa\_1$ and $pa\_2$ are changed to $pta\_1$ and $pta\_2$ to avoid confusion. And their types are changed as well due to the same reason as $pa\_1$ and $pa\_2$ in $Pump0$.
\begin{schema}{PumpCtrSystem}
  pumpctr: PumpIndex \fun PumpCtr
  \\ %
  %pa\_1~, pa\_2: NUMS
  %rye: minimise the size of set for pa and use pta (pump total adjusted value) to differentiate
  pta\_1~, pta\_2: \{0, P, 2*P, 3*P, 4*P\}
  \where %
  pta\_1 =
   %
    ( pumpctr~1 ).pa\_1 + ( pumpctr~2 ).pa\_1 +  %
    \\ \t1 %
    ( pumpctr~3 ).pa\_1 + ( pumpctr~4 ).pa\_1   %
  \also %
  pta\_2 =
   %
    ( pumpctr~1 ).pa\_2 + ( pumpctr~2 ).pa\_2 +  %
    \\ \t1 %
    ( pumpctr~3 ).pa\_2 + ( pumpctr~4 ).pa\_2  %
\end{schema}

\begin{schema}{InitPumpCtrSystem}
  PumpCtrSystem~'
  \where %
  \exists InitPumpCtr @
  \\ %
  \t1 \forall i: PumpIndex @ pumpctr'~i = \theta PumpCtr~'
\end{schema}

\section{Valve}

A freetype $VAction$ and a schema $SetValveState$ are added to update valve's state according to the output signal sent to the physical units. If this program sends $openValve$ (or $closeValve$), then its action is $openv$ (or $closev$) and its state should be $vopen$ (or $vclosed$). Otherwise, if none of $openValve$ and $closeValve$ is issued, then it is $VNoChange$ and its state is unchanged.
\begin{zed}
  VState ::= vopen | vclosed
  \also %
  VAction ::= openv | closev | VNoChange
  \also %
  Valve \defs [~ valve: VState ~]
  \also %
  InitValve \defs [~ Valve~' | valve' = vclosed ~]
  \also %
  SetValveState \defs [~ \Delta Valve; vstate?: VAction | \\
      \t1 (vstate? = VNoChange \implies valve' = valve) \land \\
      \t1 (vstate? = openv \implies valve' = vopen) \land \\
      \t1 (vstate? = closev \implies valve' = vclosed) ~]
\end{zed}

\section{Expected values}
\begin{zed}
  CValues \defs [~ qc\_1~, qc\_2~, vc\_1~, vc\_2: NUMS ~]
\end{zed}

\begin{zed}
  InitCValues \defs [~ CValues~' | qc\_1' = 0 \land qc\_2' = C \land vc\_1' = 0 \land vc\_2' = W ~]
\end{zed}

\begin{zed}
  QLowerBoundValveOpen \defs [~ CValues; Valve | valve = vopen \land qc\_1 = 0 ~]
\end{zed}

\begin{zed}
  QLowerBoundValveClosed \defs
  \\ % rye: here pa\_1 should be total pa\_1 and not individual pump
  \t1 [~ CValues; QSensor; VSensor; PumpCtrSystem; Valve | valve = vclosed \land \\
     \t2 qc\_1 = max \{ 0, qa\_1 - 5 * va\_2 - 12 * U\_1 + 5 * pta\_1 \} ~]
\end{zed}

$qc\_2$ must be larger than or equal to 0.
\begin{zed}
  QUpperBound \defs
  \\ % rye: here pa\_2 should be total pa\_2 and not individual pump
  \t1 [~ CValues; QSensor; VSensor; PumpCtrSystem | \\ %
    % qc\_2 must >= 0
    \t2 qc\_2 = max\{0, min \{ C, qa\_2 - 5 * va\_1 + 12 * U\_2 + 5 * pta\_2 \}\} ~]
\end{zed}

\begin{zed}
  VLowerBound \defs [~ CValues; VSensor | vc\_1 = max \{ 0, va\_1 - 5 * U\_2 \} ~]
\end{zed}

$vc\_2 = min \{ W, va\_2 - 5 * U\_1 \}$ should be $vc\_2 = min \{ W, va\_2 + 5 * U\_1 \}$.
\begin{zed}
  % rye: should be +, instead of -
  % add  (va\_2 = 0 \implies vc\_2 = W)
  %VUpperBound \defs [~ CValues; VSensor | (va\_2 = 0 \implies vc\_2 = W) \lor (vc\_2 = min \{ W, va\_2 + 5 * U\_1 \}) ~]
  VUpperBound \defs [~ CValues; VSensor | (vc\_2 = min \{ W, va\_2 + 5 * U\_1 \}) ~]
\end{zed}

\begin{zed}
  InputPState == \{ popen, pclosed \}
\end{zed}

\begin{zed}
  InputPCState == \{ pcflow, pcnoflow \}
\end{zed}

\begin{schema}{ExpectedPumpStates}
  expectedp: PumpIndex \fun InputPState
  \\ %
  expectedpc: PumpIndex \fun InputPCState
\end{schema}

We add a schema $InitExpectedPumpStates$ to initialise the expected pump states though their initial states can be arbitrarily chosen. In addition, we use abnormal combination of the pump state $pclosed$ and the pump controller state $pcflow$ to indicate this initial value should not be used to check again input pump and pump controller states.

\begin{schema}{InitExpectedPumpStates}
    ExpectedPumpStates~'
    \where
    expectedp' = \{ 1 \mapsto pclosed, 2 \mapsto pclosed, 3 \mapsto pclosed, 4 \mapsto pclosed\}\\
    expectedpc' = \{1 \mapsto pcflow, 2 \mapsto pcflow, 3 \mapsto pcflow, 4 \mapsto pcflow\}\\
\end{schema}

This schema $CalcExpectedPumpState$ is added to update expected pump and pump controller states according to output pump states to the physical units. If the output pump state is $popen$, then the expected pump state is $popen$ as well and the pump controller state will be $pcflow$. Otherwise, $pclosed$ and $pcnoflow$ respectively. At the same time, the pump state is changed to $pwaiting$ in case the pump is expected to be opened from closed.
\begin{zed}
CalcExpectedPumpState \defs [
    \Delta ExpectedPumpStates; \\
    \Delta PumpCtrSystem; \\
    pumpstate?: PumpIndex \fun InputPState
    |
    (\forall i:PumpIndex @ ((expectedp'~i = pumpstate?~i) \land ( (pumpstate?~i = popen \land expectedpc'~i = pcflow) \lor (pumpstate?~i = pclosed \land expectedpc'~i = pcnoflow)))) \land \\
         (\forall i:PumpIndex @ ( (pumpctr'~i).pst = \IF (expectedp~i = pclosed \land pumpstate?~i = popen \land (pumpctr~i).pst = pclosed) \THEN pwaiting \ELSE (pumpctr~i).pst ) \land (pumpctr'~i).pcst = (pumpctr~i).pcst )]
\end{zed}

\begin{zed}
  Equipment0 \defs
  \\ %
  \t1
    QSensor \land VSensor \land PumpCtrSystem \land Valve \land \\ %
  \t1  CValues \land ExpectedPumpStates
\end{zed}

\section{Failures and repairs}

\begin{zed}
  QFailed \defs [~ QSensor | qst = sfailed ~]
  \also %
  VFailed \defs [~ VSensor | vst = sfailed ~]
  \also %
  PFailed \defs [~ PumpCtrSystem | \\
      \t1 (~ \exists i: PumpIndex \spot (pumpctr~i).pst = pfailed ~) ~]
  \also %
  PCFailed \defs [~ PumpCtrSystem | \\
      (~ \exists i: PumpIndex \spot (pumpctr~i).pcst = pcfailed ~) ~]
\end{zed}

\begin{zed}
  UnitFailure ::= qfail | vfail | pfail \ldata PumpIndex \rdata | pcfail \ldata PumpIndex \rdata
  \also %
  Failures \defs [~ failures, noacks: \power UnitFailure | noacks \subseteq failures ~]
\end{zed}

The original schema uses \[(~ u = pfail~i \land PFailed ~) \] to calculate pump failures. However, since $PFailed$ holds if at least one of pumps is failed, the schema results in pump failures for all pumps. Finally, the schema is updated to check pump failures against individual pump state directly by \[(~ u = pfail~i \land (pumpctr~i).pst = pfailed ~) \]. This is the same case as $pcfail$.

\begin{zed}
EquipmentFailures \defs [
  Equipment0;
  Failures
  | %
  failures =
  \{~ u: UnitFailure; i: PumpIndex |
    \t2 (~ u = qfail \land QFailed ~) \lor% {}
    \t2 (~ u = vfail \land VFailed ~) \lor %{} %
    \t2 (~ u = pfail~i \land (pumpctr~i).pst = pfailed ~) \lor% {}
    \t2 (~ u = pcfail~i \land (pumpctr~i).pcst = pcfailed ~)
     \t1 @ u ~\}
]
\end{zed}

\begin{zed}
  InitFailures \defs [~ Failures~' | failures' = \emptyset \land noacks' = \emptyset ~]
\end{zed}

\begin{zed}
  FailuresExpected \defs
  \\ %
  \t1 [~ Failures; failureacks: \power UnitFailure | failureacks \subseteq noacks ~]
  \also %
  FailuresNotExpected \defs
  \\ %
  \t1 [~ Failures; failureacks: \power UnitFailure | \lnot (failureacks \subseteq noacks) ~]
  \also %
  AcceptFailureAcks \defs
  \\ %
  \t1 [~ \Delta Failures; FailuresExpected | noacks' = noacks \setminus failureacks ~]
\end{zed}

\begin{zed}
  RepairsExpected \defs
  \\ %
  \t1 [~ Failures; repairs: \power UnitFailure | repairs \subseteq failures ~]
  \also RepairsNotExpected \defs
  \\ %
  \t1 [~ Failures; repairs: \power UnitFailure | \lnot (repairs \subseteq failures) ~]
  \also %
  AcceptRepairs \defs [~ \Delta Failures; RepairsExpected | \\ %
    \t1 failures' = failures \setminus repairs \land noacks' = noacks \setminus repairs ~]
\end{zed}

The schema $UpdateFailuresAck$ is added to update $noacks$ according to input $failureacks?$ and $repairs?$.
\begin{itemize}
    \item For the new failures identified in this cycle, we add them to $noacks$ to state they are not acknowledged.
    \item If $failureacks?$ is accepted, that is $failureacks? \subseteq noacks$, we take these acknowledged failures  out of $noacks$.
    \item If $repairs?$ is accepted, that is $repairs? \subseteq failures$, we take these repaired failures  out of $noacks$.
\end{itemize}

\begin{zed}
UpdateFailuresAck \defs [
    \Delta Failures; \\
    failureacks?: \power UnitFailure; \\
    repairs?: \power UnitFailure
    |
    (\exists newnoacks: \power UnitFailure @ (
        \t1 (newnoacks = noacks \cup (failures' \setminus failures)) \land
        \t1 ( (((failureacks? \subseteq noacks) \land (repairs? \subseteq failures)) \implies (noacks' = newnoacks \setminus (failureacks? \cup repairs?))) \land (((failureacks? \subseteq noacks) \land \lnot (repairs? \subseteq failures)) \implies (noacks' = newnoacks \setminus failureacks?)) \land ((\lnot (failureacks? \subseteq noacks) \land (repairs? \subseteq failures)) \implies (noacks' = newnoacks \setminus repairs?)) \land ((\lnot (failureacks? \subseteq noacks) \land \lnot (repairs? \subseteq failures)) \implies (noacks' = newnoacks)) )
    ))]
\end{zed}

\begin{zed}
  Equipment \defs (~ QLowerBoundValveOpen \lor QLowerBoundValveClosed ~) \land  QUpperBound \land VLowerBound \land VUpperBound \land ExpectedPumpStates \land EquipmentFailures
\end{zed}

In $InitEquipment$, expected pump and pump controller states and valve state are initialised as well.
\begin{zed}
  InitEquipment \defs Equipment0~' \land InitQSensor \land InitVSensor \land \\
    \t1 InitPumpCtrSystem \land InitCValues \land InitFailures \land \\
    \t1 InitExpectedPumpStates \land InitValve
    %InitPumpCtrSystem \land InitFailures \land InitExpectedPumpStates \land InitValve
\end{zed}

\subsection{Repair Failed Equipments}

This is a newly added section to repair equipments according to input $repairs?$.

For $QSensor$, if it is repaired, then its $qst$ will be $sokay$. Otherwise it stays unchanged.
\begin{zed} RepairQSensor \defs
  [ \Delta QSensor ; repairs?: \power UnitFailure |
  qfail \in repairs? \implies qst' = sokay \land
    qa\_1' = qa\_1 \land
    qa\_2' = qa\_2 \land
    qfail \notin repairs? \implies qst' = qst ]
\end{zed}

For $VSensor$, if it is repaired, then its $vst$ will be $sokay$. Otherwise it stays unchanged.
\begin{zed} RepairVSensor \defs [
  \Delta VSensor ;
  repairs?: \power UnitFailure
  |
  va\_1' = va\_1 \land
  va\_2' = va\_2 \land
  vfail \in repairs? \implies vst' = sokay \land
  vfail \notin repairs? \implies vst' = vst]
\end{zed}

If a pump controller is repaired, its state will be $pcflow$ if current pump state is $popen$, or its state will be $pcnoflow$ if current pump state is not $popen$.
\begin{schema}{RepairAPumpCtr}
  \Delta PumpCtr
  \where
  pst' = pst \\
  pst = popen \implies pcst' = pcflow \\
  pst \neq popen \implies pcst' = pcnoflow
\end{schema}

If a pump is repaired, its state will be $pclosed$ and its pump controller state stays unchanged.
\begin{schema}{RepairAPump}
  \Delta PumpCtr
  \where
  pst' = pclosed \\ % after repair, pump is going to closed state
  pcst' = pcst
\end{schema}

If both a pump and its controller are repaired, then the pump will be $pclosed$ and its controller will be $pcnoflow$.
\begin{schema}{RepairPumpCtrAndPump}
  \Delta PumpCtr
  \where
  pst' = pclosed \\
  pcst' = pcnoflow
\end{schema}

The schema $RepairPumps$ repairs all pumps and their controllers according to input $repairs?$.
\begin{zed}
RepairPumps \defs [
  \Delta PumpCtrSystem;
  repairs?: \power UnitFailure \\
  |
  (\forall i: PumpIndex @ (\exists PumpCtr; PumpCtr~' @ (
    \t2 (\theta PumpCtr~' = pumpctr'~i) \land (\theta PumpCtr = pumpctr~i) \land ((pfail~i \in repairs? \land pcfail~i \notin repairs?) \implies RepairAPump) \land ((pfail~i \notin repairs? \land pcfail~i \in repairs?) \implies RepairAPumpCtr) \land ((pfail~i \in repairs? \land pcfail~i \in repairs?) \implies RepairPumpCtrAndPump) \land ((pfail~i \notin repairs? \land pcfail~i \notin repairs?) \implies \theta PumpCtr~' = \theta PumpCtr)) ))]
\end{zed}

The $RepairEquipments$ tries to repair all equipments according to input $repairs?$. If $repairs?$ are accepted, all equipments will be repaired. Otherwise, all equipments will stay unchanged.
\begin{zed}
    RepairEquipments \defs (RepairsExpected[repairs?~/repairs~] \land RepairPumps \land RepairQSensor \land RepairVSensor) \lor ((RepairsNotExpected[repairs?~/repairs~]) \land \Xi PumpCtrSystem \land \Xi QSensor \land \Xi VSensor)
\end{zed}

A $emergencyCond$ state is introduced to indicate if both input $repairs?$ and $failureacks?$ are accepted or not. It is set to 1 if there is unaccepted $repairs?$ or $failureacks?$, or both. Otherwise, it is set to 0. This update happens in the beginning of each cycle and the value is used in the later of the cycle.
\begin{zed}
    % check if repairs? and failureacks? are acceptable or not
    EmergenyCond \defs [~ emergencyCond: \{0,1\} ~] \\ % rye
    MarkEmergencyCond \defs [~ \Delta EmergenyCond | emergencyCond' = 1 ~] \\
    ClearEmergencyCond \defs [~ \Delta EmergenyCond | emergencyCond' = 0 ~] \\
    EvalRepairFailureAck \defs\\
        \t1 (RepairsExpected[repairs?~/repairs~] \land \\
            \t2 FailuresExpected[~failureacks?~/failureacks~] \land \\
            \t2 ClearEmergencyCond) \lor ( (RepairsNotExpected[repairs?~/repairs~] \lor \\
            \t2 FailuresNotExpected[~failureacks?~/failureacks~]) \\
            \t2 \land MarkEmergencyCond)  \\
\end{zed}

\section{Input messages}

\begin{zed}
  InputSignal ::= \\
  \t1 stop | steamBoilerWaiting | physicalUnitsReady | transmissionFailure
\end{zed}

\begin{schema}{UnitState}
  pumpState: PumpIndex \fun InputPState \\ %
  pumpCtrState: PumpIndex \fun InputPCState \\ %
  q, v: NUMS
\end{schema}

\begin{schema}{InputMsg}
  signals: \power InputSignal \\ %
  UnitState \\ %
  failureacks, repairs: \power UnitFailure
\end{schema}

\section{Analysing messages}

The input value $x?$ should be checked against calculated values $c\_1$ and $c\_2$, instead of adjusted values $a\_1$ and $a\_2$.
\begin{zed}
  %Expected \defs [~ x?, a\_1~, a\_2 : NUMS | a\_1 \leq x? \leq a\_2 ~] \\
  Expected \defs [~ x?, c\_1~, c\_2 : NUMS | c\_1 \leq x? \leq c\_2 ~] \\ % rye: should check calculated value c_1 and c_2
  Unexpected \defs [~ x?, c\_1~, c\_2 : NUMS | \lnot (c\_1 \leq x? \leq c\_2 )~] \\ % rye: should check calculated value c_1 and c_2
  % Unexpected \defs \lnot Expected
\end{zed}

\begin{zed}
  Sensor \defs [~ \Delta Unit[SState]; c\_1~, c\_2~, c\_1'~, c\_2'~, x?: NUMS ~]
\end{zed}

\begin{schema}{CheckAndAdjustSensor}
  Sensor
  \where %
  Expected \implies st' = st \\ %
  Unexpected \implies st' = sfailed \\ %
  st' = sokay \implies a\_1' = x? \land a\_2' = x?  \\ %
  st' = sfailed \implies a\_1' = c\_1 \land a\_2' = c\_2
\end{schema}

\begin{zed}
  CheckAndAdjustQ \defs QSensor \land CheckAndAdjustSensor[q?/x?, qa\_1~/a\_1~, qa\_2~/a\_2~, qc\_1~/c\_1~, qc\_2~/c\_2~, qst/st, qa\_1'~/a\_1'~, qa\_2'~/a\_2'~, qc\_1'~/c\_1'~, qc\_2'~/c\_2'~, qst'/st']
  \also %
  CheckAndAdjustV \defs VSensor \land CheckAndAdjustSensor[v?/x?, va\_1~/a\_1~, va\_2~/a\_2~, vc\_1~/c\_1~, vc\_2~/c\_2~, vst/st,va\_1'~/a\_1'~, va\_2'~/a\_2'~, vc\_1'~/c\_1'~, vc\_2'~/c\_2'~, vst'/st']
\end{zed}

The $ExpectedPumpStateTBD$ checks if the expected pumps and their controllers state are undetermined. This happens in the initialisation stage when the expected states are unknown. And we indicate this in $InitExpectedPumpStates$.
\begin{zed}
ExpectedPumpStateTBD \defs [
  exppst: InputPState;
  exppcst: InputPCState
  |
  exppst = pclosed \land
  exppcst = pcflow]
\end{zed}

\begin{zed}
NotExpectedPumpStateTBD \defs [
  exppst: InputPState;
  exppcst: InputPCState
  |
  exppst \neq pclosed \lor
  exppcst \neq pcflow]
\end{zed}
If expected pump states are unknown, we adjust pumps and their controllers states according to input states only and will not check expected pump states.

\begin{schema}{CheckAndAdjustPumpTBD}
  \Delta PumpCtr \\ %
  pst?, exppst: InputPState \\ %
  pcst?, exppcst: InputPCState
  \where %
  % pst? = popen \land pcst? = pcflow    => pst' = popen \land pcst' = pcflow
  % pst? = popen \land pcst? = pcnoflow    => pst' = pfailed \land pcst' = pcnoflow
  % pst? = pclosed \land pcst? = pcnoflow    => pst' = pclosed \land pcst' = pcnoflow
  % pst? = pclosed \land pcst? = pcflow    => pst' = pfailed \land pcst' = pcflow
  ((pst? = popen \land pcst? = pcflow) \lor (pst? = pclosed \land pcst? = pcnoflow)) \\
  \t1  \implies (pst' = pst? \land pcst' = pcst?) \\
  (pst? = popen \land pcst? = pcnoflow) \implies (pst' = pfailed \land pcst' = pcnoflow) \\
  (pst? = pclosed \land pcst? = pcflow) \implies (pst' = pfailed \land pcst' = pcflow)
\end{schema}
However, if expected pump states are valid, we adjust pumps and their controllers states according to input and expected pump states together.
\begin{zed} CheckAndAdjustPump \defs [
  \Delta PumpCtr;
  pst?, exppst: InputPState;
  pcst?, exppcst: InputPCState
  |
  % pst, if it is failed, it is always failed until it is repaired.
  ((pst = pfailed \land pst' = pst) \lor
    (pst \neq pfailed \land
      (pst? = exppst \implies pst' = pst?) \land
      (pst? \neq exppst \implies pst' = pfailed)) ) \land
  % pcst, if it is failed, it is always failed until it is repaired.
  ((pcst = pcfailed \land pcst' = pcst) \lor
    (pcst \neq pcfailed \land
        (pcst? = exppcst \implies pcst' = pcst?) \land
        (pcst? \neq exppcst \implies pcst' = pcfailed)
    )
  ) ]
\end{zed}

\begin{schema}{PromotePumpCheck}
  \Delta PumpCtr \\ %
  \Delta PumpCtrSystem \\ %
  ExpectedPumpStates \\ %
  pst?, exppst: InputPState \\ %
  pcst?, exppcst: InputPCState \\ %
  pumpState?: PumpIndex \fun InputPState \\ %
  pumpCtrState?: PumpIndex \fun InputPCState \\ %
  i: PumpIndex
  \where %
  \theta PumpCtr = pumpctr~i \\ %
  \theta PumpCtr~' = pumpctr'~i \\ % rye: set dashed variables
  pst? = pumpState?~i \\ %
  pcst? = pumpCtrState?~i \\ %
  exppst = expectedp~i \\ %
  exppcst = expectedpc~i
\end{schema}
%
% \begin{zed}
%   % rye: change the predicate to forall then exists
%   SetPumpCtr \defs \forall i: PumpIndex @  (\exists PumpCtr; PumpCtr~'; pst?, exppst: PState; pcst?, exppcst: PCState  @
%     (PromotePumpCheck \land
%         ((CheckAndAdjustPumpTBD \land ExpectedPumpStateTBD) \lor
%         (CheckAndAdjustPump \land NotExpectedPumpStateTBD))))
%
% \end{zed}

The original predicate of $StopPresent$ has correct. Just because we introduce $NUMS$ for animation, the predicate of $StopPresent$ is modified too.
\begin{schema}{StopPresent}
  signals?: \power InputSignal \\ %
  stops, stops': NUMS
  \where %
  stop \in signals?  \\ %
  % stops' = stops + 1 % rye: continuously add by 1 will case it larger than NUMS. Therefore
  ((stops + 1 > MAX\_NUM \land stops' = stops) \lor (stops' = stops + 1))
\end{schema}

\begin{schema}{StopNotPresent}
  signals?: \power InputSignal \\ %
  stops, stops': NUMS
  \where %
  stop \notin signals? \land stops < 3 \\ %
  stops' = 0
\end{schema}

\begin{schema}{TooManyStops}
  signals?: \power InputSignal \\ %
  stops, stops': NUMS
  \where %
  stop \notin signals? \land stops \geq 3 \\ %
  stops' = stops
\end{schema}

\begin{zed}
  AdjustStops \defs StopPresent \lor StopNotPresent \lor TooManyStops
\end{zed}

\section{The $\mathsl{Analyser}$}

\begin{circus}
  \circchannel\ levelbelowmin, levelabovemax \\
  % rename failures to cfailures to avoid name conflict since failures is also a schema component
  \circchannel\ emergencystop, cfailures, levelokay, nonqfailure: \boolean \\
  \circchannel\ physicalunitsready, qfailure, sbwaiting, vzero: \boolean
\end{circus}

For animation purpose, $input$ has been split into seven small channels: $input1$, $input2$, $input3$, $input4$, $input5$, $input6$, and $input7$.
\begin{circus}
  % additional channel defs
  %\circchannel\ input: InputMsg \\

  % rye: rewrite input channel definition

  \circchannel\ input1: (\power InputSignal) \\
  \circchannel\ input2: (PumpIndex \fun InputPState) \\ % pumpState
  \circchannel\ input3: (PumpIndex \fun InputPCState) \\ % pumpCtrState
  \circchannel\ input4: (NUMS) \\ % q
  \circchannel\ input5: (NUMS) \\ % v
  \circchannel\ input6: (\power UnitFailure) \\ % failureacks
  \circchannel\ input7: (\power UnitFailure) \\ % repairs

  \circchannel\ startexec \\
\end{circus}

\begin{circus}
   \circchannel\ failuresrepairs: (\power UnitFailure) \cross (\power UnitFailure)
\end{circus}

\begin{circus}
  \circchannel\ pumps: (PumpIndex \fun InputPState) \cross VAction \\
  \circchannelset\ Information ==  \\ \t1
    \lchanset emergencystop, cfailures, levelabovemax, levelbelowmin, levelokay, \\ \t2
              nonqfailure, physicalunitsready, qfailure, sbwaiting, vzero \rchanset
\end{circus}

\begin{circus}
   \circprocess\ Analyser \circdef\ \circbegin \\
% \end{circus}
    % state variable lists ==
    % expectedp, expectedpc
    % failures, failureacks
    % noacks
    % pumpctr, pa_1, pa_2, pst, pcst
    % pumpState, pumpCtrState
    % qa_1, qa_2, qst, qc_1, qc_2, q
    % repairs
    % stops, signalhistory, signals
    % v
    % va_1, va_2, vst,
    % valve, vc_1, vc_2,
    % QSensor VSensor PumpCtrSystem Valve CValues ExpectedPumpStates Failures InputMsg
    % emergencyCond stores the information about if repairs? and failureacks? are expected or not. It is determined in the beginning of cycle
% \begin{circusaction}
   \t1 \circstate\ AnalyserState \defs [~ Equipment0; Failures; InputMsg; \\
       \t2 stops: NUMS; signalhistory: \power InputSignal; EmergenyCond ~] \\
% \end{circusaction}
    % variable list for SetPumpCtr \land PumpOp
    % qa_1, qa_2, qst,
    % va_1, va_2, vst,
    % valve,
    % qc_1, qc_2, vc_1, vc_2,
    % pumpctr, pa_1, pa_2
    % failures, noacks
    % pst, pcst
    % expectedp, expectedpc
    % pumpState?, pumpCtrState?
% \begin{zed}
    \t1 StopSignalHis \defs [~ stops: NUMS; signalhistory: \power InputSignal | \true~] \\ % rye
    \also PumpOp \circdef \lschexpract \Xi QSensor \land \Xi VSensor \land \Xi Valve \land \Xi CValues \land \Xi Failures \land \Xi ExpectedPumpStates \land \Xi InputMsg \land \Xi StopSignalHis \land \Xi EmergenyCond \rschexpract\\ % rye: EquipmentFailures also includes the PumpCtrSystem, so it is not right for SetPumpCtr to update pumpctr etc since it is \Xi before EquipmentFailures. So just include failures
% \end{zed}
    %\t1 PumpOp == \\ \t2 \Xi QSensor \land \Xi VSensor \land \Xi Valve \land \Xi CValues \land \Xi EquipmentFailures \land \Xi InputMsg \land \Xi StopSignalHis \\
    %\t1 PumpOp == \\ \t2 \Xi QSensor \land \Xi VSensor \land \Xi Valve \land \Xi CValues \land \Xi EquipmentFailures \\
    %\t1 InitAnalyserState \defs [~ AnalyserState~' | InitEquipment \land stops' = 0 \land signalhistory' = \emptyset ~] \\
    % rye: add initialisation for InputMsg
% For $InputMsg$, its initial value can be arbitrarily chosen and it will not have impacts on the behaviour of the program. To ease model checking, we set a specific initial value in $InitAnalyserState$.
% \begin{zed}
    \t1 InitAnalyserState \defs [~ AnalyserState~' |  InitEquipment \land stops' = 0 \land signalhistory' = \emptyset \land  emergencyCond' = 0 ~]


    \\Analyse \defs  [~ \Delta AnalyserState; InputMsg~? | \theta InputMsg~' = \theta InputMsg~? \land
        CheckAndAdjustQ \land CheckAndAdjustV \land AdjustStops \land
        signalhistory' = signalhistory \cup signals? \land
        UpdateFailuresAck \land
        \Xi PumpCtrSystem \land \Xi ExpectedPumpStates \land
         \Xi Valve \land Equipment~' \land \Xi EmergenyCond ~]\\
% \end{zed}
% In its predicate, $N\_1 < qa\_2$ should be $N\_2 < qa\_2$.
% \begin{zed}
    DangerZone \defs [~ AnalyserState | qa\_1 \geq M\_1 \land qa\_2 \leq M\_2  \implies qa\_1 < N\_1 \land N\_2 < qa\_2 ~] \\ %rye: should be N\_2 < qa_2
    % \not (qa_1 >= M_1 \land qa_2 <= M_2) \lor (qa_1 < N_1 \land N_2 < qa_2)
% \end{zed}
% Instead of checking $\lnot RepairsExpected \lor \lnot FailuresExpected$, we check $emergencyCond$, because in the later stage, the $failures$ and $noacks$ have been updated and not original values. Therefore, it is wrong to check $repairs?$ and $failureacks?$ against updated $failures$ and $noacks$.
% \begin{zed}
    \t1 EmergencyStopCond \defs [~ AnalyserState |
        %\t2 [~ AnalyserState | stops \geq 3 \lor DangerZone \lor \lnot RepairsExpected \lor \\
        %    \t2 \lnot FailuresExpected \lor transmissionFailure \in signals ~] \\
            stops \geq 3 \lor DangerZone \lor emergencyCond = 1 \lor
            transmissionFailure \in signals ~] \\
% \end{zed}
% \begin{zed}
    \t1 LevelBelowMin \defs [~ AnalyserState | M\_1 \leq qa\_1 < N\_1 \land qa\_2 \leq N\_2 ~] \\
    \t1 LevelAboveMax \defs [~ AnalyserState | N\_1 \leq qa\_1 \land N\_2 < qa\_2 \leq M\_2 ~] \\
    \t1 LevelInRange \defs [~ AnalyserState | N\_1 \leq qa\_1 \land qa\_2 \leq N\_2 ~] \\
    \t1 RateZero \defs [~ VSensor | va\_1 = 0 \land va\_2 = 0 ~] \\
    \t1 AllPhysicalUnitsOkay \defs \\
        \t2 [~ AnalyserState | \lnot QFailed \land \lnot VFailed \land \lnot PFailed \land \lnot PCFailed ~] \\
    \t1 OtherPhysicalUnitsFail \circdef \lschexpract \lnot QFailed \land \lnot AllPhysicalUnitsOkay \rschexpract\\
    \t1 SteamBoilerWaiting \defs \\
        \t2 [~ AnalyserState | steamBoilerWaiting \in signalhistory ~] \\
    \t1 PhysicalUnitsReady \defs \\
        \t2 [~ AnalyserState | physicalUnitsReady \in signalhistory ~] \\
% \end{zed}

% $HandleRepair$, as a schema expression, is added to repair equipments.
% \begin{zed}
    HandleRepair \circdef \lschexpract RepairEquipments \land EvalRepairFailureAck \land \Xi CValues  \land \Xi Failures \land \Xi InputMsg \land \Xi StopSignalHis \land  \Xi Valve \land \Xi ExpectedPumpStates \rschexpract\\
    %\t1 HandleRepair == RepairEquipments \land EvalRepairFailureAck \\
    %\t1 AnalyserCycle \circdef startcycle \then input~?msg \then (\lschexpract SetPumpCtr \land PumpOp \rschexpract \circseq \\
    %\t1 AnalyserCycle \circdef startcycle \then input~?signals?pumpState?pumpCtrState?q?v?failureacks?repairs \then (\lschexpract SetPumpCtr \land PumpOp \rschexpract \circseq \\
% \end{zed}
% \begin{circusaction}
    \t1 AnalyserCycle \circdef startcycle \then input1?signals \then input2?pumpState \then \\
        \t2 input3?pumpCtrState \then input4?q \then input5?v \then \\
        \t2 input6?failureacks \then input7?repairs \then \\
        ((\lschexpract HandleRepair \rschexpract) \circseq
        % (\lschexpract SetPumpCtr \land PumpOp \rschexpract)) \circseq %Artur : failing
        ((\lschexpract Analyse \rschexpract) \circseq
        (startexec \then \lschexpract InfoService \rschexpract))) \\
    %
% \end{circusaction}
% \begin{zed}
    \t1 PumpOp2 \circdef \lschexpract \Xi QSensor \land \Xi VSensor \land \Xi CValues \land \\
        \t2 \Xi Failures \land \Xi InputMsg \land \Xi StopSignalHis \land \\
        \t2 \Xi EmergenyCond \rschexpract\\ % rye: EquipmentFailures also includes the PumpCtrSystem, so it is not right for SetPumpCtr to update pumpctr etc since it is \Xi before EquipmentFailures. So just include failures
    \t1 SetExpectedPumpState \circdef \lschexpract \\
      CalcExpectedPumpState \land SetValveState \land PumpOp2 \rschexpract\\ %rye: add for updating expected pump state

    %\t1 SetValveStateOp == SetValveState \land \Xi QSensor \land \Xi VSensor \land \Xi CValues \land \Xi Failures \land \Xi PumpCtrSystem \land \Xi InputMsg \land \Xi StopSignalHis \land \Xi ExpectedPumpStates \\
    \t1 InfoService \circdef (OfferInformation \circseq\ InfoService) \extchoice \\
            \t2 (failuresrepairs~!noacks!repairs \then pumps~?pumpstate?vstate \then \\
            \t2 \lschexpract SetExpectedPumpState \rschexpract \circseq AnalyserCycle) \\ %rye
            %\t2 pumpState := pumpstate \circseq AnalyserCycle \\
    \t1 OfferInformation \circdef \\
            emergencystop.EmergencyStopCond \then \Skip
            \extchoice  sbwaiting.SteamBoilerWaiting \then \Skip
            \extchoice  vzero.RateZero \then \Skip
            \extchoice  \lcircguard LevelBelowMin \rcircguard \circguard\ levelbelowmin \then \Skip
            \extchoice \lcircguard LevelAboveMax \rcircguard \circguard levelabovemax \then \Skip
            \extchoice levelokay.LevelInRange \then \Skip
            \extchoice physicalunitsready.PhysicalUnitsReady \then \Skip
            % \extchoice cfailures.(\lnot AllPhysicalUnitsOkay) \then \Skip % not parsing...
            \extchoice cfailures.(\false) \then \Skip
            \extchoice qfailure.QFailed \then \Skip
            \extchoice  nonqfailure.OtherPhysicalUnitsFail \then \Skip \\
% \end{circusaction}
% \begin{circusaction}
    \t1 \circspot (\lschexpract InitAnalyserState \rschexpract \circseq\ AnalyserCycle) \\
% \end{circusaction}
% \begin{circus}
    \circend
\end{circus}

\begin{circus}
    \circchannelset\ TAnalyserInterface == \lchanset startcycle \rchanset \\
    \circprocess\ TAnalyser \circdef
    ((Timer \lpar TAnalyserInterface \rpar Analyser) \circhide TAnalyserInterface)
\end{circus}
\chapter{The $\mathsl{Controller}$}

\begin{zed}
  Mode ::= initialisation | normal | degraded | rescue | emergencyStop \\
  Nonemergency == \{ initialisation, normal, degraded, rescue \}
\end{zed}

\begin{circus}
    \circchannel\ startpumps, stoppumps, openvalve, closevalve, sendprogready \\
    %
    \circchannel\ reportmode: Mode \\
    \circchannel\ startreport, endreport \\
    \circchannelset\ Reports ==  \lchanset startpumps, stoppumps, openvalve, closevalve, sendprogready \rchanset \\
    \circchannelset\ TAControllerInterface ==
    ((\lchanset startexec \rchanset) \union Information)
\end{circus}
\section{The formal paragraphs}

\begin{circus}
    \circprocess\ Controller \circdef \circbegin \\
% \end{circus}
% \begin{circusaction}
        \t1 \circstate\ ModeState \defs [~ mode: Mode ~] \\
        \t1 InitController \defs [~ ModeState~' | mode' = initialisation ~] \\
        \t1 EnterMode \circdef \circvar m: Mode \circspot reportmode~!m \then (mode := m) \\
% \end{circusaction}
% In $emergencyStop$ mode, it is not necessary to adjust level $AdjustLevel$ and just end report by $endreport$.
% \begin{circusaction}
        \t1 ControllerCycle \circdef ((startexec \then startreport \then NewModeAnalysis )\circseq\ \\
                % adjust level should only happen when mode is not equal to emergency
                \t2 ((\lcircguard mode \neq emergencyStop \rcircguard \circguard AdjustLevel \extchoice \\
                \t2 \lcircguard mode = emergencyStop \rcircguard \circguard Skip) \circseq \\
                \t2 (endreport \then ControllerCycle))) \\
        \t1 NewModeAnalysis \circdef emergencystop.\true \then EnterMode~(emergencyStop) \\
            \t2 \extchoice
            emergencystop.\false \then ( \\
                \t3 \lcircguard mode = initialisation \rcircguard \circguard\ InitModeAnalysis \\
                \t3 \extchoice \lcircguard mode = normal \rcircguard \circguard\ NormalModeAnalysis \\
                \t3 \extchoice \lcircguard mode = degraded \rcircguard \circguard\ DegradedModeAnalysis \\
                \t3 \extchoice \lcircguard mode = rescue \rcircguard \circguard\ RescueModeAnalysis \\
                \t3 \extchoice \lcircguard (mode \notin Mode \setminus \{ emergencyStop \}) \rcircguard \circguard\ \Skip \\
                \t2 ) \\
                %\t3 \circif\ \ mode = initialisation \circthen InitModeAnalysis \\ %
                %\t3\ \ \circelse\ mode = normal \circthen NormalModeAnalysis \\
                %\t3\ \ \circelse\ mode = degraded \circthen DegradedModeAnalysis \\
                %\t3\ \ \circelse\ mode = rescue \circthen RescueModeAnalysis \\
                %\t3\ \ \circelse\ (mode \notin Mode \setminus \{ emergencyStop \}) \circthen \Skip \\
                %\t3 \circfi \\
            %\t2 \circseq AdjustLevel \\
% \end{circusaction}
% \begin{circusaction}
        \t1 InitModeAnalysis \circdef \\
            \t2 sbwaiting.\true \then \\
                \t3 (~ vzero.\true \then \\
                    \t4 (~ qfailure.\false \then \\
                        \t5 (~ physicalunitsready.\true \then \\
                                \t6 (~ levelokay.\true \then \\
                                    \t7 (~ cfailures.\false \then EnterMode~(normal) \extchoice \\
                                    \t7 cfailures.\true \then EnterMode~(degraded)~) \extchoice \\
                                 \t6  levelokay.\false \then EnterMode~(emergencyStop)~) \extchoice \\
                        \t5 physicalunitsready.\false \then \\
                                \t6 (~ levelokay.\true \then \\
                                    \t7 sendprogready \then \Skip \extchoice \\
                                \t6 levelokay.\false \then \Skip~) ~) \extchoice \\
                     \t4 qfailure.\true \then EnterMode~(emergencyStop)~) \extchoice \\
                \t3 vzero.\false \then EnterMode~(emergencyStop)~) \extchoice\\
            \t2 sbwaiting.\false \then \Skip \\
        \t1 NormalModeAnalysis \circdef \\
            \t2 cfailures.\false \then \Skip \extchoice \\
            \t2 qfailure.\true \then EnterMode~(rescue) \extchoice \\
            \t2 nonqfailure.\true \then EnterMode~(degraded) \\
        \t1 DegradedModeAnalysis \circdef \\
            \t2 qfailure.\false \then \\
                \t3 ( cfailures.\true \then \Skip \extchoice \\
                \t3 cfailures.\false \then EnterMode~(normal) ~) \\
            \t2 \extchoice qfailure.\true \then EnterMode~(rescue) \\
        \t1 RescueModeAnalysis \circdef \\
            \t2 qfailure.\true \then \Skip \extchoice \\
            \t2 qfailure.\false \then ( \\
                \t3 cfailures.\false \then EnterMode~(normal) \\
                \t3 \extchoice cfailures.\true \then EnterMode~(degraded)~) \\
% \end{circusaction}
% \begin{circusaction}
        \t1 AdjustLevel \circdef  levelbelowmin \then RaiseLevel \extchoice \\ %
            \t2 levelabovemax \then ReduceLevel \extchoice  \\ %
            \t2 levelokay.\true \then RetainLevel \\
        \t1 RaiseLevel \circdef StartPumps \circseq\ \\
            \t2 \circif mode = initialisation \circthen CloseValve \\
            \t2 \circelse mode \neq initialisation \circthen \Skip \\
            \t2 \circfi  \\
        \t1 ReduceLevel \circdef StopPumps \circseq\ \\
            \t2 \circif mode = initialisation \circthen OpenValve \\
            \t2\ \ \circelse mode \neq initialisation \circthen \Skip \\
            \t2 \circfi  \\
        \t1 RetainLevel \circdef StopPumps \circseq\ \\
            \t2 \circif mode = initialisation \circthen CloseValve \\
            \t2\ \ \circelse mode \neq initialisation \circthen \Skip \\
            \t2 \circfi  \\
        \t1 StartPumps \circdef startpumps \then \Skip        \\ %
        \t1 StopPumps \circdef stoppumps \then \Skip         \\ %
        \t1 OpenValve \circdef openvalve \then \Skip         \\ %
        \t1 CloseValve \circdef closevalve \then \Skip \\

        %\t1 \circspot mode := initialisation \circseq ControllerCycle \\
        \t1 \circspot \lschexpract InitController \rschexpract \circseq ControllerCycle \\

    \circend
\end{circus}

\begin{circus}
   \circprocess\ TAController \circdef \\
    \t1 ((TAnalyser \lpar TAControllerInterface \rpar Controller) \circhide TAControllerInterface)
\end{circus}
\chapter{The $\mathsl{Reporter}$}

\begin{zed}
  OutputSignal ::= programReady  | openValve | closeValve | \\
      \t1 levelFailureDetection | steamFailureDetection | \\
      \t1 levelRepairedAcknowledgement | steamRepairedAcknowledgement
\end{zed}

\begin{schema}{OutputMsg}
  mode: Mode
  \\ %
  signals: \power OutputSignal
  \\ %
  pumpState: PumpIndex \fun InputPState
  \\ %
  pumpFailureDetection: \power UnitFailure
  \\ %
  pumpCtrFailureDetection: \power UnitFailure
  \\ %
  pumpRepairedAcknowledgement: \power UnitFailure
  \\ %
  pumpCtrRepairedAcknowledgement: \power UnitFailure
\end{schema}

Similar to the $input$ channel, the $output$ channel is split too.
\begin{circus}
  % \circchannel\ output: OutputMsg %

  % rye: rewrite output channel definition
  \circchannel\ output1: Mode \\ % mode
  \circchannel\ output2: (\power OutputSignal) \\ %signals
  \circchannel\ output3: (PumpIndex \fun InputPState) \\ % pumpState
  \circchannel\ output4: (\power UnitFailure) \\ % pumpFailureDetection:
  \circchannel\ output5: (\power UnitFailure) \\ % pumpCtrFailureDetection:
  \circchannel\ output6: (\power UnitFailure) \\ %pumpRepairedAcknowledgement:
  \circchannel\ output7: (\power UnitFailure) %pumpCtrRepairedAcknowledgement:
                    \\
\end{circus}

\begin{circus}
    \circprocess\ Reporter \circdef \circbegin \\

        \t1 \circstate\ ReporterState \defs [~ OutputMsg; valveSt: VAction | true ~] \\ % rye
% \end{circusaction}
% Similar to the $Timer$ process and initial value of $InputMsg$, we initialise $OutputMsg$ as well though its initial value can be arbitrarily chosen.
% \begin{zed}
        \t1 InitReporter \defs [~ ReporterState~' | valveSt' = VNoChange
        % \land \\
        %     \t2 \theta OutputMsg~' = \\
        %     \t2 (\LET mode == initialisation;
        %         signals == \emptyset[OutputSignal]; \\
        %         \t3 pumpState == \{ 1 \mapsto pclosed, 2 \mapsto pclosed, \\
        %             \t4 3 \mapsto pclosed, 4 \mapsto pclosed\}; \\
        %         \t3 pumpFailureDetection == \emptyset[UnitFailure]; \\
        %         \t3 pumpCtrFailureDetection == \emptyset[UnitFailure]; \\
        %         \t3 pumpRepairedAcknowledgement == \emptyset[UnitFailure]; \\
        %         \t3 pumpCtrRepairedAcknowledgement == \emptyset[UnitFailure] \\
        %         \t3 @ \theta OutputMsg)
                 ~] \\ % rye
% \end{zed}
% \begin{circusaction}
        \t1 ReportService \circdef GatherReports \circseq ReportService \extchoice \\ %
            % after entering emergencyStop mode, Reporter will not accept any other adjust and just endreport
            \t2 ((reportmode.emergencyStop \then (mode := emergencyStop)) \circseq TidyUp) \extchoice \\%
            \t2 TidyUp \\
% \end{circusaction}
        % rye
        % qfail/vfail in noacks? => levelFailureDetection/steamFailureDetection in signal'
        % qfail/vfail in repairs? => levelRepairedAcknowledgement/steamRepairedAcknowledgement in signal'
        % pfail(n) in noacks? => pfail(n) in pumpFailureDetection'
        % pcfail(n) in noacks? => pcfail(n) in pumpCtrFailureDetection'
        % pfail(n) in repairs? => pfail(n) in pumpRepairedAcknowledgement'
        % pcfail(n) in repairs? => pcfail(n) in pumpCtrRepairedAcknowledgement'
% This schema is used to update $OutputMsg$ according to the inputs $noacks$ and $repairs$ from the $Analyser$ process.
% \begin{zed}
        \t1 FailuresRepairs \defs [~ \Delta ReporterState; noacks?: (\power UnitFailure); \\
            \t2 repairs?: (\power UnitFailure) | \\
             \t2   (signals' = signals \cup \\
                \t3 (\IF (qfail \in noacks?) \THEN \{ levelFailureDetection \} \ELSE \emptyset) \cup \\
                \t3 (\IF vfail \in noacks? \THEN \{ steamFailureDetection \} \ELSE \emptyset) \cup \\
                \t3 (\IF qfail \in repairs? \THEN \{ levelRepairedAcknowledgement \} \\
                    \t4 \ELSE \emptyset) \cup \\
                \t3 (\IF vfail \in repairs? \THEN \{ steamRepairedAcknowledgement \} \\
                    \t4 \ELSE \emptyset)) \land \\
             \t2   pumpFailureDetection' = \\
                \t3 noacks? \cap \{ i:PumpIndex @ pfail~i \} \land \\
             \t2   pumpCtrFailureDetection' = \\
                \t3 noacks? \cap \{ i:PumpIndex @ pcfail~i \} \land \\
             \t2   pumpRepairedAcknowledgement' = \\
                \t3 repairs? \cap \{ i:PumpIndex @ pfail~i \} \land \\
             \t2   pumpCtrRepairedAcknowledgement' = \\
                \t3 repairs? \cap \{ i:PumpIndex @ pcfail~i \} \land \\
             \t2   mode' = mode \land valveSt' = valveSt \land pumpState' = pumpState
            ~] \\
% \end{zed}
% \begin{circusaction}
        \t1 TidyUp \circdef ((endreport \then failuresrepairs~?noacks?repairs
        \then \Skip) \circseq \\
        % \then \lschexpract FailuresRepairs \rschexpract) \circseq \\
            %\t3 output~!( \theta OutputMsg ) \then \\
            %rye
            % \t3 output~!mode!signals!pumpState!pumpFailureDetection!pumpCtrFailureDetection!pumpRepairedAcknowledgement!pumpCtrRepairedAcknowledgement \then \\
            \t2 (output1!mode \then output2!signals \then output3!pumpState \then \\
            \t2 output4!pumpFailureDetection \then output5!pumpCtrFailureDetection \then \\
            \t2 output6!pumpRepairedAcknowledgement \then \\
            \t2 output7!pumpCtrRepairedAcknowledgement \then \\
            % \t3 pumps~!pumpState \then Reporter \\
            \t2 pumps~!pumpState!valveSt \then \Skip)) \\ % change to Skip since \circmu X is added in its main action
        \t1 GatherReports \circdef \Extchoice m: Nonemergency \circspot (reportmode.m \then (mode := m))
                    \\ %
                    \t3 \extchoice
                    \\ %
                    \t3 sendprogready \then (signals := signals \cup \{ programReady \})
                    \\ %
                    \t3 \extchoice
                    \\ %
                    \t3 startpumps \then (pumpState := PumpIndex \cross \{ popen \})
                    \\ %
                    \t3 \extchoice
                    \\ %
                    \t3 stoppumps \then (pumpState := PumpIndex \cross \{ pclosed \})
                    \\ %
                    \t3 \extchoice
                    \\ %
                    \t3 openvalve \then (signals, valveSt := signals \cup \{ openValve \}, openv)
                    \\ %
                    \t3 \extchoice
                    \\ %
                    \t3 closevalve \then (signals, valveSt := signals \cup \{ closeValve \}, closev) \\
% \end{circusaction}
% \begin{circusaction}
        \t1 \circspot \circmu X \circspot startreport \then \lschexpract InitReporter \rschexpract \circseq ReportService \circseq X \\
% \end{circusaction}
% \begin{circus}
        \circend
\end{circus}

\begin{circus}
   %\circchannelset\ TACReporterInterface == Reports\ \cup \\
   %     \t1 \lchanset startreport, reportmode, endreport, failuresrepairs, pumps \rchanset  \\

   % rye: remove \cup operation in channelset to avoid timeout when calculating union_set in csp_sets.pl
   \circchannelset\ TACReporterInterface == \\
        \t1 \lchanset startpumps, stoppumps, openvalve, closevalve, sendprogready, \\
            \t2 startreport, reportmode, endreport, failuresrepairs, pumps \rchanset  \\

   \circprocess\ TACReporter \circdef \\
    \t1 (( TAController  \lpar TACReporterInterface \rpar  Reporter ) \circhide TACReporterInterface)
\end{circus}
\chapter{Steam Boiler}
\begin{circus}
  \circprocess\ SteamBoiler \circdef TACReporter
\end{circus}

% \bibliographystyle{splncs03}
% \bibliography{steam_boiler.bib}

\end{document}
