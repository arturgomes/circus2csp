-- This file is automatically generated by the Circus2ZCSP Translator V0.5
-- on Wed Jul 20 12:02:12 BST 2016
-- See https://github.com/RandallYe/Circus2ZCSP for more information.

-- Minimum and maximum integers for model checking. Make sure they are set in advance.
MININT = 0
MAXINT = 1

-- Maximum instances generated for iseq.  Make sure it is set in advance.
MAXINS = 3

-- include a set of libraries
include "lib_basic.csp"
include "lib_num.csp"
include "lib_card.csp"
include "lib_log.csp"
include "lib_set.csp"
include "lib_rel.csp"
include "lib_fun.csp"
include "lib_seq.csp"


-- Axiomatic definition (Constant)
-- They should be assigned manually to meet its type and predicate restriction
-- and match the values assigned in Z as well
-- The variables defined below should meet the predicate below
--       (MAX_ESEL == 3 and MAX_PID == 3)
MAX_ESEL = 3
MAX_PID = 3

-- type
Price = Nat

datatype ESID = ES.{1 .. MAX_ESEL}
datatype PID = PD.{1 .. MAX_PID}
datatype FStatus = fail.ESID | NA
datatype UStatus = uok | ufail


-- channel declarations
channel div
channel updateallmap : pfun(ESID, PID)
channel updatemap : pfun(ESID, PID)
channel updateallprice : pfun(PID, Price)
channel updateprice : pfun(PID, Price)
channel update
channel failures : pfun(PID, Set(FStatus))
channel resp : PID.FStatus
channel terminate
channel uupdate : ESID.Price
channel ures : ESID.UStatus
channel uinit,finishuinit
channel udisplay,finishudisplay
channel init,finishinit
channel display,finishdisplay
channel write : ESID.Price
channel read : ESID.Price
channel ondisplay : ESID
channel offdisplay : ESID
channel InitChecker_Init-- 
channel InitChecker_Init_fOp -- 
channel Controller1_Init-- 
channel Controller1_Init_fOp -- 
channel Controller1_UpdateMap: pfun(ESID, PID)-- !map
channel Controller1_UpdateMap_fOp: pfun(ESID, PID) -- !map
channel Controller1_UpdateAllMap: pfun(ESID, PID)-- !map
channel Controller1_UpdateAllMap_fOp: pfun(ESID, PID) -- !map
channel Controller1_NewPrice: pfun(PID, Price)-- !price
channel Controller1_NewPrice_fOp: pfun(PID, Price) -- !price
channel Controller1_AllNewPrice: pfun(PID, Price)-- !price
channel Controller1_AllNewPrice_fOp: pfun(PID, Price) -- !price
channel Controller1_AssgnOp0-- 
channel Controller1_AddOneFailure: FStatus.PID-- !fst!pid
channel Controller1_AddOneFailure_fOp: FStatus.PID -- !fst!pid
channel ESEL1_ES3_Init-- 
channel ESEL1_ES3_Init_fOp -- 
channel ESEL1_ES3_AssgnOp1: Price-- !x
channel ESEL1_ES3_AssgnOp2-- 
channel ESEL1_ES3_AssgnOp3-- 
channel ESEL1_ES1_Init-- 
channel ESEL1_ES1_Init_fOp -- 
channel ESEL1_ES1_AssgnOp4: Price-- !x
channel ESEL1_ES1_AssgnOp5-- 
channel ESEL1_ES1_AssgnOp6-- 
channel ESEL1_ES2_Init-- 
channel ESEL1_ES2_Init_fOp -- 
channel ESEL1_ES2_AssgnOp7: Price-- !x
channel ESEL1_ES2_AssgnOp8-- 
channel ESEL1_ES2_AssgnOp9-- 
channel Controller1_OP_pumap : pfun(ESID, PID)
channel Controller1_OP_ppmap : pfun(PID, Price)
channel Controller1_OP_response : pfun(PID, Set(FStatus))
channel ESEL1_ES3_OP_price : Price
channel ESEL1_ES3_OP_status : UStatus
channel ESEL1_ES1_OP_price : Price
channel ESEL1_ES1_OP_status : UStatus
channel ESEL1_ES2_OP_price : Price
channel ESEL1_ES2_OP_status : UStatus

-- channel set declarations
RespInterface = {| resp, terminate |}
ESELSystemInterface = {| updateallprice, updateprice, updatemap, updateallmap, update, ondisplay, offdisplay, write, read, failures |}
InterESELInterface1 = {| init, display, finishdisplay |}
ESELInterface1 = {| uupdate, ures, init, display, finishdisplay |}

-- hidden event
HIDE_CSPB = {|Controller1_OP_pumap, Controller1_OP_ppmap, Controller1_OP_response, ESEL1_ES3_OP_price, ESEL1_ES3_OP_status, ESEL1_ES1_OP_price, ESEL1_ES1_OP_status, ESEL1_ES2_OP_price, ESEL1_ES2_OP_status, InitChecker_Init, InitChecker_Init_fOp, Controller1_Init, Controller1_Init_fOp, Controller1_UpdateMap, Controller1_UpdateMap_fOp, Controller1_UpdateAllMap, Controller1_UpdateAllMap_fOp, Controller1_NewPrice, Controller1_NewPrice_fOp, Controller1_AllNewPrice, Controller1_AllNewPrice_fOp, Controller1_AssgnOp0, Controller1_AddOneFailure, Controller1_AddOneFailure_fOp, ESEL1_ES3_Init, ESEL1_ES3_Init_fOp, ESEL1_ES3_AssgnOp1, ESEL1_ES3_AssgnOp2, ESEL1_ES3_AssgnOp3, ESEL1_ES1_Init, ESEL1_ES1_Init_fOp, ESEL1_ES1_AssgnOp4, ESEL1_ES1_AssgnOp5, ESEL1_ES1_AssgnOp6, ESEL1_ES2_Init, ESEL1_ES2_Init_fOp, ESEL1_ES2_AssgnOp7, ESEL1_ES2_AssgnOp8, ESEL1_ES2_AssgnOp9|}

-- processes for variable storing and retrieving 

-- processes 
-- Divergent Process 
DIV = div -> STOP


InitChecker = 
   ( (
  (   InitChecker_Init ->  SKIP
   [] InitChecker_Init_fOp -> DIV
  ) ; ( ||| e:ESID @ (offdisplay.(e) -> SKIP)))  ; update -> SKIP) 

Controller1 = 
   ( (
  (   Controller1_Init ->  SKIP
   [] Controller1_Init_fOp -> DIV
  ) ; init -> SKIP)  ; 
  let X = 
     (
    (   
      (   
        (   updatemap?map -> 
          (   Controller1_UpdateMap!map ->  SKIP
           [] Controller1_UpdateMap_fOp!map -> DIV
          )
         [] updateallmap?map -> 
          (   Controller1_UpdateAllMap!map ->  SKIP
           [] Controller1_UpdateAllMap_fOp!map -> DIV
          )
        )
       [] 
        (   updateprice?price -> 
          (   Controller1_NewPrice!price ->  SKIP
           [] Controller1_NewPrice_fOp!price -> DIV
          )
         [] updateallprice?price -> 
          (   Controller1_AllNewPrice!price ->  SKIP
           [] Controller1_AllNewPrice_fOp!price -> DIV
          )
        )
      )
     []  ( (update -> (Controller1_AssgnOp0 ->  SKIP) ; Controller1_OP_pumap?pumap -> Controller1_OP_ppmap?ppmap -> (( (( ||| pid:dom(ppmap) @ (
      (   (member(pid, ran(pumap)) & ( ||| uid:dom(rres(pumap, {pid})) @ (uupdate.(uid).(fa(ppmap, pid)) -> ures.(uid)?rst -> 
        (   (rst == ufail & resp.(pid).((fail.uid)) -> SKIP)
         [] (rst == uok & SKIP)
        ))))
       [] (not member(pid, ran(pumap)) & resp.(pid).(NA) -> SKIP)
      ))) ; terminate -> SKIP)  [| RespInterface |] 
      let X = 
        (    (resp?pid?fst -> 
          (   Controller1_AddOneFailure!fst!pid ->  SKIP
           [] Controller1_AddOneFailure_fOp!fst!pid -> DIV
          ) ; X) 
         [] terminate -> SKIP
        )
      within X) \ RespInterface))  ; display -> finishdisplay -> Controller1_OP_response?response -> failures.(response) -> SKIP) 
    ) ; X) 
  within X) 

ESELS1 =  [| InterESELInterface1 |] eid:ESID @ (eid == (ES.2) & ESEL1_ES2 [] (eid == (ES.1) & ESEL1_ES1 [] eid == (ES.3) & ESEL1_ES3))

ESELSystem1 = ( Controller1 [| ESELInterface1 |] ESELS1 ) \ ESELInterface1

ESELSystem1InitChecker = InitChecker [| ESELSystemInterface |] ESELSystem1

ESEL1_ES3 = 
   ( (
  (   ESEL1_ES3_Init ->  SKIP
   [] ESEL1_ES3_Init_fOp -> DIV
  ) ; offdisplay.((ES.3)) -> init -> SKIP)  ; 
  let X = 
     (
    (    ( (uupdate.((ES.3))?x -> (ESEL1_ES3_AssgnOp1!x ->  SKIP) ; ESEL1_ES3_OP_price?price -> write.((ES.3)).(price) -> read.((ES.3))?y -> ESEL1_ES3_OP_price?price -> 
      (   (y == price & ures.((ES.3)).(uok) -> (ESEL1_ES3_AssgnOp2 ->  SKIP))
       [] ((y != price) & ures.((ES.3)).(ufail) -> (ESEL1_ES3_AssgnOp3 ->  SKIP))
      ))  ;  (display -> ESEL1_ES3_OP_status?status -> 
      (   (status == uok & ondisplay.((ES.3)) -> SKIP)
       [] (status == ufail & offdisplay.((ES.3)) -> SKIP)
      ) ; finishdisplay -> SKIP) ) 
     [] display -> offdisplay.((ES.3)) -> finishdisplay -> SKIP
    ) ; X) 
  within X) 

ESEL1_ES1 = 
   ( (
  (   ESEL1_ES1_Init ->  SKIP
   [] ESEL1_ES1_Init_fOp -> DIV
  ) ; offdisplay.((ES.1)) -> init -> SKIP)  ; 
  let X = 
     (
    (    ( (uupdate.((ES.1))?x -> (ESEL1_ES1_AssgnOp4!x ->  SKIP) ; ESEL1_ES1_OP_price?price -> write.((ES.1)).(price) -> read.((ES.1))?y -> ESEL1_ES1_OP_price?price -> 
      (   (y == price & ures.((ES.1)).(uok) -> (ESEL1_ES1_AssgnOp5 ->  SKIP))
       [] ((y != price) & ures.((ES.1)).(ufail) -> (ESEL1_ES1_AssgnOp6 ->  SKIP))
      ))  ;  (display -> ESEL1_ES1_OP_status?status -> 
      (   (status == uok & ondisplay.((ES.1)) -> SKIP)
       [] (status == ufail & offdisplay.((ES.1)) -> SKIP)
      ) ; finishdisplay -> SKIP) ) 
     [] display -> offdisplay.((ES.1)) -> finishdisplay -> SKIP
    ) ; X) 
  within X) 

ESEL1_ES2 = 
   ( (
  (   ESEL1_ES2_Init ->  SKIP
   [] ESEL1_ES2_Init_fOp -> DIV
  ) ; offdisplay.((ES.2)) -> init -> SKIP)  ; 
  let X = 
     (
    (    ( (uupdate.((ES.2))?x -> (ESEL1_ES2_AssgnOp7!x ->  SKIP) ; ESEL1_ES2_OP_price?price -> write.((ES.2)).(price) -> read.((ES.2))?y -> ESEL1_ES2_OP_price?price -> 
      (   (y == price & ures.((ES.2)).(uok) -> (ESEL1_ES2_AssgnOp8 ->  SKIP))
       [] ((y != price) & ures.((ES.2)).(ufail) -> (ESEL1_ES2_AssgnOp9 ->  SKIP))
      ))  ;  (display -> ESEL1_ES2_OP_status?status -> 
      (   (status == uok & ondisplay.((ES.2)) -> SKIP)
       [] (status == ufail & offdisplay.((ES.2)) -> SKIP)
      ) ; finishdisplay -> SKIP) ) 
     [] display -> offdisplay.((ES.2)) -> finishdisplay -> SKIP
    ) ; X) 
  within X) 

MAIN = ESELSystem1InitChecker


-- assertions 
assert MAIN :[ livelock free ]
assert MAIN :[ deadlock free [F] ]
assert MAIN :[ deadlock free [FD] ]

