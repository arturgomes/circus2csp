include "sequence_aux.csp"
include "function_aux.csp"

NatValue = {0..4}
INDEX = NatValue
MONEY = NatValue
channel pay : INDEX.INDEX.MONEY
channel transfer : INDEX.INDEX.MONEY
channel accept : INDEX
channel reject : INDEX
--------------------------------
-- The universe of values
 datatype UNIVERSE = IND.INDEX
--Conversions
valueIND(IND.v) = v

typeIND(x) = U_IND

tagIND(x) = IND

-- subtypes of UNIVERSE for IND
subtype U_IND = IND.INDEX

-- definition of NAME for the entire spec
datatype NAME = sv_value

-- Subtype definition for IND
b_IND1 = {(sv_value, IND.0)}
subtype NAME_IND = sv_value
NAMES_VALUES_IND = seq({seq({(n,v) | v <- typeIND(n)}) | n <- NAME_IND})

-- Bindings definitions for IND
BINDINGS_IND = {set(b) | b <- set(distCartProd(NAMES_VALUES_IND))}


--------------------------------
 -- mget, mset and terminate --
--------------------------------
channel mget, mset : NAME.UNIVERSE
channel terminate

--------------------------------
 -- MEMI --
--------------------------------
MEMI = {| mset,mget,terminate |}
channel lget, lset : NAME.UNIVERSE
channel lterminate
MEML = {| lset,lget,lterminate |}

Card(b_IND,i) =
  let
     Memory(b_IND) =
        ( ( ( [] n : dom(b_IND) @ mget.n.apply(b_IND,n) ->
      Memory(b_IND) )
      [] ( [] n : dom(b_IND) @ mset.n?nv:typeIND(n) ->
      Memory(over(b_IND,n,nv)) ))
      [] terminate -> SKIP)
     MemoryMerge(b_IND,ns) =
        ( ( ( [] n : dom(b_IND) @ lget.n.apply(b_IND,n) ->
      MemoryMerge(b_IND,ns) )
      [] ( [] n : dom(b_IND) @ lset.n?nv:typeIND(n) ->
      MemoryMerge(over(b_IND,n,nv),ns) ))
      [] lterminate ->
      (  ; bd : <b_IND> @   ; n : <y | y <- ns> @  mset.n.apply(bd,n) -> SKIP ))

  within ( ( ( mset.sv_value.(IND.0) ->
      ( let muCycle = mget.sv_value?v_sv_value:(typeIND(sv_value)) ->
      ( ( pay.i?j?n ->
      ( ( n > valueIND(v_sv_value) & reject.i -> SKIP )
      [] ( n <= valueIND(v_sv_value) & transfer.i.j.n ->
      accept.i ->
      ( n <= valueIND(v_sv_value) & mset.sv_value.(IND.(valueIND(v_sv_value) - n)) -> SKIP ) ))
      [] transfer?j.i?n ->
      mset.sv_value.(IND.(valueIND(v_sv_value) + n)) -> SKIP);
      muCycle ) within muCycle );
      terminate -> SKIP )
      [| MEMI |] Memory(b_IND))\MEMI )

assert Card(b_IND1,1) :[deadlock free]
