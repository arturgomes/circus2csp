include "sequence_aux.csp"
include "function_aux.csp"


RANGE = {0..2}
channel tick, time
channel out : (RANGE,RANGE)
channel inc, minsReq
channel ans : RANGE

datatype DIRECTION = LEFT | RIGHT

Sync = {| inc,minsReq,ans |}

--------------------------------
-- The universe of values
 datatype UNIVERSE = RAN.RANGE
--Conversions
valueRAN(RAN.v) = v

typeRAN(x) = U_RAN

tagRAN(x) = RAN

-- subtypes of UNIVERSE for RAN
subtype U_RAN = RAN.RANGE

-- definition of NAME for the entire spec
datatype NAME = sv_sec | sv_min

-- Subtype definition for RAN
b_RAN1 = {(sv_sec, RAN.0),(sv_min, RAN.0)}
subtype NAME_RAN = sv_sec | sv_min
NAMES_VALUES_RAN = seq({seq({(n,v) | v <- typeRAN(n)}) | n <- NAME_RAN})

-- Bindings definitions for RAN
BINDINGS_RAN = {set(b) | b <- set(distCartProd(NAMES_VALUES))}
NAMES_VALUES = seq({seq({(n,v) | v <- typeRAN(n)}) | n <- NAME})

-- Bindings definitions for RAN
BINDINGS = {set(b) | b <- set(distCartProd(NAMES_VALUES))}


-----------

--------------------------------
 -- mget, mset and terminate --
--------------------------------
channel mget, mset : NAME.UNIVERSE
channel terminate

--------------------------------
 -- MEMI --
--------------------------------
MEMI = {| mset,mget,terminate |}
channel lget, lset : NAME.UNIVERSE
channel lterminate
MEML = {| lset,lget,lterminate |}

MinutesAOG(b_RAN) =
  let
     Memory(b_RAN) =
        ( ( ( [] n : dom(b_RAN) @ mget.n.apply(b_RAN,n) ->
      Memory(b_RAN) )
      [] ( [] n : dom(b_RAN) @ mset.n?nv:typeRAN(n) ->
      Memory(over(b_RAN,n,nv)) ))
      [] terminate -> SKIP)
  within
     let  restrictRAN(bs) = dres(bs,{sv_sec, sv_min})
     within( ( ( mset.sv_min.(RAN.0) ->
      ( let X = mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      ( ( inc ->
      mset.sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 3) -> SKIP
      [] minsReq ->
      ans.valueRAN(v_sv_min) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |] Memory(restrictRAN(b_RAN)))\MEMI )


SecondsAOG(b_RAN) =
  let
     Memory(b_RAN) =
        ( ( ( [] n : dom(b_RAN) @ mget.n.apply(b_RAN,n) ->
      Memory(b_RAN) )
      [] ( [] n : dom(b_RAN) @ mset.n?nv:typeRAN(n) ->
      Memory(over(b_RAN,n,nv)) ))
      [] terminate -> SKIP)
  within
     let  restrictRAN(bs) = dres(bs,{sv_sec, sv_min})
     within( ( ( mset.sv_sec.(RAN.0) ->
      ( let X = mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
      ( ( tick ->
      mset.sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 3) ->
      mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
      (valueRAN(v_sv_sec) == 0 &
         inc -> SKIP [] valueRAN(v_sv_sec) != 0 &
         SKIP)
      [] time ->
      minsReq ->
      ans?t_sv_min ->
      mset.sv_min.(RAN.t_sv_min) ->
      out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |] Memory(restrictRAN(b_RAN)))\MEMI )

ChronometerFullAOG(b) = ( ( SecondsAOG(b) [| Sync |] MinutesAOG(b) ) \ Sync )

ChronoAOG(b_RAN) =
  let
     Memory(b_RAN) =
        ( ( ( [] n : dom(b_RAN) @ mget.n.apply(b_RAN,n) ->
      Memory(b_RAN) )
      [] ( [] n : dom(b_RAN) @ mset.n?nv:typeRAN(n) ->
      Memory(over(b_RAN,n,nv)) ))
      [] terminate -> SKIP)
     MemoryMerge(b_RAN,ns) =
        ( ( ( [] n : dom(b_RAN) @ lget.n.apply(b_RAN,n) ->
      MemoryMerge(b_RAN,ns) )
      [] ( [] n : dom(b_RAN) @ lset.n?nv:typeRAN(n) ->
      MemoryMerge(over(b_RAN,n,nv),ns) ))
      [] lterminate ->
      (  ; bd : <b_RAN> @   ; n : <y | y <- ns> @  mset.n.apply(bd,n) -> SKIP ))

  within
     let  restrictRAN(bs) = dres(bs,{sv_sec, sv_min})
     within( ( ( ( mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
      ( ( ( lset.sv_sec.(RAN.0) ->
      ( ( let X = lget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      lget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      lget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
      ( ( tick ->
      lset.sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 3) ->
      lget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
      (valueRAN(v_sv_sec) == 0 & inc -> SKIP
      [] valueRAN(v_sv_sec) != 0 & SKIP)
      [] time -> minsReq -> ans?t_sv_min ->
      mset.sv_min.(RAN.t_sv_min) ->
      mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
      out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEML |]
      MemoryMerge({(sv_min,v_sv_min),(sv_min,v_sv_min),(sv_sec,v_sv_sec)},<sv_sec>) )\MEML )
      [| Sync |]
      ( ( lset.sv_min.(RAN.0) ->
      ( ( let X = lget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      ( ( inc ->
      lset.sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 3) -> SKIP
      [] minsReq -> ans.valueRAN(v_sv_min) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEML |]
      MemoryMerge({(sv_min,v_sv_min),(sv_min,v_sv_min),(sv_sec,v_sv_sec)},<sv_min>) )\MEML ) )\Sync );
      terminate -> SKIP )
      [| MEMI |] Memory(restrictRAN(b_RAN)))\MEMI )


AChronoAOG(b_RAN) =
  let
     Memory(b_RAN) =
        ( ( ( [] n : dom(b_RAN) @ mget.n.apply(b_RAN,n) ->
      Memory(b_RAN) )
      [] ( [] n : dom(b_RAN) @ mset.n?nv:typeRAN(n) ->
      Memory(over(b_RAN,n,nv)) ))
      [] terminate -> SKIP)
     MemoryMerge(b_RAN,ns) =
        ( ( ( [] n : dom(b_RAN) @ lget.n.apply(b_RAN,n) ->
      MemoryMerge(b_RAN,ns) )
      [] ( [] n : dom(b_RAN) @ lset.n?nv:typeRAN(n) ->
      MemoryMerge(over(b_RAN,n,nv),ns) ))
      [] lterminate ->
      (  ; bd : <b_RAN> @   ; n : <y | y <- ns> @  mset.n.apply(bd,n) -> SKIP ))

  within
     let  restrictRAN(bs) = dres(bs,{sv_sec, sv_min})
     within( ( ( mset.sv_sec.(RAN.0) ->
      mset.sv_min.(RAN.0) ->
      ( let X = mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
      ( ( tick ->
      mset.sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 3) ->
      mset.sv_min.(RAN.valueRAN(v_sv_min)) ->
      mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
      (valueRAN(v_sv_sec) == 0 &
         mset.sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 3) ->
      mset.sv_sec.(RAN.valueRAN(v_sv_sec)) -> SKIP [] valueRAN(v_sv_sec) != 0 &
         SKIP)
      [] time ->
      out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |] Memory(restrictRAN(b_RAN)))\MEMI )


-- Oliveira et al


Minutes =
  let
    Memory(b) =
       ( ( ( [] n : dom(b) @ mget.n.apply(b,n) -> Memory(b) )
     [] ( [] n : dom(b) @ mset.n?nv:typeRAN(n) -> Memory(over(b,n,nv)) ))
     [] terminate -> SKIP)

  within
     let  restrictRAN(bs) = dres(bs,{sv_sec, sv_min})
     within |~| b:BINDINGS @  ( ( ( mset.sv_min.(RAN.0) ->
      ( let X = mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      ( ( inc ->
          mset.sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 3) -> SKIP
          [] minsReq -> ans.valueRAN(v_sv_min) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |] Memory(restrictRAN(b)))\MEMI )


Seconds =
  let
    Memory(b) =
       ( ( ( [] n : dom(b) @ mget.n.apply(b,n) -> Memory(b) )
     [] ( [] n : dom(b) @ mset.n?nv:typeRAN(n) -> Memory(over(b,n,nv)) ))
     [] terminate -> SKIP)

  within
     let  restrictRAN(bs) = dres(bs,{sv_sec, sv_min})
     within |~| b:BINDINGS @  ( ( mset.sv_sec.(RAN.0) ->
      ( let X = mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
      ( ( tick ->
      mset.sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 3) ->
      mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
      (valueRAN(v_sv_sec) == 0 & inc -> SKIP
      [] valueRAN(v_sv_sec) != 0 & SKIP)
      [] time ->
      minsReq ->
      ans?t_sv_min ->
      mset.sv_min.(RAN.t_sv_min) ->
      out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP);
      X ) within X );
      terminate -> SKIP ) [| MEMI |] Memory(restrictRAN(b)))\MEMI

ChronometerFull = ( ( Seconds [| Sync |] Minutes ) \ Sync )

channel mleft,mright:BINDINGS

Chrono =
  let
     Memory(b) =
        ( ( ( [] n : dom(b) @ mget.n.apply(b,n) -> Memory(b) )
      [] ( [] n : dom(b) @ mset.n?nv:typeRAN(n) -> Memory(over(b,n,nv)) ))
      [] terminate -> SKIP)
     MemoryMerge(b,s) =
        ( ( ( [] n : dom(b) @ mget.n.apply(b,n) -> MemoryMerge(b,s) )
      [] ( [] n : dom(b) @ mset.n?nv:typeRAN(n) -> MemoryMerge(over(b,n,nv),s) ))
      [] terminate ->((s == LEFT & mleft!b -> SKIP ) [] (s == RIGHT & mright!b -> SKIP )))

  within
     let  restrictRAN(bs) = dres(bs,{sv_sec, sv_min})
     within |~| b : BINDINGS @ ( ( (( mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
      ( ( ( mset.sv_sec.(RAN.0) ->
      ( ( let X = mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
      ( ( tick ->
      mset.sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 3) ->
      mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
      (valueRAN(v_sv_sec) == 0 & inc -> SKIP
      [] valueRAN(v_sv_sec) != 0 & SKIP)
      [] time ->
      minsReq ->
      ans?t_sv_min ->
      mset.sv_min.(RAN.t_sv_min) ->
      mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
      out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |]
      MemoryMerge({(sv_min,v_sv_min),(sv_min,v_sv_min),(sv_sec,v_sv_sec)},LEFT) )\MEMI )
      [| Sync |]
      ( ( mset.sv_min.(RAN.0) ->
      ( ( let X = mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      ( ( inc ->
      mset.sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 3) -> SKIP
      [] minsReq ->
      ans.valueRAN(v_sv_min) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |]
      MemoryMerge({(sv_min,v_sv_min),(sv_min,v_sv_min),(sv_sec,v_sv_sec)},RIGHT) )\MEMI ) )\Sync )
      [| MRG |]
      ((mleft?l -> (; n: <sv_sec> @ mset.n!apply(l,n) -> SKIP))
        [] (mright?r -> (; n: <sv_min> @ mset.n!apply(r,n) -> SKIP))))
      [| MEMI |] Memory(restrictRAN(b))) \ MEMI )
MRG = {|mleft, mright|}

AChrono =
  let
     Memory(b) =
        ( ( ( [] n : dom(b) @ mget.n.apply(b,n) -> Memory(b) )
      [] ( [] n : dom(b) @ mset.n?nv:typeRAN(n) -> Memory(over(b,n,nv)) ))
      [] terminate -> SKIP)
  within
     let  restrictRAN(bs) = dres(bs,{sv_sec, sv_min})
     within |~| b : BINDINGS @ ( ( ( mset.sv_sec.(RAN.0) ->
      mset.sv_min.(RAN.0) ->
      ( let X = mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
      mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
      ( ( tick ->
      mset.sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 3) ->
      mset.sv_min.(RAN.valueRAN(v_sv_min)) ->
      mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
      (valueRAN(v_sv_sec) == 0 &
         mset.sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 3) ->
         mset.sv_sec.(RAN.valueRAN(v_sv_sec)) -> SKIP
      [] valueRAN(v_sv_sec) != 0 & SKIP)
      [] time ->
      out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |]
      Memory(restrictRAN(b)))\MEMI )
