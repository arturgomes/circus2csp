include "sequence_aux.csp"
include "function_aux.csp"


RANGE = {0..2}
assert AChrono :[deterministic [FD]]
assert Chrono :[deterministic [FD]]
assert AChrono\{|tick|} [FD= Chrono\{|tick|}
assert Chrono\{|tick|} [FD= AChrono\{|tick|}
datatype SIDE = LEFT | RIGHT

--------------------------------
-- The universe of values
 datatype UNIVERSE = RAN.RANGE
--Conversions
valueRAN(RAN.v) = v

typeRAN(x) = U_RAN

tagRAN(x) = RAN

-- subtypes of UNIVERSE for RAN
subtype U_RAN = RAN.RANGE

-- definition of NAME for the entire spec
datatype NAME = sv_Chrono_sec | sv_Chrono_min | sv_AChrono_sec | sv_AChrono_min

-- Subtype definition for RAN
 subtype NAME_RAN = sv_Chrono_sec | sv_Chrono_min | sv_AChrono_sec | sv_AChrono_min
NAMES_VALUES_RAN = seq({seq({(n,v) | v <- typeRAN(n)}) | n <- NAME_RAN})

-- Bindings definitions for RAN
BINDINGS_RAN = {set(b) | b <- set(distCartProd(NAMES_VALUES_RAN))}


--------------------------------
 -- mget, mset and terminate --
--------------------------------
channel mget, mset : NAME.UNIVERSE
channel lget, lset : NAME.UNIVERSE
channel terminate, lterminate

--------------------------------
 -- MEMI --
--------------------------------
MEMI = {| mset,mget,terminate |}
MEML = {| lset,lget,lterminate |}

Chrono =
	let
		Memory(b_RAN) =
			( ( ( [] n : dom(b_RAN) @ mget.n.apply(b_RAN,n) -> Memory(b_RAN) )
		 [] ( [] n : dom(b_RAN) @ mset.n?nv:typeRAN(n) -> Memory(over(b_RAN,n,nv)) ))
		 [] terminate -> SKIP)
		MemoryMerge(b_RAN,s,ns1,ns2) =
			( ( ( [] n : dom(b_RAN) @ lget.n.apply(b_RAN,n) -> MemoryMerge(b_RAN,s,ns1,ns2) )
		 [] ( [] n : dom(b_RAN) @ lset.n?nv:typeRAN(n) -> MemoryMerge(over(b_RAN,n,nv),s,ns1,ns2) ))
		 [] lterminate -> ( ( s == LEFT & (  ; l : <b_RAN> @   ; n : <y | y <- ns1> @  mset.n.apply(l,n) -> SKIP ) )
		 [] ( s == RIGHT & (  ; r : <b_RAN> @   ; n : <y | y <- ns2> @  mset.n.apply(r,n) -> SKIP ) )))
		within
		let  restrictRAN(bs) = dres(bs,{sv_Chrono_sec, sv_Chrono_min})
		within
			|~| b_RAN : BINDINGS_RAN @ ( ( ( ( mget.sv_Chrono_min?v_sv_Chrono_min:(typeRAN(sv_Chrono_min)) -> mget.sv_Chrono_sec?v_sv_Chrono_sec:(typeRAN(sv_Chrono_sec)) -> ( ( ( ( ( lset.sv_Chrono_sec.(RAN.0) -> SKIP ; ( let X = ( lget.sv_Chrono_min?v_sv_Chrono_min:(typeRAN(sv_Chrono_min)) -> lget.sv_Chrono_sec?v_sv_Chrono_sec:(typeRAN(sv_Chrono_sec)) -> ( tick -> ( lset.sv_Chrono_sec.(RAN.(valueRAN(v_sv_Chrono_sec) + 1) % 3) -> SKIP ; lget.sv_Chrono_sec?v_sv_Chrono_sec:(typeRAN(sv_Chrono_sec)) -> (valueRAN(v_sv_Chrono_sec) == 0 &
			 inc -> SKIP [] valueRAN(v_sv_Chrono_sec) != 0 &
			 SKIP) )
		 [] time -> minsReq -> ans?Chrono_min ->
		 out.(valueRAN(v_sv_Chrono_min),valueRAN(v_sv_Chrono_sec)) -> SKIP) ; X ) within X ) ) ; terminate -> SKIP )
		 [| MEML |]
		MemoryMerge({(sv_Chrono_sec,v_sv_Chrono_sec)},LEFT,<sv_Chrono_sec>,<sv_Chrono_min>) )\MEML )
		 [| Sync |]
		( ( ( ( lset.sv_Chrono_min.(RAN.0) -> SKIP ; ( let X = ( lget.sv_Chrono_min?v_sv_Chrono_min:(typeRAN(sv_Chrono_min)) -> ( inc -> lset.sv_Chrono_min.(RAN.(valueRAN(v_sv_Chrono_min) + 1) % 3) -> SKIP
		 [] minsReq -> ans.valueRAN(v_sv_Chrono_min) -> SKIP) ; X ) within X ) ) ; terminate -> SKIP )
		 [| MEML |]
		MemoryMerge({(sv_Chrono_min,v_sv_Chrono_min)},RIGHT,<sv_Chrono_sec>,<sv_Chrono_min>) )\MEML ) )\Sync ) ; terminate -> SKIP )
		 [| MEMI |]
		Memory(b_RAN) )\MEMI )

Sync = {| inc,minsReq,ans |}
channel ans : RANGE
channel inc, minsReq

AChrono =
	let
		Memory(b_RAN) =
			( ( ( [] n : dom(b_RAN) @ mget.n.apply(b_RAN,n) -> Memory(b_RAN) )
		 [] ( [] n : dom(b_RAN) @ mset.n?nv:typeRAN(n) -> Memory(over(b_RAN,n,nv)) ))
		 [] terminate -> SKIP)
		MemoryMerge(b_RAN,s,ns1,ns2) =
			( ( ( [] n : dom(b_RAN) @ lget.n.apply(b_RAN,n) -> MemoryMerge(b_RAN,s,ns1,ns2) )
		 [] ( [] n : dom(b_RAN) @ lset.n?nv:typeRAN(n) -> MemoryMerge(over(b_RAN,n,nv),s,ns1,ns2) ))
		 [] lterminate -> ( ( s == LEFT & (  ; l : <b_RAN> @   ; n : <y | y <- ns1> @  mset.n.apply(l,n) -> SKIP ) )
		 [] ( s == RIGHT & (  ; r : <b_RAN> @   ; n : <y | y <- ns2> @  mset.n.apply(r,n) -> SKIP ) )))
		within
		let  restrictRAN(bs) = dres(bs,{sv_AChrono_sec, sv_AChrono_min})
		within
			|~| b_RAN : BINDINGS_RAN @ ( ( ( ( mget.sv_AChrono_sec?v_sv_AChrono_sec:(typeRAN(sv_AChrono_sec)) -> mget.sv_AChrono_min?v_sv_AChrono_min:(typeRAN(sv_AChrono_min)) -> mset.sv_AChrono_sec.(RAN.0) -> mset.sv_AChrono_min.(RAN.0) -> SKIP ; ( let X = ( mget.sv_AChrono_min?v_sv_AChrono_min:(typeRAN(sv_AChrono_min)) -> mget.sv_AChrono_sec?v_sv_AChrono_sec:(typeRAN(sv_AChrono_sec)) -> ( tick -> ( mset.sv_AChrono_sec.(RAN.(valueRAN(v_sv_AChrono_sec) + 1) % 3) -> mset.sv_AChrono_min.(RAN.valueRAN(v_sv_AChrono_min)) -> SKIP ; mget.sv_AChrono_sec?v_sv_AChrono_sec:(typeRAN(sv_AChrono_sec)) -> (valueRAN(v_sv_AChrono_sec) == 0 &
			 mset.sv_AChrono_min.(RAN.(valueRAN(v_sv_AChrono_min) + 1) % 3) -> mset.sv_AChrono_sec.(RAN.valueRAN(v_sv_AChrono_sec)) -> SKIP [] valueRAN(v_sv_AChrono_sec) != 0 &
			 SKIP) )
		 [] time -> out.(valueRAN(v_sv_AChrono_min),valueRAN(v_sv_AChrono_sec)) -> SKIP) ; X ) within X ) ) ; terminate -> SKIP )
		 [| MEMI |]
		Memory(b_RAN) )\MEMI )

channel out : (RANGE,RANGE)
channel tick, time
