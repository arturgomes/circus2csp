include "sequence_aux.csp"
include "function_aux.csp"


RANGE = {1..2}
datatype ALARM = ON | OFF

-- assert AChrono :[deterministic [FD]]
assert Chrono :[deterministic [FD]]

datatype SIDE = LEFT | RIGHT

--------------------------------
-- The universe of values
 datatype UNIVERSE = ALA.ALARM | RAN.RANGE
--Conversions
valueALA(ALA.v) = v
valueRAN(RAN.v) = v

typeALA(x) = U_ALA
typeRAN(x) = U_RAN

tagALA(x) = ALA
tagRAN(x) = RAN

-- subtypes of UNIVERSE for ALA
subtype U_ALA = ALA.ALARM

-- subtypes of UNIVERSE for RAN
subtype U_RAN = RAN.RANGE

-- definition of NAME for the entire spec
datatype NAME = sv_WakeUpOK_sec | sv_WakeUpOK_min | sv_WakeUpOK_buzz | sv_WakeUp_sec | sv_WakeUp_min | sv_WakeUp_buzz | sv_Chrono_sec | sv_Chrono_min | sv_AChrono_sec | sv_AChrono_min

-- Subtype definition for RAN
 subtype NAME_RAN = sv_WakeUpOK_sec | sv_WakeUpOK_min | sv_WakeUp_sec | sv_WakeUp_min | sv_Chrono_sec | sv_Chrono_min | sv_AChrono_sec | sv_AChrono_min
NAMES_VALUES_RAN = seq({seq({(n,v) | v <- typeRAN(n)}) | n <- NAME_RAN})

-- Subtype definition for ALA
 subtype NAME_ALA = sv_WakeUpOK_buzz | sv_WakeUp_buzz
NAMES_VALUES_ALA = seq({seq({(n,v) | v <- typeALA(n)}) | n <- NAME_ALA})

-- Bindings definitions for RAN
BINDINGS_RAN = {set(b) | b <- set(distCartProd(NAMES_VALUES_RAN))}

-- Bindings definitions for ALA
BINDINGS_ALA = {set(b) | b <- set(distCartProd(NAMES_VALUES_ALA))}

BINDINGS = union(BINDINGS_ALA,BINDINGS_RAN)
BD(x) = Set(x)
--------------------------------
 -- mget, mset and terminate --
--------------------------------
channel mget, mset : NAME.UNIVERSE
channel mleft, mright : Set(BINDINGS)
channel terminate

--------------------------------
 -- MEMI --
--------------------------------
MEMI = {| mset,mget,terminate |}

channel snooze, radioOn

Chrono =
	let
		Memory(b_RAN) =
			( ( ( [] n : dom(b_RAN) @ mget.n.apply(b_RAN,n) -> Memory(b_RAN) )
		 [] ( [] n : dom(b_RAN) @ mset.n?nv:typeRAN(n) -> Memory(over(b_RAN,n,nv)) ))
		 [] terminate -> SKIP)
		MemoryMerge(b_RAN,s) =
			( ( ( [] n : dom(b_RAN) @ mget.n.apply(b_RAN,n) -> MemoryMerge(b_RAN,s) )
		 [] ( [] n : dom(b_RAN) @ mset.n?nv:typeRAN(n) -> MemoryMerge(over(b_RAN,n,nv),s) ))
		 [] terminate -> ( ( s == LEFT & mleft.b_RAN ->  SKIP )
		 [] ( s == RIGHT & mright.b_RAN ->  SKIP )))
		within
		let  restrictRAN(bs) = dres(bs,{sv_Chrono_sec, sv_Chrono_min})
		within
			|~| b_RAN : BINDINGS_RAN @ ( ( (( ( mget.sv_Chrono_min?v_sv_Chrono_min:(typeRAN(sv_Chrono_min)) -> mget.sv_Chrono_sec?v_sv_Chrono_sec:(typeRAN(sv_Chrono_sec)) -> ( ( ( ( ( ( ( mset.sv_Chrono_sec.(RAN.1) -> SKIP ; ( let X = ( mget.sv_Chrono_min?v_sv_Chrono_min:(typeRAN(sv_Chrono_min)) -> mget.sv_Chrono_sec?v_sv_Chrono_sec:(typeRAN(sv_Chrono_sec)) -> ( tick -> ( mset.sv_Chrono_sec.(RAN.(valueRAN(v_sv_Chrono_sec) + 1) % 3) -> SKIP ; mget.sv_Chrono_sec?v_sv_Chrono_sec:(typeRAN(sv_Chrono_sec)) -> (valueRAN(v_sv_Chrono_sec) == 1 &
			 inc -> SKIP [] valueRAN(v_sv_Chrono_sec) != 1 &
			 SKIP) )
		 [] time -> minsReq -> ans?WakeUpOK_min ->
		 out.(valueRAN(v_sv_Chrono_min),valueRAN(v_sv_Chrono_sec)) -> SKIP) ; X ) within X ) ) ; terminate -> SKIP )
		 [| MEMI |]
		MemoryMerge({(sv_Chrono_sec,v_sv_Chrono_sec)},LEFT) )\MEMI )
		 [| Sync |]
		( ( ( ( mset.sv_Chrono_min.(RAN.1) -> SKIP ; ( let X = ( mget.sv_Chrono_min?v_sv_Chrono_min:(typeRAN(sv_Chrono_min)) -> ( inc -> mset.sv_Chrono_min.(RAN.(valueRAN(v_sv_Chrono_min) + 1) % 3) -> SKIP
		 [] minsReq -> ans.valueRAN(v_sv_Chrono_min) -> SKIP) ; X ) within X ) ) ; terminate -> SKIP )
		 [| MEMI |]
		MemoryMerge({(sv_Chrono_min,v_sv_Chrono_min)},RIGHT) )\MEMI ) )
		 [| MEMI |]
		( mleft?l ->
		 ( ; n : <sv_Chrono_sec> @ mset.n.apply(l,n) -> SKIP )
		 ||| mright?r ->
		 ( ; n : <sv_Chrono_min> @ mset.n.apply(r,n) -> SKIP ) ) )\{| mleft,mright |} )\Sync ) ; terminate -> SKIP )\ {|mleft, mright|})
		 [| MEMI |]
		Memory(restrictRAN(b_RAN)) )\MEMI )

Sync = {| inc,minsReq,ans |}
channel ans : RANGE
channel inc, minsReq

channel out : (RANGE,RANGE)
channel tick, time
