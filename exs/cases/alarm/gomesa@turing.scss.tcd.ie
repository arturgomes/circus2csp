include "sequence_aux.csp"
include "function_aux.csp"


RANGE = {0..2}
datatype ALARM = ON | OFF

assert Chrono :[deterministic [FD]]
datatype SIDE = LEFT | RIGHT

--------------------------------
-- The universe of values
 datatype UNIVERSE = ALA.ALARM | RAN.RANGE
--Conversions
valueALA(ALA.v) = v
valueRAN(RAN.v) = v

typeALA(x) = U_ALA
typeRAN(x) = U_RAN

tagALA(x) = ALA
tagRAN(x) = RAN

-- subtypes of UNIVERSE for ALA
subtype U_ALA = ALA.ALARM

-- subtypes of UNIVERSE for RAN
subtype U_RAN = RAN.RANGE

-- definition of NAME for the entire spec
datatype NAME = sv_WakeUpOK_sec | sv_WakeUpOK_min | sv_WakeUpOK_buzz | sv_WakeUp_sec | sv_WakeUp_min | sv_WakeUp_buzz | sv_Chrono_sec | sv_Chrono_min | sv_AChrono_sec | sv_AChrono_min

-- Subtype definition for RAN
subtype NAME_RAN = sv_WakeUpOK_sec | sv_WakeUpOK_min | sv_WakeUp_sec | sv_WakeUp_min | sv_Chrono_sec | sv_Chrono_min | sv_AChrono_sec | sv_AChrono_min
NAMES_VALUES_RAN = seq({seq({(n,v) | v <- typeRAN(n)}) | n <- NAME_RAN})

-- Subtype definition for ALA
 subtype NAME_ALA = sv_WakeUpOK_buzz | sv_WakeUp_buzz
NAMES_VALUES_ALA = seq({seq({(n,v) | v <- typeALA(n)}) | n <- NAME_ALA})

-- Bindings definitions for RAN
BINDINGS_RAN = {set(b) | b <- set(distCartProd(NAMES_VALUES_RAN))}

-- Bindings definitions for ALA
BINDINGS_ALA = {set(b) | b <- set(distCartProd(NAMES_VALUES_ALA))}

BINDINGS = union(BINDINGS_RAN,BINDINGS_ALA)

--------------------------------
 -- mget, mset and terminate --
--------------------------------
channel mget, mset : NAME.UNIVERSE
channel terminate

--------------------------------
 -- MEMI --
--------------------------------
MEMI = {| mset,mget,terminate |}

channel snooze, radioOn

Chrono =
	let
		Memory(b_RAN) =
			( ( ( [] n : dom(b_RAN) @ mget.n.apply(b_RAN,n) -> Memory(b_RAN) )
		 [] ( [] n : dom(b_RAN) @ mset.n?nv:typeRAN(n) -> Memory(over(b_RAN,n,nv)) ))
		 [] terminate -> SKIP)
		MemoryMerge(b_RAN,s,ns1,ns2) =
			( ( ( [] n : dom(b_RAN) @ mget.n.apply(b_RAN,n) -> MemoryMerge(b_RAN,s,ns1,ns2) )
		 [] ( [] n : dom(b_RAN) @ mset.n?nv:typeRAN(n) -> MemoryMerge(over(b_RAN,n,nv),s,ns1,ns2) ))
		 [] terminate -> ( ( s == LEFT & ( ; n : ns2 @ mset.n.apply(b_RAN,n) -> SKIP ) ) [] ( s == RIGHT & ( ; n : ns1 @ mset.n.apply(b_RAN,n) -> SKIP ) )))
		within
		let  restrictRAN(bs) = dres(bs,{sv_Chrono_sec, sv_Chrono_min})
		within
			|~| b_RAN : BINDINGS_RAN @ ( ( ( ( (
      mget.sv_Chrono_min?v_sv_Chrono_min:(typeRAN(sv_Chrono_min)) ->
      mget.sv_Chrono_sec?v_sv_Chrono_sec:(typeRAN(sv_Chrono_sec)) ->
      ( ( ( ( ( ( ( mset.sv_Chrono_sec.(RAN.0) -> SKIP ;
      ( let X = ( mget.sv_Chrono_min?v_sv_Chrono_min:(typeRAN(sv_Chrono_min)) ->
                  mget.sv_Chrono_sec?v_sv_Chrono_sec:(typeRAN(sv_Chrono_sec)) ->
                  ( tick -> ( mset.sv_Chrono_sec.(RAN.(valueRAN(v_sv_Chrono_sec) + 1) % 3) -> SKIP ;
                  mget.sv_Chrono_sec?v_sv_Chrono_sec:(typeRAN(sv_Chrono_sec)) ->
                  (valueRAN(v_sv_Chrono_sec) == 0 & inc -> SKIP
                  [] valueRAN(v_sv_Chrono_sec) != 0 & SKIP) )
		              [] time -> minsReq -> ans?WakeUpOK_min -> out.(valueRAN(v_sv_Chrono_min),valueRAN(v_sv_Chrono_sec)) -> SKIP) ;
                   X ) within X ) ) ; terminate -> SKIP )
		                 [| MEMI |] MemoryMerge(restrictRAN(b_RAN),LEFT,<sv_Chrono_sec>,<sv_Chrono_min>)) )\MEMI )
		 [| Sync |]
  		( ( ( ( mset.sv_Chrono_min.(RAN.0) -> SKIP ;
        ( let X = ( mget.sv_Chrono_min?v_sv_Chrono_min:(typeRAN(sv_Chrono_min)) ->
          ( inc -> mset.sv_Chrono_min.(RAN.(valueRAN(v_sv_Chrono_min) + 1) % 3) -> SKIP
  		      [] minsReq -> ans.valueRAN(v_sv_Chrono_min) -> SKIP) ; X ) within X ) ) ; terminate -> SKIP )
  	         [| MEMI |] MemoryMerge(restrictRAN(b_RAN),RIGHT,<sv_Chrono_sec>,<sv_Chrono_min>)) )\MEMI ) )
		 ) \Sync ) ;
    terminate -> SKIP )
		 [| MEMI |] Memory(restrictRAN(b_RAN)) )\ MEMI )

Sync = {| inc,minsReq,ans |}
channel ans : RANGE
channel inc, minsReq


channel out : (RANGE,RANGE)
channel tick, time
