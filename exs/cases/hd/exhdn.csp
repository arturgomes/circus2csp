include "sequence_aux.csp"
include "function_aux.csp"


--------------------------------
-- The universe of values
 datatype UNIVERSE = NUM.\num
--Conversions
valueNUM(NUM.v) = v

typeNUM(x) = U_NUM

tagNUM(x) = NUM

-- subtypes of UNIVERSE for NUM
subtype U_NUM = NUM.\num

-- definition of NAME for the entire spec 
datatype NAME = sv_fillingBPRate

-- Subtype definition for NUM
b_NUM1 = {(sv_fillingBPRate, NUM.DO_IT_MANUALLY)}
subtype NAME_NUM = sv_fillingBPRate
NAMES_VALUES_NUM = seq({seq({(n,v) | v <- typeNUM(n)}) | n <- NAME_NUM})

-- Bindings definitions for NUM
BINDINGS_NUM = {set(b) | b <- set(distCartProd(NAMES_VALUES_NUM))}


--------------------------------
 -- mget, mset and terminate -- 
--------------------------------
channel mget, mset : NAME.UNIVERSE
channel terminate

--------------------------------
 -- MEMI -- 
--------------------------------
MEMI = {| mset,mget,terminate |}
channel lget, lset : NAME.UNIVERSE
channel lterminate
MEML = {| lset,lget,lterminate |}

HDMachine(b_NUM) = 
  let
     MemoryNUMVar(n,b_NUM) =
        ( ( mget.n.apply(b_NUM,n) ->
    MemoryNUMVar(n,b_NUM)
      [] mset.n?nv:typeNUM(n) ->
    MemoryNUMVar(n,over(b_NUM,n,nv)))
      [] terminate -> SKIP)
     MemoryNUM(b_NUM) =
        ( [| {| terminate |} |] n : dom(b_NUM) @ MemoryNUMVar(n,b_NUM) )
     Memory(b_NUM) =
        MemoryNUM(b_NUM)
     MemoryMergeNUMVar(n,b_NUM,ns) =
        ( ( lget.n.apply(b_NUM,n) ->
    MemoryMergeNUMVar(n,b_NUM,ns)
      [] lset.n?nv:typeNUM(n) ->
    MemoryMergeNUMVar(n,over(b_NUM,n,nv),ns))
      [] lterminate ->
    (  ; bd : <b_NUM> @   ; n : <y | y <- ns> @  mset.n.apply(bd,n) -> SKIP ))
     MemoryMergeNUM(b_NUM,ns) =
        ( [| {| lterminate |} |] n : dom(b_NUM) @ MemoryMergeNUMVar(n,b_NUM,ns) )
     MemoryMerge(b_NUM,ns) =
        MemoryMergeNUM(b_NUM,ns)
     
  within ( ( ( someEvent?t_sv_fillingBPRate ->
    mset.sv_fillingBPRate.(NUM.t_sv_fillingBPRate) -> SKIP;
      terminate -> SKIP )
      [| MEMI |] Memory(b_NUM))\MEMI )