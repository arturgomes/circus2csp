include "../isequence_aux.csp"
include "../function_aux.csp"

RANGE = {0..2}
--------------------------------
-- The universe of values
 datatype UNIVERSE = RAN.RANGE

--------------------------------
--Conversions
subtype U_RAN = RAN.RANGE

valueRAN(RAN.v) = v

typeRAN(x) = U_RAN

tagRAN(x) = RAN

--------------------------------
-- MEMORY
--------------------------------
Memory(b_RAN) = 
  ([] n:dom(b_RAN) @ mget.n!(apply(b_RAN,n)) -> Memory(b_RAN))
  [] ([] n:dom(b_RAN) @ mset.n?x:typeRAN(n) -> Memory(over(b_RAN,n,x)))
    [] terminate -> SKIP

Memorise(P,b_RAN) = 
    ((P; terminate -> SKIP) [| MEM_I |] Memory(b_RAN)) \ MEM_I

datatype NAME = sv_AChrono_sec_U_RAN | sv_AChrono_min_U_RAN | sv_Chrono_sec_U_RAN | sv_Chrono_min_U_RAN
subtype NAME_RAN = sv_AChrono_sec_U_RAN | sv_AChrono_min_U_RAN | sv_Chrono_sec_U_RAN | sv_Chrono_min_U_RAN
--------------------------------
-- All possible bidings

NAMES_VALUES_RAN = seq({seq({(n,v) | v <- typeRAN(n)}) | n <- NAME_RAN})

BINDINGS_RAN = {set(b) | b <- set(distCartProd(NAMES_VALUES_RAN))}

channel mget, mset : NAME.UNIVERSE
channel terminate
MEM_I = {| mset,mget,terminate |}

AChrono = 
  (let    restrictRAN(bs) = dres(bs,{sv_AChrono_sec_U_RAN, sv_AChrono_min_U_RAN})
  within
    |~| b_RAN : BINDINGS_RAN @ Memorise(( ( mget.sv_AChrono_sec_U_RAN?v_sv_AChrono_sec_U_RAN:(typeRAN(sv_AChrono_sec_U_RAN)) ->
    mset.sv_AChrono_sec_U_RAN.(RAN.0) ->
    ( let X = ( mget.sv_AChrono_sec_U_RAN?v_sv_AChrono_sec_U_RAN:(typeRAN(sv_AChrono_sec_U_RAN)) ->
    ( tick ->
    mset.sv_AChrono_sec_U_RAN.(RAN.(valueRAN(v_sv_AChrono_sec_U_RAN) + 1) % 3) ->
    mget.sv_AChrono_sec_U_RAN?v_sv_AChrono_sec_U_RAN:(typeRAN(sv_AChrono_sec_U_RAN)) ->
    ( ( valueRAN(v_sv_AChrono_sec_U_RAN) == 0 & inc ->
    SKIP ) [] ( valueRAN(v_sv_AChrono_sec_U_RAN) != 0 & SKIP )) [] time ->
    minsReq ->
    ans?mins ->
    out.(mins,valueRAN(v_sv_AChrono_sec_U_RAN)) ->
    SKIP) ; X ) within X ) [| Sync |] mget.sv_AChrono_min_U_RAN?v_sv_AChrono_min_U_RAN:(typeRAN(sv_AChrono_min_U_RAN)) ->
    mset.sv_AChrono_min_U_RAN.(RAN.0) ->
    ( let X = ( mget.sv_AChrono_min_U_RAN?v_sv_AChrono_min_U_RAN:(typeRAN(sv_AChrono_min_U_RAN)) ->
    ( inc ->
    mset.sv_AChrono_min_U_RAN.(RAN.((valueRAN(v_sv_AChrono_min_U_RAN) + 1) % 3)) ->
    SKIP [] minsReq ->
    ans.valueRAN(v_sv_AChrono_min_U_RAN) ->
    SKIP) ; X ) within X ) )\Sync ), restrictRAN(b_RAN))
)
Sync = {| inc,minsReq,ans |}
channel ans : RANGE
channel inc, minsReq

Chrono = 
  (let    restrictRAN(bs) = dres(bs,{sv_Chrono_sec_U_RAN, sv_Chrono_min_U_RAN})
  within
    |~| b_RAN : BINDINGS_RAN @ Memorise(mget.sv_Chrono_sec_U_RAN?v_sv_Chrono_sec_U_RAN:(typeRAN(sv_Chrono_sec_U_RAN)) ->
   mget.sv_Chrono_min_U_RAN?v_sv_Chrono_min_U_RAN:(typeRAN(sv_Chrono_min_U_RAN)) ->
   mset.sv_Chrono_sec_U_RAN.(RAN.0) ->
   mset.sv_Chrono_min_U_RAN.(RAN.0) ->
   ( let X = ( mget.sv_Chrono_min_U_RAN?v_sv_Chrono_min_U_RAN:(typeRAN(sv_Chrono_min_U_RAN)) ->
   mget.sv_Chrono_sec_U_RAN?v_sv_Chrono_sec_U_RAN:(typeRAN(sv_Chrono_sec_U_RAN)) ->
   ( tick ->
   mset.sv_Chrono_sec_U_RAN.(RAN.((valueRAN(v_sv_Chrono_sec_U_RAN) + 1) % 3)) ->
   mset.sv_Chrono_min_U_RAN.(RAN.valueRAN(v_sv_Chrono_min_U_RAN)) ->
   mget.sv_Chrono_min_U_RAN?v_sv_Chrono_min_U_RAN:(typeRAN(sv_Chrono_min_U_RAN)) ->
   mget.sv_Chrono_sec_U_RAN?v_sv_Chrono_sec_U_RAN:(typeRAN(sv_Chrono_sec_U_RAN)) ->
   ( ( valueRAN(v_sv_Chrono_sec_U_RAN) == 0 & mset.sv_Chrono_min_U_RAN.(RAN.((valueRAN(v_sv_Chrono_min_U_RAN) + 1) % 3)) ->
   mset.sv_Chrono_sec_U_RAN.(RAN.valueRAN(v_sv_Chrono_sec_U_RAN)) ->
   SKIP ) [] ( valueRAN(v_sv_Chrono_sec_U_RAN) != 0 & SKIP )) [] time ->
   out.(valueRAN(v_sv_Chrono_min_U_RAN),valueRAN(v_sv_Chrono_sec_U_RAN)) ->
   SKIP) ; X ) within X ), restrictRAN(b_RAN))
)
channel out : (RANGE,RANGE)
channel tick, time

assert AChrono [FD= Chrono
assert Chrono [FD= (AChrono \ Sync)


MyAChrono = (let X = AChrono; X within X) \ MEM_I
assert MyAChrono :[ deadlock free [FD] ]
assert AChrono \ MEM_I :[ livelock free ]
assert AChrono \ MEM_I :[ deterministic [FD] ]

MyChrono = let X = Chrono; X within X
assert MyChrono :[ deadlock free [FD] ]
assert Chrono :[ livelock free ]
assert Chrono :[ deterministic [FD] ]
