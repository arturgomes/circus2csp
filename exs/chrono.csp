include "sequence_aux.csp"
include "function_aux.csp"


RANGE = {0..2}
--------------------------------
-- The universe of values
 datatype UNIVERSE = RAN.RANGE

--------------------------------
--Conversions
subtype U_RAN = RAN.RANGE


valueRAN(RAN.v) = v


typeRAN(x) = U_RAN


tagRAN(x) = RAN

--------------------------------
 -- NAME --
--------------------------------
datatype NAME = sv_Chrono_sec_U_RAN | sv_Chrono_min_U_RAN | sv_AChrono_sec_U_RAN | sv_AChrono_min_U_RAN
subtype NAME_RAN = sv_Chrono_sec_U_RAN | sv_Chrono_min_U_RAN | sv_AChrono_sec_U_RAN | sv_AChrono_min_U_RAN

NAMES_VALUES_RAN = seq({seq({(n,v) | v <- typeRAN(n)}) | n <- NAME_RAN})

--------------------------------
 -- BINDINGS --
--------------------------------
BINDINGS_RAN = {set(b) | b <- set(distCartProd(NAMES_VALUES_RAN))}


--------------------------------
 -- mget, mset and terminate --
--------------------------------
channel mget, mset : NAME.UNIVERSE
channel terminate

--------------------------------
 -- MEM_I --
--------------------------------
MEM_I = {| mset,mget,terminate |}

Chrono =
	let

--------------------------------
-- MEMORY
--------------------------------
Memory(b_RAN) =
    ([] n:dom(b_RAN) @ mget.n!(apply(b_RAN,n)) -> Memory(b_RAN))
	[] ([] n:dom(b_RAN) @ mset.n?x:typeRAN(n) -> Memory(over(b_RAN,n,x)))
		[] terminate -> SKIP

Memorise(P,b_RAN) =
    ((P; terminate -> SKIP) [| MEM_I |]
    Memory(b_RAN)) \ MEM_I
within (let  restrictRAN(bs) = dres(bs,{sv_Chrono_sec_U_RAN, sv_Chrono_min_U_RAN, sv_AChrono_sec_U_RAN, sv_AChrono_min_U_RAN})
	within
		|~| b_RAN : BINDINGS_RAN @ Memorise(( (
		mget.sv_Chrono_sec_U_RAN?v_sv_Chrono_sec_U_RAN:(typeRAN(sv_Chrono_sec_U_RAN)) ->
		mset.sv_Chrono_sec_U_RAN.(RAN.0) -> ( let X = (
		mget.sv_Chrono_sec_U_RAN?v_sv_Chrono_sec_U_RAN:(typeRAN(sv_Chrono_sec_U_RAN)) -> ( tick ->
		mset.sv_Chrono_sec_U_RAN.(RAN.(valueRAN(v_sv_Chrono_sec_U_RAN) + 1) % 3) ->
		mget.sv_Chrono_sec_U_RAN?v_sv_Chrono_sec_U_RAN:(typeRAN(sv_Chrono_sec_U_RAN)) -> (valueRAN(v_sv_Chrono_sec_U_RAN) == 0 & inc -> SKIP [] valueRAN(v_sv_Chrono_sec_U_RAN) != 0 & SKIP)
		 [] time -> minsReq -> ans?mins -> out.(mins,valueRAN(v_sv_Chrono_sec_U_RAN)) -> SKIP) ; X ) within X )
		 [| Sync |]

		mget.sv_Chrono_min_U_RAN?v_sv_Chrono_min_U_RAN:(typeRAN(sv_Chrono_min_U_RAN)) ->
		mset.sv_Chrono_min_U_RAN.(RAN.0) -> ( let X = (
		mget.sv_Chrono_min_U_RAN?v_sv_Chrono_min_U_RAN:(typeRAN(sv_Chrono_min_U_RAN)) -> ( inc ->
		mset.sv_Chrono_min_U_RAN.(RAN.(valueRAN(v_sv_Chrono_min_U_RAN) + 1) % 3) -> SKIP
		 [] minsReq -> ans.valueRAN(v_sv_Chrono_min_U_RAN) -> SKIP) ; X ) within X ) )\Sync ), restrictRAN(b_RAN))
)
Sync = {| inc,minsReq,ans |}
channel ans : RANGE
channel inc, minsReq

AChrono =
	let
--------------------------------
-- MEMORY
--------------------------------
Memory(b_RAN) =
    ([] n:dom(b_RAN) @ mget.n!(apply(b_RAN,n)) -> Memory(b_RAN))
	[] ([] n:dom(b_RAN) @ mset.n?x:typeRAN(n) -> Memory(over(b_RAN,n,x)))
		[] terminate -> SKIP

Memorise(P,b_RAN) =
    ((P; terminate -> SKIP) [| MEM_I |]
    Memory(b_RAN)) \ MEM_I
within (let  restrictRAN(bs) = dres(bs,{sv_Chrono_sec_U_RAN, sv_Chrono_min_U_RAN, sv_AChrono_sec_U_RAN, sv_AChrono_min_U_RAN})
	within
		|~| b_RAN : BINDINGS_RAN @ Memorise(
		mget.sv_Chrono_sec_U_RAN?v_sv_Chrono_sec_U_RAN:(typeRAN(sv_Chrono_sec_U_RAN)) ->
		mget.sv_Chrono_min_U_RAN?v_sv_Chrono_min_U_RAN:(typeRAN(sv_Chrono_min_U_RAN)) ->
		mset.sv_Chrono_sec_U_RAN.(RAN.0) ->
		mset.sv_Chrono_min_U_RAN.(RAN.0) -> ( let X = (
		mget.sv_Chrono_min_U_RAN?v_sv_Chrono_min_U_RAN:(typeRAN(sv_Chrono_min_U_RAN)) ->
		mget.sv_Chrono_sec_U_RAN?v_sv_Chrono_sec_U_RAN:(typeRAN(sv_Chrono_sec_U_RAN)) -> ( tick ->
		mset.sv_Chrono_sec_U_RAN.(RAN.(valueRAN(v_sv_Chrono_sec_U_RAN) + 1) % 3) ->
		mset.sv_Chrono_min_U_RAN.(RAN.valueRAN(v_sv_Chrono_min_U_RAN)) ->
		mget.sv_Chrono_sec_U_RAN?v_sv_Chrono_sec_U_RAN:(typeRAN(sv_Chrono_sec_U_RAN)) -> (valueRAN(v_sv_Chrono_sec_U_RAN) == 0 &
		mset.sv_Chrono_min_U_RAN.(RAN.(valueRAN(v_sv_Chrono_min_U_RAN) + 1) % 3) ->
		mset.sv_Chrono_sec_U_RAN.(RAN.valueRAN(v_sv_Chrono_sec_U_RAN)) -> SKIP [] valueRAN(v_sv_Chrono_sec_U_RAN) != 0 & SKIP)
		 [] time -> out.(valueRAN(v_sv_Chrono_min_U_RAN),valueRAN(v_sv_Chrono_sec_U_RAN)) -> SKIP) ; X ) within X ), restrictRAN(b_RAN))
)
channel out : (RANGE,RANGE)
channel tick, time




assert AChrono :[deterministic [FD]]
assert Chrono :[deterministic [FD]]
assert AChrono [FD= Chrono
assert Chrono [FD= AChrono
