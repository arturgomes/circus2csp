include "sequence_aux.csp"
include "function_aux.csp"


maxbuff = 2
maxring = (maxbuff - 1)
Value = {0..2}
CellId = {1..maxring}
datatype Direction = req | ack

NatValue = {0..maxbuff}
channel input, output : Value
channel write, read, rdi, wrti : CellId.Direction.Value
channel rrd, wrt : Direction.Value
CtrI = {| rdi,wrti |}

IRCell(i) = RingCell[[rrd <- rdi.i, wrt <- wrti.i]]

DRing = |||i : CellId @ IRCell(i)

ControllerR = Controller[[read <- rdi, write <- wrti]]

DBuffer = ( ( ControllerR [| CtrI |] DRing ) \ CtrI )
------------------------
-- VERIFICATION
--------------------------------
ABuffer =
  let BufferState(s)= #s > 0 & output!head(s) -> BufferState(tail(s))
                      [] #s < maxbuff & input?x -> BufferState(s ^ <x>)
  within BufferState(<>)
assert ABuffer [FD= DBuffer
assert DBuffer [FD= ABuffer
--------------------------------
-- The universe of values
 datatype UNIVERSE = NAT.NatValue | CEL.CellId | VAL.Value
--Conversions
valueNAT(NAT.v) = v
valueCEL(CEL.v) = v
valueVAL(VAL.v) = v

typeNAT(x) = U_NAT
typeCEL(x) = U_CEL
typeVAL(x) = U_VAL

tagNAT(x) = NAT
tagCEL(x) = CEL
tagVAL(x) = VAL

-- subtypes of UNIVERSE for NAT
subtype U_NAT = NAT.NatValue

-- subtypes of UNIVERSE for CEL
subtype U_CEL = CEL.CellId

-- subtypes of UNIVERSE for VAL
subtype U_VAL = VAL.Value

-- definition of NAME for the entire spec 
datatype NAME = sv_cache | sv_size | sv_top | sv_bot | sv_v

-- Subtype definition for VAL
b_VAL1 = {(sv_cache, VAL.0),(sv_v, VAL.0)}
subtype NAME_VAL = sv_cache | sv_v
NAMES_VALUES_VAL = seq({seq({(n,v) | v <- typeVAL(n)}) | n <- NAME_VAL})

-- Subtype definition for NAT
b_NAT1 = {(sv_size, NAT.0)}
subtype NAME_NAT = sv_size
NAMES_VALUES_NAT = seq({seq({(n,v) | v <- typeNAT(n)}) | n <- NAME_NAT})

-- Subtype definition for CEL
b_CEL1 = {(sv_top, CEL.1),(sv_bot, CEL.1)}
subtype NAME_CEL = sv_top | sv_bot
NAMES_VALUES_CEL = seq({seq({(n,v) | v <- typeCEL(n)}) | n <- NAME_CEL})

-- Bindings definitions for VAL
BINDINGS_VAL = {set(b) | b <- set(distCartProd(NAMES_VALUES_VAL))}

-- Bindings definitions for NAT
BINDINGS_NAT = {set(b) | b <- set(distCartProd(NAMES_VALUES_NAT))}

-- Bindings definitions for CEL
BINDINGS_CEL = {set(b) | b <- set(distCartProd(NAMES_VALUES_CEL))}


--------------------------------
 -- mget, mset and terminate -- 
--------------------------------
channel mget, mset : NAME.UNIVERSE
channel terminate

--------------------------------
 -- MEMI -- 
--------------------------------
MEMI = {| mset,mget,terminate |}
channel lget, lset : NAME.UNIVERSE
channel lterminate
MEML = {| lset,lget,lterminate |}

Controller(b_VAL,b_NAT,b_CEL) = 
  let
     MemoryVALVar(n,b_VAL) =
        ( ( mget.n.apply(b_VAL,n) ->
    MemoryVALVar(n,b_VAL)
      [] mset.n?nv:typeVAL(n) ->
    MemoryVALVar(n,over(b_VAL,n,nv)))
      [] terminate -> SKIP)
     MemoryNATVar(n,b_NAT) =
        ( ( mget.n.apply(b_NAT,n) ->
    MemoryNATVar(n,b_NAT)
      [] mset.n?nv:typeNAT(n) ->
    MemoryNATVar(n,over(b_NAT,n,nv)))
      [] terminate -> SKIP)
     MemoryCELVar(n,b_CEL) =
        ( ( mget.n.apply(b_CEL,n) ->
    MemoryCELVar(n,b_CEL)
      [] mset.n?nv:typeCEL(n) ->
    MemoryCELVar(n,over(b_CEL,n,nv)))
      [] terminate -> SKIP)
     MemoryVAL(b_VAL) =
        ( [| {| terminate |} |] n : dom(b_VAL) @ MemoryVALVar(n,b_VAL) )
     MemoryNAT(b_NAT) =
        ( [| {| terminate |} |] n : dom(b_NAT) @ MemoryNATVar(n,b_NAT) )
     MemoryCEL(b_CEL) =
        ( [| {| terminate |} |] n : dom(b_CEL) @ MemoryCELVar(n,b_CEL) )
     Memory(b_VAL,b_NAT,b_CEL) =
        ( ( MemoryCEL(b_CEL)
      [| {| terminate |} |] 
      MemoryNAT(b_NAT) )
      [| {| terminate |} |] 
      MemoryVAL(b_VAL) )
     MemoryMergeVALVar(n,b_VAL,ns) =
        ( ( lget.n.apply(b_VAL,n) ->
    MemoryMergeVALVar(n,b_VAL,ns)
      [] lset.n?nv:typeVAL(n) ->
    MemoryMergeVALVar(n,over(b_VAL,n,nv),ns))
      [] lterminate ->
    (  ; bd : <b_VAL> @   ; n : <y | y <- ns> @  mset.n.apply(bd,n) -> SKIP ))
     MemoryMergeNATVar(n,b_NAT,ns) =
        ( ( lget.n.apply(b_NAT,n) ->
    MemoryMergeNATVar(n,b_NAT,ns)
      [] lset.n?nv:typeNAT(n) ->
    MemoryMergeNATVar(n,over(b_NAT,n,nv),ns))
      [] lterminate ->
    (  ; bd : <b_NAT> @   ; n : <y | y <- ns> @  mset.n.apply(bd,n) -> SKIP ))
     MemoryMergeCELVar(n,b_CEL,ns) =
        ( ( lget.n.apply(b_CEL,n) ->
    MemoryMergeCELVar(n,b_CEL,ns)
      [] lset.n?nv:typeCEL(n) ->
    MemoryMergeCELVar(n,over(b_CEL,n,nv),ns))
      [] lterminate ->
    (  ; bd : <b_CEL> @   ; n : <y | y <- ns> @  mset.n.apply(bd,n) -> SKIP ))
     MemoryMergeVAL(b_VAL,ns) =
        ( [| {| lterminate |} |] n : dom(b_VAL) @ MemoryMergeVALVar(n,b_VAL,ns) )
     MemoryMergeNAT(b_NAT,ns) =
        ( [| {| lterminate |} |] n : dom(b_NAT) @ MemoryMergeNATVar(n,b_NAT,ns) )
     MemoryMergeCEL(b_CEL,ns) =
        ( [| {| lterminate |} |] n : dom(b_CEL) @ MemoryMergeCELVar(n,b_CEL,ns) )
     MemoryMerge(b_VAL,b_NAT,b_CEL,ns) =
        ( ( MemoryMergeCEL(b_CEL,ns)
      [| {| lterminate |} |] 
      MemoryMergeNAT(b_NAT,ns) )
      [| {| lterminate |} |] 
      MemoryMergeVAL(b_VAL,ns) )
     
  within ( ( ( mset.sv_cache.(VAL.0) ->
    mset.sv_size.(NAT.0) ->
    mset.sv_top.(CEL.1) ->
    mset.sv_bot.(CEL.1) ->
    ( let X = mget.sv_bot?v_sv_bot:(typeCEL(sv_bot)) ->
    mget.sv_cache?v_sv_cache:(typeVAL(sv_cache)) ->
    mget.sv_size?v_sv_size:(typeNAT(sv_size)) ->
    mget.sv_top?v_sv_top:(typeCEL(sv_top)) ->
    ( ( (valueNAT(v_sv_size) < maxbuff) & input?x ->
    ( ( (valueNAT(v_sv_size) == 0) & mset.sv_cache.(VAL.x) ->
    mset.sv_size.(NAT.1) ->
    X )
      [] ( (valueNAT(v_sv_size) > 0) & write.valueCEL(v_sv_top).req.x ->
    write.valueCEL(v_sv_top).ack?dumb ->
    mset.sv_size.(NAT.(valueNAT(v_sv_size) + 1)) ->
    mget.sv_top?v_sv_top:(typeCEL(sv_top)) ->
    mset.sv_top.(CEL.(valueCEL(v_sv_top) % maxring + 1)) ->
    X )) )
      [] ( (valueNAT(v_sv_size) > 0) & output.valueVAL(v_sv_cache) ->
    ( ( (valueNAT(v_sv_size) > 1) & ( ( ( |~| dumb : Value @
         read.valueCEL(v_sv_bot).req.dumb ->
    read.valueCEL(v_sv_bot).ack?x ->
    mset.sv_cache.(VAL.x) -> SKIP );
      mget.sv_size?v_sv_size:(typeNAT(sv_size)) ->
    ( (valueNAT(v_sv_size) > 1) & mget.sv_size?v_sv_size:(typeNAT(sv_size)) ->
    mset.sv_size.(NAT.(valueNAT(v_sv_size) - 1)) ->
    mget.sv_bot?v_sv_bot:(typeCEL(sv_bot)) ->
    mset.sv_bot.(CEL.(valueCEL(v_sv_bot) % maxring + 1)) -> SKIP ) );
      X ) )
      [] ( (valueNAT(v_sv_size) == 1) & mset.sv_size.(NAT.0) ->
    X )) )) within X );
      terminate -> SKIP )
      [| MEMI |] Memory(b_VAL,b_NAT,b_CEL))\MEMI )

RingCell(b_VAL) = 
  let
     MemoryVALVar(n,b_VAL) =
        ( ( mget.n.apply(b_VAL,n) ->
    MemoryVALVar(n,b_VAL)
      [] mset.n?nv:typeVAL(n) ->
    MemoryVALVar(n,over(b_VAL,n,nv)))
      [] terminate -> SKIP)
     MemoryVAL(b_VAL) =
        ( [| {| terminate |} |] n : dom(b_VAL) @ MemoryVALVar(n,b_VAL) )
     Memory(b_VAL) =
        MemoryVAL(b_VAL)
     MemoryMergeVALVar(n,b_VAL,ns) =
        ( ( lget.n.apply(b_VAL,n) ->
    MemoryMergeVALVar(n,b_VAL,ns)
      [] lset.n?nv:typeVAL(n) ->
    MemoryMergeVALVar(n,over(b_VAL,n,nv),ns))
      [] lterminate ->
    (  ; bd : <b_VAL> @   ; n : <y | y <- ns> @  mset.n.apply(bd,n) -> SKIP ))
     MemoryMergeVAL(b_VAL,ns) =
        ( [| {| lterminate |} |] n : dom(b_VAL) @ MemoryMergeVALVar(n,b_VAL,ns) )
     MemoryMerge(b_VAL,ns) =
        MemoryMergeVAL(b_VAL,ns)
     
  within ( ( ( ( ( |~| x : Value @
         mset.sv_v.(VAL.x) -> SKIP );
      ( let X = mget.sv_v?v_sv_v:(typeVAL(sv_v)) ->
    ( ( wrt.req?x ->
    mset.sv_v.(VAL.x) ->
    wrt.ack.x -> SKIP
      [] rrd.req?dumb ->
    rrd.ack.valueVAL(v_sv_v) -> SKIP);
      X ) within X ) );
      terminate -> SKIP )
      [| MEMI |] Memory(b_VAL))\MEMI )