include "sequence_aux.csp"
include "function_aux.csp"

--------------------------------
-- GENERAL DEFINITIONS
--------------------------------

-- The maximum size of the buffer is a strictly positive constant.
maxbuff = 2

-- The values buffered are numbers.
Value = {0..maxbuff}

-- The ring is a circular array, modelled as a sequence whose two
-- ends are considered to be joined.
-- The constant maxring, defined as (maxbuff - 1), gives the bound for
-- the ring.
maxring = maxbuff - 1

-- The communication is bi-directional
datatype Direction = req | ack

CellId = {1 .. maxring}
channel input, output: Value
channel rrd, wrt: Direction . Value
-- An indexed cell
channel rdi, wrti: CellId.Direction.Value
channel write, read: CellId.Direction.Value
--------------------------------
-- MEMORY
--------------------------------
channel mget, mset : NAME.UNIVERSE
channel terminate

--------------------------------
-- THE ABSTRACT BUFFER
--------------------------------

-- It takes its inputs and supplies its outputs on two different
-- typed channels.

ABuffer =
  let BufferState(s)= #s > 0 & output!head(s) -> BufferState(tail(s))
                      []
                      #s < maxbuff & input?x -> BufferState(s ^ <x>)

  within
    BufferState(<>)


--------------------------------
-- BINDINGS
--------------------------------

--------------------------------
-- Set of names
datatype NAME = sv_v | sv_top | sv_bot | sv_cache | sv_size

--------------------------------
-- Nat
NatValue = {0..maxbuff}

--------------------------------
-- The universe of values
datatype UNIVERSE =
    NAT.NatValue | VAL.Value | CEL.CellId

--------------------------------
-- Conversions
subtype U_NAT = NAT.NatValue
subtype U_VAL = VAL.Value
subtype U_CEL = CEL.CellId

value(NAT.v) = v
value(VAL.v) = v
value(CEL.v) = v

type(x) =
    if x== sv_v then U_VAL
    else if x == sv_top then U_CEL
    else if x == sv_bot then U_CEL
    else if x == sv_cache then U_VAL
    else if x == sv_size then U_NAT
    else {}

tag(x) =
    if x== sv_v then VAL
    else if x == sv_top then CEL
    else if x == sv_bot then CEL
    else if x == sv_cache then VAL
    else if x == sv_size then NAT
    else NAT

--------------------------------
-- All possible bidings
NAMES_VALUES = seq({seq({(n,v) | v <- type(n)}) | n <- NAME})
BINDINGS = {set(b) | b <- set(distCartProd(NAMES_VALUES))}



MEM_I = {| mset, mget, terminate |}

Memory(b) =
    ([] n:dom(b) @ mget.n!(apply(b,n)) -> Memory(b))
    [] ([] n:dom(b) @ mset.n?x:type(n) -> Memory(over(b,n,x)))
    [] terminate -> SKIP

Memorise(P, b) =
    ((P; terminate -> SKIP) [| MEM_I |] Memory(b)) \ MEM_I

--------------------------------
-- STATELESS RING
--------------------------------

RingCellMain =
    (|~| v:Value @
        mget.sv_v?v_sv_v:(type(sv_v)) ->
        mset.sv_v!((tag(sv_v)).v) ->
        SKIP);
    (let
        MuCellX =
            (mget.sv_v?v_sv_v:(type(sv_v)) ->
                (
                rrd.req?dumb ->
                    rrd.ack!(value(v_sv_v)) ->
                    SKIP
                []
                wrt.req?x ->
                    mset.sv_v!((tag(sv_v)).x) ->
                    wrt.ack?dumb ->
                    SKIP
            ));
            MuCellX
    within
        MuCellX)

MemoryRingCell =
    let restrict(bs) = dres(bs,{sv_v})
    within
        |~| b:BINDINGS @ Memorise(RingCellMain, restrict(b))



MemoryIRCell(i) = MemoryRingCell [[rrd <- rdi.i, wrt <- wrti.i]]

-- The distributed ring
MemoryDRing = ||| i: CellId @ MemoryIRCell(i)

--------------------------------
-- STATELESS CONTROLLER
--------------------------------

ControllerMain =
(mget.sv_cache?v_sv_cache:(type(sv_cache)) ->
 mget.sv_size?v_sv_size:(type(sv_size)) ->
 mget.sv_top?v_sv_top:(type(sv_top)) ->
 mget.sv_bot?v_sv_bot:(type(sv_bot)) ->
 mset.sv_cache.((tag(sv_cache)).0) ->
 mset.sv_size.((tag(sv_size)).0) ->
 mset.sv_top.((tag(sv_top)).1) ->
 mset.sv_bot.((tag(sv_bot)).1) ->
 SKIP);
let
    MuControllerX =
        (
        mget.sv_cache?v_sv_cache:(type(sv_cache)) ->
        mget.sv_size?v_sv_size:(type(sv_size)) ->
        mget.sv_top?v_sv_top:(type(sv_top)) ->
        mget.sv_bot?v_sv_bot:(type(sv_bot)) ->
            (
               (value(v_sv_size) < maxbuff) &
                    input?x ->
        ---- THE READING BELOW BREAKS IT BECAUSE WE CAN NO LONGER GUARANTEEE THAT
        ---- value(v_sv_size) < maxbuff. Hence, incrementing it may take its value
        ---- outside the range of the channel.
        --            mget.sv_size?v_sv_size:(type(sv_size)) ->
            (
                (value(v_sv_size) == 0) &
                    mset.sv_cache.((tag(sv_cache)).x) ->
                    mset.sv_size.((tag(sv_size)).1) ->
                    SKIP
                []
                (value(v_sv_size) > 0) &
                    write.(value(v_sv_top)).req!x ->
                    write.(value(v_sv_top)).ack?dumb ->
                    mset.sv_size.((tag(sv_size)).((value(v_sv_size))+1)) ->
                    mset.sv_top.((tag(sv_top)).(((value(v_sv_top)) % maxring)+1)) ->
                    SKIP
            )
       []
       (value(v_sv_size) > 0) &
            output!(value(v_sv_cache)) ->
            (
                (value(v_sv_size) > 1) &
                    (|~| dumb:Value @
                        read.(value(v_sv_bot)).req.dumb ->
                        read.(value(v_sv_bot)).ack?x ->
                        mset.sv_cache.((tag(sv_cache)).x) -> SKIP);
                        (mset.sv_size.((tag(sv_size)).((value(v_sv_size)) - 1)) ->
                         mset.sv_bot.((tag(sv_bot)).(((value(v_sv_bot)) % maxring)+1)) ->
                                         SKIP)
                []
                (value(v_sv_size) == 1) &
                    mset.sv_size.((tag(sv_size)).0) ->
                                                SKIP
            )
            )
        );
        MuControllerX
within
    MuControllerX

MemoryController =
    let restrict(bs) = dres(bs,{sv_cache, sv_size, sv_top, sv_bot})
    within
        |~| b:BINDINGS @ Memorise(ControllerMain, restrict(b))

--------------------------------
-- THE RING BUFFER
--------------------------------
MemoryControllerR = MemoryController[[ read <- rdi, write <- wrti]]
MemoryDBuffer = (MemoryControllerR [| {| rdi, wrti |} |] MemoryDRing) \ {| rdi, wrti |}

--------------------------------
-- VERIFICATION
--------------------------------
assert (|~| b: BINDINGS @ Memory(b)) :[deadlock free]
assert RingCellMain :[deadlock free]
assert ABuffer [FD= MemoryDBuffer
assert MemoryDBuffer [FD= ABuffer
