
\chapter{A \Circus~ Model of the ARINC 653 Components}
\label{circus-model}
\section{Types}
\label{ap-types}
%<*\iseq1>
  % \begin{zed}
  %   \iseq_1[X] == \{~ s: \seq X | s \neq \langle \rangle \land s \in \nat \inj X~\}
  % \end{zed}
%</\iseq1>
\begin{zed}
  [NAT]
\end{zed}
\subsection{Basic types definition}
%It is used within the configuration tables construction and within the \Circus~processes.
%begin{enumerate}
  %item Definition for numbers
    %<*type1>
    \begin{zed}
    DecOrHexValueType == NAT\\
    IdentifierValueType == DecOrHexValueType
    \end{zed}
    %</type1>
  %item Definition for Strings
    %<*type2>
    \begin{zed}
    [~ String~]\\
    NameType == String
    \end{zed}
    %</type2>
  %item Definition of Boolean
    \begin{zed}
    Boolean ::= TRUE | FALSE
    \end{zed}
  %item Definition of Time
    %<*systemtimetype>
    \begin{zed}
      SYSTEM\_TIME\_TYPE == DecOrHexValueType
    \end{zed}
    %</systemtimetype>
  %item Definition of Partitions and Process Identifiers
    \begin{zed}
      PARTITION\_ID\_TYPE == DecOrHexValueType\\
      PROCESS\_ID\_TYPE == DecOrHexValueType
    \end{zed}
  %item Definition of messages provided in the end of the execution of an APEX service
    %<*returncodetype>
    \begin{zed}
      RETURN\_CODE\_TYPE ::= NO\_ERROR | NO\_ACTION | NOT\_AVAILABLE\\
          \t4  | INVALID\_PARAM | INVALID\_CONFIG \\
          \t4  | INVALID\_MODE | TIMED\_OUT
    \end{zed}
    %</returncodetype>
  %item Definition of ARINC constants, including operating modes and recovery actions.
    %<*arincconstants>
    \begin{zed}
      ARINC\_CONSTANTS ::= COLD\_START | WARM\_START | COLD\_RESTART \\
          \t4  | WARM\_RESTART | IDLE | NORMAL \\
          \t4  | ERROR\_MODE | IGNORE | SHUTDOWN \\
          \t4  | RESET | ARINC\_CONSTANTS\_NULL
    \end{zed}
    %</arincconstants>
  %item Definition of Operating modes, subsets of $ARINC\_CONSTANTS$.
    %<*opmode>
    \begin{zed}
      OPERATING\_MODE\_TYPE == \\
      \t2  ARINC\_CONSTANTS ~\setminus \{COLD\_RESTART, WARM\_RESTART, \\
          \t4  ERROR\_MODE, IGNORE, SHUTDOWN, \\
          \t4  RESET, ARINC\_CONSTANTS\_NULL\}\\
      OPERATING\_INIT\_MODE\_TYPE == \\
      \t2  ARINC\_CONSTANTS ~\setminus \{IDLE, NORMAL, \\
          \t4  COLD\_RESTART, WARM\_RESTART, \\
          \t4  ERROR\_MODE, IGNORE, SHUTDOWN, \\
          \t4  RESET, ARINC\_CONSTANTS\_NULL\}
    \end{zed}
    %</opmode>
  %item Start Condition
    %<*startcondition>
    \begin{zed}
      START\_CONDITION\_TYPE ::= NORMAL\_START | PARTITION\_RESTART \\
        \t4  | HM\_NORMAL\_START | HM\_PARTITION\_RESTART
    \end{zed}
    %</startcondition>
  %item Lock Level
    %<*locklevel>
    \begin{zed}
      LOCK\_LEVEL\_TYPE == DecOrHexValueType
    \end{zed}
    %</locklevel>

  %item Errors and levels of error definition
    %<*modulelevels>
    \begin{zed}
      ErrorCodeType ::= DEADLINE\_MISSED | APPLICATION\_ERROR\\
        \t4  | NUMERIC\_ERROR | ILLEGAL\_REQUEST \\
        \t4  | STACK\_OVERFLOW | MEMORY\_VIOLATION\\
        \t4  | HARDWARE\_FAULT | POWER\_FAIL\\
      MODULE\_LEVELS ::= PARTITION | PROCESS\\
        \t4  | MODULE | MODULE\_LEVELS\_NULL\\
      PartitionHMTableErrorLevelType == \\   
        \t2  MODULE\_LEVELS ~\setminus \{MODULE\}\\
      MultiPartitionHMTableErrorLevelType == \\
        \t2  MODULE\_LEVELS ~\setminus \{PARTITION\}
    \end{zed}
    %</modulelevels>

  %item Recovery Actions definition for Module and Partition levels
    %<*ModuleLevelErrorRecoveryActionType>
    \begin{zed}
    ModuleLevelErrorRecoveryActionType == \\ 
      \t2  ARINC\_CONSTANTS ~\setminus \{COLD\_RESTART, WARM\_RESTART, \\
        \t4  COLD\_START, WARM\_START, \\
        \t4  IDLE, NORMAL, ERROR\_MODE,  \\
        \t4  ARINC\_CONSTANTS\_NULL\}
    \also\ PartitionLevelErrorRecoveryActionType == \\
      \t2  ARINC\_CONSTANTS ~\setminus \{COLD\_START, WARM\_START, NORMAL, \\
        \t4  ERROR\_MODE, SHUTDOWN, \\
        \t4  RESET, ARINC\_CONSTANTS\_NULL\}
    \end{zed}
    %</ModuleLevelErrorRecoveryActionType>
  %item Port message types definition
    %any message sent from or to a partition has the type $MESSAGE\_ADDR\_TYPE$, which is the starting address of
    % a contiguous area of data. 
    %<*messagetypes>
    \begin{zed}
      [~ MESSAGE\_ADDR\_TYPE ~]\\
      SAMPLING\_PORT\_NAME\_TYPE == NameType\\
      MESSAGE\_SIZE\_TYPE == DecOrHexValueType\\
      SAMPLING\_PORT\_ID\_TYPE == DecOrHexValueType\\
      VALIDITY\_TYPE ::= INVALID | VALID\\
      QUEUING\_PORT\_ID\_TYPE == DecOrHexValueType\\
      [QUEUING\_PORT\_NAME\_TYPE]\\
      QUEUING\_DISCIPLINE\_TYPE ::= FIFO | PRIORITY\\
      MESSAGE\_RANGE\_TYPE == DecOrHexValueType\\
      WAITING\_RANGE\_TYPE == DecOrHexValueType\\
      PortDirectionType ::= SOURCE | DESTINATION
    \end{zed}
    %</messagetypes>
\end{enumerate}

\subsection{Configuration Tables Data Structure}
%begin{enumerate}
%item Partitions
  %begin{enumerate}
  %item Partition Status Type Definition
    %<*PartitionBaseType>
    \begin{schema}{A653\_PartitionBaseType}
      Identifier : PARTITION\_ID\_TYPE\\
      Name: NameType
    \end{schema}
    %</PartitionBaseType>

  %item Partition Memory Region Type Definition
    %<*MemoryRegionType>
    \begin{schema}{A653\_MemoryRegionType}
      Name, Type, AccessRights: NameType\\
      Size : DecOrHexValueType
    \end{schema}
    %</MemoryRegionType>
    %
    %<*MemoryRegion>  
    %\begin{zed} MemoryRegion == \iseq_1[A653\_MemoryRegionType] \end{zed}
    \begin{zed} MemoryRegion == \iseq A653\_MemoryRegionType \end{zed}
    %</MemoryRegion>
  %item Partition Periodicity Type Definition
    %<*PartitionPeriodicityType>
    \begin{schema}{A653\_PartitionPeriodicityType}
      Period:SYSTEM\_TIME\_TYPE\\
      Duration:SYSTEM\_TIME\_TYPE
    \end{schema}
    %</PartitionPeriodicityType>

  %item Partition Ports Types Definition
    %begin{enumerate}
      %item Port Base (used in both port types)
        %<*PortBaseType>
        \begin{schema}{PortBaseType}
          Name: NameType\\
          MaxMessageSize : DecOrHexValueType\\
          Direction: PortDirectionType
        \end{schema}
        %</PortBaseType>
      %item Sampling Port
        %<*SamplingPortType>
        \begin{schema}{A653\_SamplingPortType}
          PortBaseType
        \end{schema}
        %</SamplingPortType>
      %item Queuing Port
        %<*QueueingPortType>
        \begin{schema}{A653\_QueueingPortType}
          PortBaseType\\
          MaxNbMessage: DecOrHexValueType
        \end{schema}
        %</QueueingPortType>
      %item Partition Ports Definition
        %<*PartitionPort>
        \begin{zed} PartitionPort ::= SamplingPort \ldata A653\_SamplingPortType\rdata\\
        \t4  | QueueingPort \ldata A653\_QueueingPortType\rdata\end{zed}
        %</PartitionPort>
        %<*PartitionPorts>
        %\begin{zed} PartitionPorts == \iseq_1[PartitionPort] \end{zed}
        \begin{zed} PartitionPorts == \iseq PartitionPort \end{zed}
        %</PartitionPorts>
    \end{enumerate}
  %item Partition definition
    %<*Partition>
    \begin{schema}{Partition}
      PartitionDefinition : A653\_PartitionBaseType\\
      PartitionPeriodicity : A653\_PartitionPeriodicityType\\
      MemoryRegions : \iseq A653\_MemoryRegionType\\
      % MemoryRegions : \iseq_1[A653\_MemoryRegionType]\\
      PartitionPorts : \iseq PartitionPort 
      % PartitionPorts : \iseq_1[PartitionPort] 
    \end{schema}
    %</Partition>
  %item Sequence of Partitions definition
    %<*PartitionsType>
      \begin{zed} 
        % PartitionsType == \iseq_1[Partition]
        PartitionsType == \iseq Partition
      \end{zed}
    %</PartitionsType>
  \end{enumerate}

%item Partition Schedule
  %<*PartitionTimeWindowType>
  \begin{schema}{A653\_PartitionTimeWindowType}
    PartitionNameRef:NameType;\\
    Duration, Offset : DecOrHexValueType;\\
    PeriodicProcessingStart : Boolean
  \end{schema}
  %</PartitionTimeWindowType>

  %<*ScheduleType>
  \begin{zed}ScheduleType == \iseq A653\_PartitionTimeWindowType\end{zed}
  % \begin{zed}ScheduleType == \iseq_1[A653\_PartitionTimeWindowType]\end{zed}
  %</ScheduleType>
%item Health Monitor
  %begin{enumerate}
  %item Error Identifier Types
    %<*ErrorIdentifierType>
    \begin{schema}{A653\_ErrorIdentifierType}
      ErrorIdentifier : IdentifierValueType\\
      Description: NameType
    \end{schema}
    %</ErrorIdentifierType>
  %item Partition Health Monitor Definition
    %<*PErrorActionType>
    \begin{schema}{PErrorActionType}
      ErrorIdentifierRef: IdentifierValueType\\
      ErrorLevel : PartitionHMTableErrorLevelType\\
      PartitionRecoveryAction : ModuleLevelErrorRecoveryActionType\\
      ErrorCode : ErrorCodeType
    \end{schema}
    %</PErrorActionType>
    %<*PartitionHMTableType>
    \begin{schema}{A653\_PartitionHMTableType}
      %TableIdentifier : IdentifierValueType\\
      TableName : NameType\\
      MultiPartitionHMTableNameRef : NameType\\
      ErrorAction : \seq_1 PErrorActionType
    \end{schema}
    %</PartitionHMTableType>
  %item Multi-Partition Health Monitor Definition
    %<*MPErrorActionType>
    \begin{schema}{MPErrorActionType}
      ErrorIdentifierRef: IdentifierValueType\\
      ErrorLevel : PartitionHMTableErrorLevelType\\
      %ModuleRecoveryAction : ModuleLevelErrorRecoveryActionType\\
    \end{schema}
    %</MPErrorActionType>
    %<*MultiPartitionHMTableType>
    \begin{schema}{A653\_MultiPartitionHMTableType}
      %TableIdentifier: IdentifierValueType\\
      TableName : NameType\\
      ErrorAction : \seq_1 MPErrorActionType
    \end{schema}
    %</MultiPartitionHMTableType>
  %item Module Health monitor definition
    %<*MErrorActionType>
    \begin{schema}{MErrorActionType}
      ErrorIdentifierRef: IdentifierValueType\\
      ModuleRecoveryAction : ModuleLevelErrorRecoveryActionType
    \end{schema}
    %</MErrorActionType>
    %<*ModuleHMTableType>
    \begin{schema}{A653\_ModuleHMTableType}
      StateIdentifier : IdentifierValueType\\
      Description: NameType\\
      ErrorAction: \seq_1 MErrorActionType
    \end{schema}
    %</ModuleHMTableType>
  %item Health monitor Definition
    %<*HealthMonitoringType>
    \begin{schema}{HealthMonitoringType}
      SystemErrors : \iseq A653\_ErrorIdentifierType\\
      ModuleHM : \iseq A653\_ModuleHMTableType\\
      MultiPartitionHM : \iseq ~A653\_MultiPartitionHMTableType\\
      PartitionHM : \iseq A653\_PartitionHMTableType 
    \end{schema}
    % \begin{schema}{HealthMonitoringType}
    %   SystemErrors : \iseq_1[A653\_ErrorIdentifierType]\\
    %   ModuleHM : \iseq_1[~A653\_ModuleHMTableType~]\\
    %   MultiPartitionHM : \iseq_1[~A653\_MultiPartitionHMTableType~]\\
    %   PartitionHM : \iseq_1[~A653\_PartitionHMTableType~] 
    % \end{schema}
    %</HealthMonitoringType>
  \end{enumerate}
%item Module Definition
  %<*Module>
  \begin{schema}{Module}
    Name : NameType\\
    Partitions : PartitionsType\\
    Schedules : ScheduleType\\
    HealthMonitoring : HealthMonitoringType
  \end{schema}
  %</Module>
%item Partition Status Type Definition
  %<*PartitionVariableAttributes>
  \begin{schema}{PartitionVariables}
    OPERATING\_MODE : OPERATING\_MODE\_TYPE\\
    START\_CONDITION : START\_CONDITION\_TYPE\\
    LOCK\_LEVEL : LOCK\_LEVEL\_TYPE
  \end{schema}
  %</PartitionVariableAttributes>
  %<*partitionstatus>
  \begin{schema}{PARTITION\_STATUS\_TYPE}
    Identifier:PARTITION\_ID\_TYPE\\
    Period:SYSTEM\_TIME\_TYPE\\
    Duration:SYSTEM\_TIME\_TYPE\\
    PartitionVariables
  \end{schema}
  %</partitionstatus>
\end{enumerate}

\section{\Circus~Channels}
\label{ap-channels}
%Channels of the communication between the $Apex$ process and the $OperatingSystem$ process.%

%begin{enumerate}
%item Channels for communication between the Operating System, APEX and the Partitions indicating the life stage of the ARINC Module.
%<*apexchannelsmode>
\begin{circus}
\circchannel\ moduleInit, moduleEndInit, moduleEnd
%\circchannel\ moduleHMDecision, moduleHMRestart, moduleIdle
\end{circus}
%</apexchannelsmode>

%item Channels used by the Operating System \Circus~process to control the partitions execution.
%<*Modulechannels>
\begin{circus}
\circchannel initPartition, endPartition, reinitPartition : PARTITION\_ID\_TYPE\\
\circchannel execPartition, interruptPartition : PARTITION\_ID\_TYPE\\
\circchannel return\_code: PARTITION\_ID\_TYPE \cross RETURN\_CODE\_TYPE
\end{circus}%
%</Modulechannels>
%item Channels for communication between the APEX and the Operating System
%<*APEXchannels>
\begin{circus}
\circchannel apex\_req\_sampling\_port\_id: PARTITION\_ID\_TYPE \\
       \t4  \cross SAMPLING\_PORT\_NAME\_TYPE\\
\circchannel apex\_get\_sampling\_port\_id: PARTITION\_ID\_TYPE \\
       \t4  \cross SAMPLING\_PORT\_ID\_TYPE\\
\circchannel apex\_req\_new\_partition\_mode : PARTITION\_ID\_TYPE \\
       \t4  \cross OPERATING\_MODE\_TYPE\\ 
\circchannel apex\_req\_partition\_status: PARTITION\_ID\_TYPE\\
\circchannel apex\_get\_partition\_status: PARTITION\_ID\_TYPE \\
       \t4  \cross PARTITION\_STATUS\_TYPE\\
\circchannel apex\_req\_system\_time: PARTITION\_ID\_TYPE\\
\circchannel apex\_get\_system\_time: PARTITION\_ID\_TYPE \\
       \t4  \cross SYSTEM\_TIME\_TYPE\\
\circchannel apex\_req\_partition\_mode: PARTITION\_ID\_TYPE\\
\circchannel apex\_get\_partition\_mode: PARTITION\_ID\_TYPE \\
       \t4  \cross OPERATING\_MODE\_TYPE\\
\circchannel apex\_new\_partition\_mode\_fail: PARTITION\_ID\_TYPE 
\end{circus}%
%<*APEXchannels>

%item Channels for communication between the APEX and its health monitor
%<*APEXHMchannels>
\begin{circus}
\circchannel apex\_send\_mpHM\_table : A653\_MultiPartitionHMTableType \\ \t4  \cross (\seq_1 A653\_ErrorIdentifierType)
% \circchannel apex\_send\_mpHM\_table : \iseq_1[~A653\_MultiPartitionHMTableType~] \\ \t4  \cross (\seq_1 A653\_ErrorIdentifierType)
\end{circus}%
%</APEXHMchannels>

%item Channels for communication between Partitions and the APEX
%<*PARTchannels>
\begin{circus}
\circchannel part\_set\_partition\_mode: PARTITION\_ID\_TYPE \\
       \t4  \cross ARINC\_CONSTANTS\\
\circchannel part\_req\_partition\_status: PARTITION\_ID\_TYPE\\
\circchannel part\_get\_partition\_status: PARTITION\_ID\_TYPE\\
       \t4  \cross PARTITION\_STATUS\_TYPE\\
\circchannel part\_req\_system\_time: PARTITION\_ID\_TYPE\\
\circchannel part\_get\_system\_time: PARTITION\_ID\_TYPE \\
       \t4  \cross SYSTEM\_TIME\_TYPE\\
\circchannel part\_req\_sampling\_port\_id: PARTITION\_ID\_TYPE \\
       \t4  \cross SAMPLING\_PORT\_NAME\_TYPE\\
\circchannel part\_get\_sampling\_port\_id: PARTITION\_ID\_TYPE \\
       \t4  \cross SAMPLING\_PORT\_ID\_TYPE\\
\circchannel partHM\_restart\_partition : PARTITION\_ID\_TYPE
\end{circus}%
%<*PARTchannels>

%item Channels for communication between each Partition and its health monitor
%<*PARTHMchannels>
\begin{circus}  
\circchannel part\_send\_partHM\_table: PARTITION\_ID\_TYPE \\
       \t4  \cross A653\_PartitionHMTableType \\
       \t4  \cross (\seq_1 A653\_ErrorIdentifierType)
\end{circus}%
%<*PARTHMchannels>

%item Channels for communication between ARINC processes and its Partition
%<*PROCchannels>
\begin{circus}
\circchannel proc\_req\_system\_time: PARTITION\_ID\_TYPE \\
       \t4  \cross PROCESS\_ID\_TYPE\\
\circchannel proc\_get\_system\_time: PARTITION\_ID\_TYPE \\
       \t4  \cross PROCESS\_ID\_TYPE \\
       \t4  \cross SYSTEM\_TIME\_TYPE\\
\circchannel proc\_set\_partition\_mode: PARTITION\_ID\_TYPE \\
       \t4  \cross PROCESS\_ID\_TYPE \\
       \t4  \cross ARINC\_CONSTANTS\\
\circchannel proc\_req\_sampling\_port\_id: PARTITION\_ID\_TYPE \\
       \t4  \cross PROCESS\_ID\_TYPE \\
       \t4  \cross SAMPLING\_PORT\_NAME\_TYPE\\
\circchannel proc\_get\_sampling\_port\_id: PARTITION\_ID\_TYPE \\
       \t4  \cross PROCESS\_ID\_TYPE \\
       \t4  \cross SAMPLING\_PORT\_ID\_TYPE\\
\circchannel proc\_req\_partition\_status: PARTITION\_ID\_TYPE \\
       \t4  \cross PROCESS\_ID\_TYPE\\
\circchannel proc\_get\_partition\_status: PARTITION\_ID\_TYPE \\
       \t4  \cross PROCESS\_ID\_TYPE\\
       \t4  \cross PARTITION\_STATUS\_TYPE
\end{circus}%
%<*PROCchannels>

%item Channel for communication between the Operating System and its health monitor
%<*OSHMchannels>
\begin{circus}       
\circchannel os\_send\_modHM\_table : \iseq ~A653\_ModuleHMTableType \\ \t4  \cross \seq_1 A653\_ErrorIdentifierType
% \circchannel os\_send\_modHM\_table : \iseq_1[~A653\_ModuleHMTableType~]\\ \t4  \cross \seq_1 A653\_ErrorIdentifierType
\end{circus}%
%<*OSHMchannels>

%item Channel for communication between the Timer and the Operating System
%<*TIMERchannels>
\begin{circus}
\circchannel updateClock: SYSTEM\_TIME\_TYPE
\end{circus}%
%</TIMERchannels>
% \end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%% Section Partitions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Partitions}

\subsection{Channels}
%<*PartitionApex>
\begin{circus}
  \circchannelset PartitionApex == \lchanset~part\_req\_partition\_status, part\_get\_partition\_status,\\  
  \t2  part\_req\_sampling\_port\_id, part\_get\_sampling\_port\_id,\\
  \t2  part\_req\_system\_time, part\_get\_system\_time,\\
  \t2  return\_code, part\_set\_partition\_mode, \\
  \t2  moduleInit,moduleEnd,moduleEndInit,endPartition, reinitPartition~\rchanset
\end{circus}
%</PartitionApex> 

\subsection{Partition process}
%<*beginpartproc>
\begin{circus}% 
  \circprocess ~A653\_Partition ~\circdef~ partitionId : PARTITION\_ID\_TYPE; partHM: A653\_PartitionHMTableType; sysError : \seq_1 A653\_ErrorIdentifierType ~\circspot~\circbegin
\end{circus}%
%</beginpartproc>

%<*pgettime>
\begin{circusaction}
  GetTime ~\circdef~   
  proc\_req\_system\_time.partitionId?processId \then\\
  \t1  part\_req\_system\_time.partitionId \then\\
  \t1  part\_get\_system\_time.partitionId?t \then\\
  \t1  proc\_get\_system\_time.partitionId.processId!t \then\\
  \t1  return\_code.partitionId?rc \then \Skip 
\end{circusaction}  
%</pgettime>

%<*pSetPartitionMode>
\begin{circusaction}
  SetPartitionMode ~\circdef~ \\
  \t1  proc\_set\_partition\_mode.partitionId?processId?OPERATING\_MODE \then\\
  \t1  part\_set\_partition\_mode.partitionId!OPERATING\_MODE \then\\
  \t1  return\_code.partitionId?rc \then \Skip 
\end{circusaction}  
%</pSetPartitionMode>

%<*pGetSamplingPortId>
\begin{circusaction}
  GetSamplingPortId ~\circdef \\
  \t1  proc\_req\_sampling\_port\_id.partitionId?processId?SAMPLING\_PORT\_NAME \then\\
  \t1  part\_req\_sampling\_port\_id.partitionId!SAMPLING\_PORT\_NAME \then\\
  \t1  part\_get\_sampling\_port\_id.partitionId?spid \then\\
  \t1  proc\_get\_sampling\_port\_id.partitionId!processId!spid \then\\
  \t1  return\_code.partitionId?rc \then \Skip
\end{circusaction}    
%</pGetSamplingPortId>

%<*pGetPartitionStatus>
\begin{circusaction}
  GetPartitionStatus ~\circdef \\
  \t1  proc\_req\_partition\_status.partitionId?processId \then\\
  \t1  part\_req\_partition\_status.partitionId \then\\
  \t1  part\_get\_partition\_status.partitionId?st \then\\
  \t1  proc\_get\_partition\_status.partitionId.processId!st \then\\
  \t1  return\_code.partitionId?rc \then \Skip
\end{circusaction}    
%</pGetPartitionStatus>

%<*ExecPartitionServices>
\begin{circusaction}
  ExecPartitionServices ~\circdef~\\
  \t1  execPartition.partitionId \then\\
  \t1  (
    \circmu~X \circspot
     (
      SetPartitionMode\\
        \extchoice~~ GetPartitionStatus\\
        \extchoice~~ GetSamplingPortId\\
        \extchoice~~ GetTime 
       ) \circseq X\\
    % interruption is not yet supported
    % \circinterrupt~
    % (interruptPartition.partitionId \then \Skip)
   )
\end{circusaction}
%</ExecPartitionServices>

%<*HMDecInterruption>
%\begin{circusaction}
% HMDecInterruption ~\circdef 
%   (moduleHMRestart \then ExecPartition \\
%     \extchoice~~ moduleIdle \then \Skip
%     
%    )
%\end{circusaction}
%</HMDecInterruption>

%<*ExecPartition>
\begin{circusaction}
  ExecPartition ~\circdef~initPartition.partitionId \then\\
  \t1  part\_send\_partHM\_table.partitionId!pHM!sysError \then \\
  \t1  moduleEndInit \then\\
  \t1  ((\circmu~X \circspot ExecPartitionServices\circseq X)\\
  % \circinterrupt~ (endPartition.partitionId \then \Skip\\
  %   \extchoice~~ reinitPartition.partitionId \then ReinitPartition )
   )
\end{circusaction}
%</ExecPartition>
%<*ReinitPartition>
\begin{circusaction}
  ReinitPartition ~\circdef~partHM\_restart\_partition.partitionId \then\\
  \t1  ((\circmu~X \circspot ExecPartitionServices\circseq X)\\
  % \circinterrupt~ (endPartition.partitionId \then \Skip\\
  %   \extchoice~~ reinitPartition.partitionId \then ReinitPartition
  %   )
  )
\end{circusaction}
%</ReinitPartition>

\begin{circus}
  \circspot moduleInit \then ExecPartition % \circinterrupt~moduleEnd \then \Skip)
  \circend
\end{circus}

\subsection{The Partition Level Health Monitor}
%<*PartitionHM>
\begin{circus}
  \circprocess\ PartitionHM ~\circdef~ partitionId : PARTITION\_ID\_TYPE \circspot 
  \circbegin~
\circstate PartitionHMSt == [pHM:A653\_PartitionHMTableType;\\
  \t3  sysError : \seq_1 A653\_ErrorIdentifierType]

  \t1  \circspot (part\_send\_partHM\_table.partitionId?phm?se \then \\
  (pHM,sysError := phm,se) )\\
    % \t3  \circinterrupt 
    % (moduleEnd \then \Skip\\ 
    % \extchoice\ endPartition.partitionId \then \Skip)

  \circend
\end{circus}
%</PartitionHM>
%<*PartitionHMChannels>
\begin{circus}
  \circchannelset PartitionHMChannels ==\\\t3  \lchanset~part\_send\_partHM\_table, moduleEnd,endPartition~\rchanset
\end{circus}
%</PartitionHMChannels>
\subsection{Partitions Layer Model}
%<*procPartitions>
\begin{circus}
  \circprocess\ Partitions\_Layer ~\circdef~ partitionIds : \power PARTITION\_ID\_TYPE; \\
  \t1  partHM:\seq_1 A653\_PartitionHMTableType;\\
  \t2  sysError : \seq_1 A653\_ErrorIdentifierType \\
  \t2  \circspot
    \lpar \lchanset moduleInit, moduleEnd, moduleEndInit \rchanset \rpar \\
   pid:partitionIds  \circspot 
    (A653\_Partition(pid, partHM(pid), sysError))
     \lpar PartitionHMChannels \rpar PartitionHM(pid)\\
    
\end{circus}%
%</procPartitions>
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Section APEX %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The APEX}

%TODO: The following channelset must be analysed during the analysis of the specification, translated to CSP, in FDR2.
%<*APEXOS>
\begin{circus}
  \circchannelset ApexOs == \lchanset~moduleInit,moduleEnd,moduleEndInit,\\
    \t2  endPartition, reinitPartition, return\_code,\\ 
    \t2  apex\_get\_sampling\_port\_id, apex\_req\_new\_partition\_mode, \\
    \t2  apex\_req\_partition\_status, apex\_get\_partition\_status, \\
    \t2  apex\_req\_system\_time, apex\_get\_system\_time, \\
    \t2  apex\_req\_partition\_mode, apex\_get\_partition\_mode,\\ 
    \t2  apex\_req\_sampling\_port\_id, apex\_new\_partition\_mode\_fail~\rchanset
\end{circus}


%</APEXOS>
\subsection{APEX Process}
%Type of the partitions%
%<*APEXbegin>
\begin{circus}
  \circprocess\ APEX ~\circdef sysError : \seq_1 A653\_ErrorIdentifierType;\\
  \t4  mpHM:\seq_1 A653\_MultiPartitionHMTableType \circspot \circbegin
\end{circus}%
%</APEXbegin>
%<*gettime>
\begin{circusaction}
  GET\_TIME ~\circdef~ part\_req\_system\_time?pid \then\\
  \t1  apex\_req\_system\_time.pid \then\\
  \t1  apex\_get\_system\_time.pid?t \then\\
  \t1  part\_get\_system\_time.pid!t \then\\
  \t1  return\_code.pid!NO\_ERROR \then \Skip 
\end{circusaction}
%</gettime>
%<*getpartitionstatus>  
\begin{circusaction}
  GET\_PARTITION\_STATUS ~\circdef~ \\
  \t1  part\_req\_partition\_status?pid \then\\
  \t1  apex\_req\_partition\_status.pid \then\\
  \t1  apex\_get\_partition\_status.pid?cp \then\\
  \t1  part\_get\_partition\_status.pid!cp \then \Skip
\end{circusaction}
%</getpartitionstatus>
%<*setpartitionmode>
\begin{circusaction}
  SET\_PARTITION\_MODE ~\circdef~\\
  \t1  part\_set\_partition\_mode?pid?nopm \then\\
  \t1  apex\_req\_partition\_mode.pid \then\\
  \t1  apex\_get\_partition\_mode.pid?opm \then\\
    \t2 (
      \circif~ (nopm \notin OPERATING\_MODE\_TYPE) \circthen \\
        \t1  return\_code.pid!INVALID\_PARAM \then\Skip \\
      \circelse~~(opm = NORMAL \land nopm = NORMAL) \circthen\\
        \t1  apex\_new\_partition\_mode\_fail.pid \then\\
        \t1  return\_code.pid!NO\_ACTION \then\Skip \\
      \circelse~~(opm = COLD\_START \land nopm = WARM\_START) \circthen \\
        \t1  apex\_new\_partition\_mode\_fail.pid \then \\
        \t1  return\_code.pid!INVALID\_MODE \then\Skip \\
      \circelse~~(nopm = IDLE\\
               \lor nopm \in OPERATING\_INIT\_MODE\_TYPE
                ) \circthen \\
        \t1  apex\_req\_new\_partition\_mode.pid!nopm \then\\
        \t1  return\_code.pid!NO\_ERROR \then \Skip \\
      \circelse~~(opm \neq NORMAL \land nopm = NORMAL) \circthen \\
        \t1  apex\_req\_new\_partition\_mode.pid!nopm \then\\
        \t1  return\_code.pid!NO\_ERROR \then\Skip \\
    \circfi )
  \end{circusaction}
%</setpartitionmode>
%<*getsamplingportid> 
\begin{circusaction}
  GET\_SAMPLING\_PORT\_ID ~\circdef\\
    \t1  part\_req\_sampling\_port\_id?pid?spn \then\\
    \t1  apex\_req\_sampling\_port\_id.pid!spn \then\\
    \t1  apex\_get\_sampling\_port\_id.pid?spid \then\\
      \t2 (\circif~(spid = \negate 1) \circthen\\
        \t1  part\_get\_sampling\_port\_id.pid!spid \then\\
        \t1  return\_code.pid!INVALID\_CONFIG \then \Skip\\
        \circelse~~(spid \neq \negate 1) \circthen\\
        \t1  part\_get\_sampling\_port\_id.pid!spid \then\\
        \t1  return\_code.pid!NO\_ERROR \then \Skip\\
        \circfi )
\end{circusaction}    
%</getsamplingportid>
%<*CheckPortName> 
% \begin{schema}{CheckPortName}
%   SAMPLING\_PORT\_NAME?: SAMPLING\_PORT\_NAME\_TYPE\\
%   MAX\_MESSAGE\_SIZE? : MESSAGE\_SIZE\_TYPE\\
%   PORT\_DIRECTION? : PortDirectionType\\
%   ports?:PartitionPorts\\
%   port\_exists!,max\_mess\_size!,port\_direction! : Boolean
% \where
%   \forall p:A653\_SamplingPortType | SamplingPort(p) \in \ran ports?\\
%   \t2  @ ((p.Name = SAMPLING\_PORT\_NAME?) \implies port\_exists! = TRUE)\\
%   \t3 \land ((p.MaxMessageSize = MAX\_MESSAGE\_SIZE?)\\
%     \t1  \implies max\_mess\_size! = TRUE )\\
%   \t3 \land ((p.Direction = PORT\_DIRECTION?)\\
%     \t1  \implies port\_direction! = TRUE )
% \end{schema}
%</CheckPortName>
%<*createsamplingport>
% \begin{circusaction}
% CREATE\_SAMPLING\_PORT ~\circdef\\
% \t1  \circval SAMPLING\_PORT\_NAME : NameType; \\
% \t1  \circval MAX\_MESSAGE\_SIZE : MESSAGE\_SIZE\_TYPE;\\
% \t1  \circval PORT\_DIRECTION : PortDirectionType \circspot \\
% \t1  (\circmu X \circspot (\circvar ports : PartitionPorts;\\
% \t2  port\_exists,max\_mess\_size,port\_direction : Boolean; \\
% \t2  SAMPLING\_PORT\_ID: SAMPLING\_PORT\_ID\_TYPE\\
% \t2  partition\_status:PARTITION\_STATUS\_TYPE\\
% \t2  \circspot apex\_req\_partition\_ports.pid \\
% \t2    \then apex\_get\_partition\_ports?pidorts\\
% \t2  \then apex\_req\_partition\_status.pid\\
% \t2  \then get\_pstatus?status \then \lschexpract CheckPortName \rschexpract \circseq \\
       
% \t2  GET\_SAMPLING\_PORT\_ID(SAMPLING\_PORT\_NAME,\\
%   \t4  \t4  SAMPLING\_PORT\_ID) \circseq\\
%   %no sampling port of the partition is named SAMPLING\_PORTNAME in the configuration tables
% \t1    (\circif (port\_exists = TRUE) \circthen return\_code.pid!INVALID\_CONFIG \then \Skip \\
%   %a port named SAMPLING\_PORTNAME is already created
% \t2    \circelse~~(SAMPLING\_PORT\_ID \neq \negate 1) \circthen\\
% \t3  return\_code!NO\_ACTION \then \Skip\\
% %max\_message\_size is zero, negative or is not equal to the value specified in the configuration tables
% \t2    \circelse~~(MAX\_MESSAGE\_SIZE \leq 0 \lor max\_mess\_size \neq TRUE) \circthen\\
%     \t3  return\_code.pid!INVALID\_CONFIG \then \Skip \\
%     %port direction is invalid or not equal to the value...
% \t2    \circelse~~(port\_direction \neq TRUE) \circthen\\
%   \t3  return\_code.pid!INVALID\_CONFIG \then \Skip \\
% \t2    \circelse~~(partition\_status.OPERATING\_MODE = NORMAL) \circthen\\
%   \t3  return\_code.pid!INVALID\_MODE \then \Skip \\
% \t2    \circelse~~((port\_exists \neq TRUE) \land (SAMPLING\_PORT\_ID = \negate 1) \land\\
% \t3    (MAX\_MESSAGE\_SIZE > 0 \land max\_mess\_size = TRUE) \land\\
% \t3    (port\_direction = TRUE) \land\\
% \t3    (partition\_status.OPERATING\_MODE \neq NORMAL))\\
% \t3      \circthen
%   apex\_send\_new\_partition\_port!SAMPLING\_PORT\_NAME!MAX\_MESSAGE\_SIZE!PORT\_DIRECTION\\
% \t3    \then apex\_get\_new\_partition\_port\_id?SAMPLING\_PORT\_ID\\
% \t3  \then
%   apex\_send\_new\_port.pid!SAMPLING\_PORT\_ID \then \Skip
% \t2      \circfi)) \\
% )
% \end{circusaction}  
%</createsamplingport>
%<*ExecApexServices>
\begin{circusaction}
  ExecApexServices ~\circdef
  execPartition?pid \then\\
  \t1  (
    \circmu~X \circspot
    (
      GET\_TIME \\
      \extchoice~~ SET\_PARTITION\_MODE\\
      \extchoice~~ GET\_PARTITION\_STATUS\\
      \extchoice~~ GET\_SAMPLING\_PORT\_ID
      
       )\circseq X\\
    % \circinterrupt~ 
    % (
    %   interruptPartition.pid \then \Skip\\
    %   \extchoice~~endPartition.pid \then \Skip
    %   )
   )
\end{circusaction}
%</ExecApexServices>

%<*HMDecInterruption>
%\begin{circusaction}
% HMDecInterruption ~\circdef 
%   (moduleHMRestart \then ExecApex \\
%     \extchoice~~ moduleIdle \then \Skip
%     
%    )
%\end{circusaction}
%</HMDecInterruption>

%<*ExecApex>  
\begin{circusaction}
  ExecApex ~\circdef~ apex\_send\_mpHM\_table!mpHM!sysError \then\\
    \t1  moduleEndInit \then (\circmu~X \circspot ExecApexServices \circseq X)
        %\circinterrupt~ moduleHMDecision \then HMDecInterruption
\end{circusaction}
%</ExecApex>

%<*ApexEnd>
\begin{circus}
  \t1  \circspot moduleInit \then ExecApex\\ %\circinterrupt~ moduleEnd \then \Skip)

  \circend
\end{circus}
%</ApexEnd> 
\subsection{The APEX Health Monitor (Multi-Partition)}
%<*MultiPartitionHM>
\begin{circus}
  \circprocess\ MultiPartitionHM ~\circdef~ \circbegin
  \t1 \circstate MultiPartitionHMSt ==\\
  \t3  [mpHM: \seq_1 A653\_MultiPartitionHMTableType;\\
  \t4  sysError : \seq_1 A653\_ErrorIdentifierType]\\

  \t1 \circspot apex\_send\_mpHM\_table?mp?se \then\\
  \t3  (mpHM,sysError := mp,se) \\
    % \t4  \circinterrupt 
    %     moduleEnd \then \Skip
  \circend
\end{circus}
%</MultiPartitionHM>
%<*MultiPartitionHMChannels>
\begin{circus}
  \circchannelset MultiPartitionHMChannels == 
  \lchanset~apex\_send\_mpHM\_table, moduleEnd~\rchanset
\end{circus}
%</MultiPartitionHMChannels>
\subsection{APEX Layer Model}
%<*APEX>
\begin{circus}
  \circprocess\ APEX\_Layer ~\circdef~mpHM:\seq_1 A653\_MultiPartitionHMTableType;\\
  \t2  sysError : \seq_1 A653\_ErrorIdentifierType\\
  \t3  \circspot(APEX(sysError,mpHM)\\
  \t1  \lpar MultiPartitionHMChannels \rpar MultiPartitionHM )
\end{circus}%
%</APEX>
\section{The Operating System}

\subsection{The Operating System \Circus~ process}
%<*OperatingSystemBegin>  

\begin{circus}
  \circprocess\ OperatingSystem ~\circdef~ module:Module \circspot \circbegin
\circstate OSSt == OS
\end{circus}
\begin{schema}{OS}
  % partitions\_variables : \iseq_1[PartitionVariables]\\
  partitions\_variables : \iseq PartitionVariables\\
  major\_time\_frame : SYSTEM\_TIME\_TYPE;\\
  system\_time : SYSTEM\_TIME\_TYPE\\
  current\_partition: A653\_PartitionTimeWindowType\\
  current\_partition\_id : PARTITION\_ID\_TYPE\\
  sampling\_ports: (SAMPLING\_PORT\_ID\_TYPE\pfun \\
  \t4  \t2  SAMPLING\_PORT\_NAME\_TYPE)\\
  queuing\_ports: (QUEUING\_PORT\_ID\_TYPE\pfun \\
  \t4  \t2  QUEUING\_PORT\_NAME\_TYPE)
  \where 
  \# partitions\_variables = \# module.Partitions
\end{schema}
%</OSSt>
%<*InitPartitions>
\begin{circusaction}
  InitPartition ~\circdef~ \Interleave pid : (1 \upto (\# module.Partitions)) \circspot initPartition.pid \then \Skip
\end{circusaction}
%</InitPartitions>

%<*MajorTimeFrame>
  \begin{schema}{MajorTimeFrame}
    \Delta OSSt\\
    getMajorTimeFrame : PartitionsType
  \where
    \forall x: \ran module.Partitions\\
    \t1  @ \#~(module.Partitions \rres \{ x\}) = \#~(getMajorTimeFrame \rres \{ x\})\\
    \forall p1,p2 : \ran getMajorTimeFrame\\
    \t1  @ ((p1.PartitionPeriodicity).Period > (p2.PartitionPeriodicity).Period)\\
    major\_time\_frame' =  ((getMajorTimeFrame(1)).PartitionPeriodicity).Period\\
    %(\theta (OSSt \hide (major\_time\_frame ))' = \theta (OSSt \hide (major\_time\_frame)))
    
  \end{schema}
%</MajorTimeFrame>
%<*NextPartition>
  \begin{schema}{NextPartition}
    \Delta OSSt\\
  \where
    current\_partition' = head~(module.Schedules \filter \\
    \t2 \{p:A653\_PartitionTimeWindowType | \\
    \t4  (system\_time \mod major\_time\_frame) \leq p.Offset\})\\
   ( (module.Partitions(current\_partition\_id')).PartitionDefinition).Name=\\
    \t4  (current\_partition').PartitionNameRef\\
    % \theta (OSSt \hide (current\_partition\_id, current\_partition))' =\\ 
    % \t1  \theta (OSSt \hide (current\_partition\_id, current\_partition))
  \end{schema}
%</NextPartition>
%<*UpdateSystemTime>
\begin{circusaction}
  UpdateSystemTime ~\circdef~ updateClock?x \then (system\_time := x)
\end{circusaction}
%</UpdateSystemTime>
%<*OSGetTime>
\begin{circusaction}
  OSGetTime ~\circdef~ (apex\_req\_system\_time.current\_partition\_id \then UpdateSystemTime)\circseq\\
  \t2  (apex\_get\_system\_time.current\_partition\_id!system\_time \then \Skip)
\end{circusaction}
%</OSGetTime>
%<*OSGetPartitionStatus>  
\begin{schema}{PartitionStatus}
  \Xi OSSt\\
  p! : PARTITION\_STATUS\_TYPE
\where
  (p!).Identifier =\\
  \t1 ((module.Partitions(current\_partition\_id)).PartitionDefinition).Identifier\\
  (p!).Period =\\
  \t1 ((module.Partitions(current\_partition\_id)).PartitionPeriodicity).Period\\
  (p!).Duration =\\
  \t1 ((module.Partitions(current\_partition\_id)).PartitionPeriodicity).Duration\\
  (p!).LOCK\_LEVEL =\\
  \t1 (partitions\_variables(current\_partition\_id)).LOCK\_LEVEL\\
  (p!).OPERATING\_MODE =\\
  \t1 (partitions\_variables(current\_partition\_id)).OPERATING\_MODE\\
  (p!).START\_CONDITION =\\
  \t1 (partitions\_variables(current\_partition\_id)).START\_CONDITION
\end{schema}

\begin{circusaction}
  OSGetPartitionStatus ~\circdef~ \circvar p:PARTITION\_STATUS\_TYPE \circspot\\
  \t1  (apex\_req\_partition\_status.current\_partition\_id \then \lschexpract PartitionStatus \rschexpract) \circseq\\
  \t2  (apex\_get\_partition\_status.current\_partition\_id!p \then \Skip)
\end{circusaction}
%</OSGetPartitionStatus>
%<*SetPMode>
  \begin{schema}{SetPMode}
    \Delta OSSt\\
    nopm?:OPERATING\_MODE\_TYPE
  \where
    partitions\_variables' =\\
    (\LET o == \lblot~ OPERATING\_MODE == nopm?,\\
        START\_CONDITION ==\\
      \t1  (partitions\_variables(current\_partition\_id)).START\_CONDITION,\\
      LOCK\_LEVEL ==\\
      \t1  (partitions\_variables(current\_partition\_id)).LOCK\_LEVEL ~\rblot\\
    \t1 @ partitions\_variables \oplus \{current\_partition\_id \mapsto o\})\\
    % \theta (OSSt \hide (current\_partition\_id, current\_partition, partitions\_variables))' =\\ 
    % \t1  \theta (OSSt \hide (current\_partition\_id, current\_partition, partitions\_variables))
  \end{schema}
%</SetPMode>
%<*OSSetPartitionMode>
\begin{circusaction}
  OSSetPartitionMode ~\circdef~ \circvar opm:OPERATING\_MODE\_TYPE \circspot\\
\t1  apex\_req\_partition\_mode.current\_partition\_id \then\\
  %\t1  opm := (PartitionsVariables(current\_partition\_id)).OPERATING\_MODE \circseq \\
  \t1  apex\_get\_partition\_mode.current\_partition\_id!((PartitionsVariables(current\_partition\_id)).OPERATING\_MODE) \then\\
  \t1 (
  (apex\_req\_new\_partition\_mode.current\_partition\_id?nopm  \then\\
  \circif (nopm = IDLE) 
  \circthen\\
  \t1  endPartition.current\_partition\_id \then\ \lschexpract SetPMode \rschexpract\\
  \circelse~~(nopm \in OPERATING\_INIT\_MODE\_TYPE) \circthen \\
  \t1  reinitPartition.current\_partition\_id  \then\ \lschexpract SetPMode \rschexpract\\
  \circelse~~(nopm = NORMAL) \circthen \lschexpract SetPMode \rschexpract\\ 
  \circfi )\\
  \extchoice~~ apex\_new\_partition\_mode\_fail?current\_partition\_id \then \Skip\\
     )
\end{circusaction}
%</OSSetPartitionMode>
%<*OSGetSamplingPortId> 
\begin{circusaction}
  OSGetSamplingPortId ~\circdef\\
    \t1  apex\_req\_sampling\_port\_id.current\_partition\_id?spn \then\\
    \t1 (\circif (spn \in \ran sampling\_ports) \circthen \\
    \t1  apex\_get\_sampling\_port\_id.current\_partition\_id!(\mu 
     x:(\dom (sampling\_ports \rres \{spn\})) @ x) \then\\       
    \t1  return\_code.current\_partition\_id!NO\_ERROR \then \Skip\\
    \circelse~~(spn \notin \ran sampling\_ports) \circthen \\
    \t1  apex\_get\_sampling\_port\_id.current\_partition\_id!(\negate 1) \then\\
    \t1  return\_code.current\_partition\_id!INVALID\_CONFIG \then \Skip\\
    \circfi )
\end{circusaction}    
%</OSGetSamplingPortId>
%<*ExecOSServices>
\begin{circusaction}
  ExecOSServices ~\circdef~\\
  \t1  execPartition.current\_partition\_id \then \\
  \t1  (
    \circmu~X \circspot
     (
      
        OSGetTime \\
        \extchoice~~ OSGetPartitionStatus\\
        \extchoice~~ OSSetPartitionMode \\
        \extchoice~~ OSGetSamplingPortId
       )
    \circseq X
   )
\end{circusaction}
%</ExecOSServices>
%<*ExecOS>
  %\begin{circusaction}
  % OSMainAction ~\circdef~ MajorTimeFrame \circseq \\
  % \t1  (\circmu~X \circspot UpdateSystemTime \circseq \lschexpract NextPartition \rschexpract \circseq\\
  % \t2  (\circif (current\_partition.Offset > (system\_time \mod major\_time\_frame)) \circthen\\
  % \t3  \circwait (current\_partition.Offset -\\
  % \t4  \t2 (system\_time \mod major\_time\_frame)) \circseq X\\
  % \t2  \circelse~~(current\_partition.Offset = (system\_time \mod major\_time\_frame)) \circthen\\
  % \t3  (ExecOSServices \lcirctimeout current\_partition.Duration \rcirctimeout X)\\
  % \t2 \circfi))
  %\end{circusaction}
\begin{circusaction}
  ExecOS ~\circdef~ \circvar getMajorTimeFrame : PartitionsType \circspot \lschexpract MajorTimeFrame \rschexpract \circseq \\
  \t1 (
  \circmu~X \circspot UpdateSystemTime \circseq \lschexpract NextPartition \rschexpract \circseq\\
  (\circif 
    (current\_partition.Offset >\\
    \t2  (system\_time \mod major\_time\_frame) ) \circthen\\
  \t1  \circwait (current\_partition.Offset -\\
  \t2 (system\_time \mod major\_time\_frame) ) \circseq X\\
  \circelse~~(current\_partition.Offset =\\
    \t2  (system\_time \mod major\_time\_frame) ) \circthen\\
    \t1  (ExecOSServices% \Timeout{current\_partition.Duration} \\ 
        % \t1  interruptPartition.current\_partition\_id \circseq X
         )\\
  \circfi )
 )
\end{circusaction}
%</ExecOS>
%<*OperatingSystemEnd>
\begin{circus}
  \circspot moduleInit \then
    os\_send\_modHM\_table!((module.HealthMonitoring).ModuleHM)!((module.HealthMonitoring).SystemErrors) 
    \then ExecOS 
    % \t4  ~\circinterrupt~ moduleEnd \then \Skip
  \circend
\end{circus}
%</OperatingSystemEnd>

\subsection{The Timer}
%<*TimerBegin>
\begin{circus}
  \circprocess\ Timer ~\circdef~ \circbegin
  \t1 \circstate\ TimerSt == [clock : SYSTEM\_TIME\_TYPE]
\end{circus}
%</TimerSt>
%<*Counter> 
\begin{circusaction}
  \t1 Counter ~\circdef~ (
  \circmu~X~\circspot~\\
    (
    (%\circwait (1) \circseq 
    clock := clock + 1)\\
    \interleave~ (
      
        (\circmu~Y~\circspot~updateClock!clock \then Y) 
          %\Timeout{1} \Skip
       )
    )\circseq X
   )
\end{circusaction}

  %\begin{circusaction}
  % Counter ~\circdef~ \\
  % \t1 (\circmu~X~\circspot~\\
  % \t2 ((\circwait (1) \circseq clock := clock + 1)
  % \\\t2  \interleave ((\circmu~Y~\circspot~updateClock!clock \then Y) 
  % \lcirctimeout 1 \rcirctimeout \Skip)\circseq\\
  % \t1  X))
  %\end{circusaction}
%</Counter>
%<*TimerEnd>
\begin{circus}
  % \t1 \circspot moduleInit \then (Counter ~\circinterrupt~ moduleEnd \then \Skip)
  \t1 \circspot moduleInit \then Counter

  \circend
\end{circus}
%</TimerEnd>

\subsection{The Operating System Health Monitor (Module)}
%Investigate the Health Monitor actions and include in each \Circus~process.
%\section{The Module Health Monitor}
%<*ModuleHMbegin>
\begin{circus}
  \circprocess\ ModuleHM ~\circdef~ \circbegin

  \t1 \circstate\ ModuleHMSt == [modHM:\seq_1 A653\_ModuleHMTableType;\\
  \t4  sysError : \seq_1 A653\_ErrorIdentifierType]\\
  \t1 \circspot (os\_send\_modHM\_table?mp?se \then (modHM, sysError := mp, se))\\ %InitModuleHM
    %\t4  \circinterrupt moduleEnd \then \Skip 

  \circend
\end{circus}
%</ModuleHMbegin>
%<*ModuleHMChannels>
\begin{circus}
  \circchannelset ModuleHMChannels == \lchanset~os\_send\_modHM\_table, moduleEnd~\rchanset
\end{circus}
%</ModuleHMChannels>
\subsection{The Operating System Layer Model}
%<*OS>
\begin{circus}
  \circprocess\ OS\_Layer ~\circdef~ module : Module
   \circspot ModuleHM \lpar ModuleHMChannels \rpar (OperatingSystem(module) \lpar \lchanset updateClock \rchanset \rpar Timer)
\end{circus}%
%</OS>
%<*IMAModule>
\begin{circus}
  \circprocess\ IMA\_Module ~\circdef~ module : Module\\
    \t1   \circspot (OS\_Layer(module) \lpar ApexOs \rpar (
    
      APEX\_Layer(
        (module.HealthMonitoring).MultiPartitionHM,\\
        (module.HealthMonitoring).SystemErrors )
    \lpar PartitionApex \rpar 
       Partitions\_Layer(
        1 .. \# module.Partitions,\\
        (module.HealthMonitoring).PartitionHM,\\
        (module.HealthMonitoring).SystemErrors )
     )
     )
  \end{circus}%
%</IMAModule>


