include "function_aux.csp"
include "sequence_aux.csp"

datatype ALARM = ON | OFF
RANGE = {0..2}

datatype UNIVERSE = ALA.ALARM | RAN.RANGE
--Conversions
valueALA(ALA.v) = v
valueRAN(RAN.v) = v

typeALA(x) = U_ALA
typeRAN(x) = U_RAN

tagALA(x) = ALA
tagRAN(x) = RAN

-- subtypes of UNIVERSE for ALA
subtype U_ALA = ALA.ALARM

-- subtypes of UNIVERSE for RAN
subtype U_RAN = RAN.RANGE

-- definition of NAME for the entire spec
datatype NAME = sv_buzz | sv_sec | sv_min

-- Subtype definition for RAN
b_RAsv_buzz = {(sv_sec, RAN.0),(sv_min, RAN.0)}
subtype NAME_RAN = sv_sec | sv_min
NAMES_VALUES_RAN = seq({seq({(n,v) | v <- typeRAN(n)}) | n <- NAME_RAN})

-- Subtype definition for ALA
b_ALA = {(sv_buzz, ALA.ON)}
subtype NAME_ALA = sv_buzz
NAMES_VALUES_ALA = seq({seq({(n,v) | v <- typeALA(n)}) | n <- NAME_ALA})

-- Bindings definitions for RAN
BINDINGS_RAN = {set(b) | b <- set(distCartProd(NAMES_VALUES_RAN))}

-- Bindings definitions for ALA
BINDINGS_ALA = {set(b) | b <- set(distCartProd(NAMES_VALUES_ALA))}

-- Channels

channel mget, mset : NAME.UNIVERSE
channel terminate
MEMI = {| mset,mget,terminate |}
channel lget, lset : NAME.UNIVERSE
channel lterminate
MEML = {| lset,lget,lterminate |}


channel tick, time
channel out : (RANGE,RANGE)
channel inc, minsReq
channel ans : RANGE
Sync = {| inc,minsReq,ans |}
channel snooze, radioOn

--------------------------------------------------------------------------------
-- Models
-- I`m using internal choice of bindings so I can test for any binding set.
--------------------------------------------------------------------------------

----------------------------------------------------------------------------------
-- 2 = Typed Memory
----------------------------------------------------------------------------------
Memory2(b_RAN, b_ALA) =
    ([] n:dom(b_RAN) @ mget.n!(apply(b_RAN,n)) -> Memory2(b_RAN, b_ALA))
    []
    ([] n:dom(b_ALA) @ mget.n!(apply(b_ALA,n)) -> Memory2(b_RAN, b_ALA))
    []
    ([] n:dom(b_RAN) @ mset.n?x:typeRAN(n) -> Memory2(over(b_RAN,n,x),b_ALA))
    []
    ([] n:dom(b_ALA) @ mset.n?x:typeALA(n) -> Memory2(b_RAN,over(b_ALA,n,x)))
    []
    terminate -> SKIP


----------------------------------------------------------------------------------
-- 3 - CTOC approach
----------------------------------------------------------------------------------
MemoryALAVar(n,b_ALA) =
    mget.n.apply(b_ALA,n) -> MemoryALAVar(n,b_ALA)
    []
    mset.n?nv:typeALA(n) -> MemoryALAVar(n,over(b_ALA,n,nv))
    []
    terminate -> SKIP

MemoryALA(b_ALA) =
    ( [| {| terminate |} |] n : dom(b_ALA) @ MemoryALAVar(n,dres(b_ALA,{n})) )

MemoryRANVar(n,b_RAN) =
    mget.n.apply(b_RAN,n) -> MemoryRANVar(n,b_RAN)
    []
    mset.n?nv:typeRAN(n) -> MemoryRANVar(n,over(b_RAN,n,nv))
    []
    terminate -> SKIP

MemoryRAN(b_RAN) =
    ( [| {| terminate |} |] n : dom(b_RAN) @ MemoryRANVar(n,dres(b_RAN,{n})) )

Memory3(b_RAN, b_ALA) =
    MemoryRAN(b_RAN) [|{|terminate|}|] MemoryALA(b_ALA)




----------------------------------------------------------------------------------
-- 4 - multiple mgets and msets for each state variable
----------------------------------------------------------------------------------

channel mget_sv_buzz, mset_sv_buzz : UNIVERSE
channel mget_sv_min, mget_sv_sec, mset_sv_min, mset_sv_sec : UNIVERSE
channel lget_sv_buzz, lset_sv_buzz : UNIVERSE
channel lget_sv_min, lget_sv_sec, lset_sv_min, lset_sv_sec : UNIVERSE
MEMIn = {| mget_sv_buzz, mset_sv_buzz, mget_sv_min, mget_sv_sec, mset_sv_min, mset_sv_sec |}
Memory_sv_buzz(b_ALA) =
    mget_sv_buzz.apply(b_ALA,sv_buzz) -> Memory_sv_buzz(b_ALA)
    []
    mset_sv_buzz?nv : typeALA(sv_buzz) -> Memory_sv_buzz(over(b_ALA,sv_buzz,nv))
    []
    terminate -> SKIP
Memory_sv_min(b_RAN) =
    mget_sv_min.apply(b_RAN,sv_min) -> Memory_sv_min(b_RAN)
    []
    mset_sv_min?nv : typeRAN(sv_min) -> Memory_sv_min(over(b_RAN,sv_min,nv))
    []
    terminate -> SKIP
Memory_sv_sec(b_RAN) =
    mget_sv_sec.apply(b_RAN,sv_sec) -> Memory_sv_sec(b_RAN)
    []
    mset_sv_sec?nv : typeRAN(sv_sec) -> Memory_sv_sec(over(b_RAN,sv_sec,nv))
    []
    terminate -> SKIP
Memory4(b_RAN, b_ALA) =
    ((Memory_sv_buzz(b_ALA)
    [| {| terminate |} |]
    Memory_sv_min(b_RAN))
    [| {| terminate |} |]
    Memory_sv_sec(b_RAN))

-- --------------------------------------------------------------------------------
-- -- Models
-- -- I`m using internal choice of bindings so I can test for any binding set.
-- --------------------------------------------------------------------------------
--
-- --------------------------------------------------------------------------------
-- -- Typed approach
-- --------------------------------------------------------------------------------
-- M2 = |~| b_RAN:BINDINGS_RAN, b_ALA:BINDINGS_ALA @ Memory2(b_RAN, b_ALA)
-- Mm2a = |~| b_RAN:BINDINGS_RAN, b_ALA:BINDINGS_ALA
--           @ Memory2(b_RAN, b_ALA)[[mget.sv_buzz <- mget_sv_buzz,
--                                     mget.sv_min <- mget_sv_min,
--                                     mget.sv_sec <- mget_sv_sec,
--                                     mset.sv_buzz <- mset_sv_buzz,
--                                     mset.sv_min <- mset_sv_min,
--                                     mset.sv_sec <- mset_sv_sec]]
--
-- --------------------------------------------------------------------------------
-- -- Distributed approach
-- --------------------------------------------------------------------------------
-- M3 = |~| b_RAN:BINDINGS_RAN, b_ALA:BINDINGS_ALA @ Memory3(b_RAN, b_ALA)
-- Mm3a = |~| b_RAN:BINDINGS_RAN, b_ALA:BINDINGS_ALA
--           @ Memory3(b_RAN, b_ALA)[[mget.sv_buzz <- mget_sv_buzz,
--                                   mget.sv_min <- mget_sv_min,
--                                   mget.sv_sec <- mget_sv_sec,
--                                   mset.sv_buzz <- mset_sv_buzz,
--                                   mset.sv_min <- mset_sv_min,
--                                   mset.sv_sec <- mset_sv_sec]]
--
-- --------------------------------------------------------------------------------
-- -- One mget and mset for each state variable
-- --------------------------------------------------------------------------------
-- M4 = |~| b_RAN:BINDINGS_RAN, b_ALA:BINDINGS_ALA @ Memory4(b_RAN, b_ALA)
-- Mm4a = |~| b_RAN:BINDINGS_RAN, b_ALA:BINDINGS_ALA @
--           Memory4(b_RAN, b_ALA)[[mget_sv_buzz <- mget.sv_buzz,
--                                 mget_sv_min <- mget.sv_min,
--                                 mget_sv_sec <- mget.sv_sec,
--                                 mset_sv_buzz <- mset.sv_buzz,
--                                 mset_sv_min <- mset.sv_min,
--                                 mset_sv_sec <- mset.sv_sec]]
--
-- --------------------------------------------------------------------------------
-- -- Verification
-- --------------------------------------------------------------------------------
-- -- is the distributed approach a refinement of the typed one?
-- assert M2 [FD= M3 -- passed
-- -- is the typed approach a refinement of the distributed one?
-- assert M3 [FD= M2 -- passed
-- -- so they are equivalent!
--
-- -- is the prefixed approach a refinement of the typed one?
-- assert Mm2a [FD= M4 -- passed
-- -- is the typed approach a refinement of the prefixed one?
-- assert M4 [FD= Mm2a -- passed
-- -- so they are equivalent!
--
-- -- is the prefixed approach a refinement of the CTOC one?
-- assert Mm3a [FD= M4 -- passed
-- -- is the CTOC approach a refinement of the prefixed one?
-- assert M4 [FD= Mm3a -- passed
-- -- so they are equivalent!
--
-- --------------------------------------------------------------------------------
-- -- Now we test the inverse, with renaming from the
-- -- prefixed mgets to the other approaches
-- --------------------------------------------------------------------------------
-- assert Mm4a [FD= M2 -- passed
-- assert Mm4a [FD= M3 -- passed
-- assert M3 [FD= Mm4a -- passed
-- assert M2 [FD= Mm4a -- passed
--
--
-- --------------------------------------------------------------------------------
-- -- Finally, we test if all approaches renamed to
-- -- prefixed mgets are refinement from each other
-- --------------------------------------------------------------------------------
-- assert Mm2a [FD= Mm3a -- passed
-- assert Mm3a [FD= M4 -- passed
-- assert M4  [FD= Mm3a -- passed
-- assert Mm3a [FD= Mm2a -- passed



-- Alarm Models

-- Typed
WakeUpOK2(b_RAN,b_ALA) =
  let

    Memory2(b_RAN, b_ALA) =
        ([] n:dom(b_RAN) @ mget.n!(apply(b_RAN,n)) -> Memory2(b_RAN, b_ALA))
        []
        ([] n:dom(b_ALA) @ mget.n!(apply(b_ALA,n)) -> Memory2(b_RAN, b_ALA))
        []
        ([] n:dom(b_RAN) @ mset.n?x:typeRAN(n) -> Memory2(over(b_RAN,n,x),b_ALA))
        []
        ([] n:dom(b_ALA) @ mset.n?x:typeALA(n) -> Memory2(b_RAN,over(b_ALA,n,x)))
        []
        terminate -> SKIP
  within ( ( ( mset.sv_sec.(RAN.0) ->
    mset.sv_min.(RAN.0) ->
    mset.sv_buzz.(ALA.OFF) ->
    ( let X = mget.sv_buzz?v_sv_buzz:(typeALA(sv_buzz)) ->
    mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( ( ( tick ->
    mset.sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 2) ->
    mset.sv_min.(RAN.valueRAN(v_sv_min)) ->
    mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( (valueRAN(v_sv_sec) == 0) & mset.sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 2) ->
    mset.sv_sec.(RAN.valueRAN(v_sv_sec)) -> SKIP )
      [] ( (valueRAN(v_sv_sec) != 0) & SKIP ))
      [] ( (valueRAN(v_sv_min) == 1) & radioOn ->
    mset.sv_buzz.(ALA.ON) -> SKIP ))
      [] time ->
    out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP)
      [] snooze ->
    mset.sv_buzz.(ALA.OFF) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |] Memory2(b_RAN,b_ALA))\MEMI )

WakeUp2(b_RAN,b_ALA) =
  let
    Memory2(b_RAN, b_ALA) =
        ([] n:dom(b_RAN) @ mget.n!(apply(b_RAN,n)) -> Memory2(b_RAN, b_ALA))
        []
        ([] n:dom(b_ALA) @ mget.n!(apply(b_ALA,n)) -> Memory2(b_RAN, b_ALA))
        []
        ([] n:dom(b_RAN) @ mset.n?x:typeRAN(n) -> Memory2(over(b_RAN,n,x),b_ALA))
        []
        ([] n:dom(b_ALA) @ mset.n?x:typeALA(n) -> Memory2(b_RAN,over(b_ALA,n,x)))
        []
        terminate -> SKIP
  within ( ( ( mset.sv_sec.(RAN.0) ->
    mset.sv_min.(RAN.0) ->
    mset.sv_buzz.(ALA.OFF) ->
    ( let X = tick ->
    mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    mset.sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 2) ->
    mset.sv_min.(RAN.valueRAN(v_sv_min)) ->
    mget.sv_buzz?v_sv_buzz:(typeALA(sv_buzz)) ->
    mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( ( ( ( ( (valueRAN(v_sv_sec) == 0) & mset.sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 2) ->
    mset.sv_sec.(RAN.valueRAN(v_sv_sec)) -> SKIP )
      [] ( (valueRAN(v_sv_sec) != 0) & SKIP ))
      [] ( (valueRAN(v_sv_min) == 1) & radioOn ->
    mset.sv_buzz.(ALA.ON) -> SKIP ))
      [] time ->
    out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP)
      [] snooze ->
    mset.sv_buzz.(ALA.OFF) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |] Memory2(b_RAN,b_ALA))\MEMI )

Minutes2(b_RAN) =
  let
    Memory2(b_RAN) =
        ([] n:dom(b_RAN) @ mget.n!(apply(b_RAN,n)) -> Memory2(b_RAN))
        []
        ([] n:dom(b_RAN) @ mset.n?x:typeRAN(n) -> Memory2(over(b_RAN,n,x)))
        []
        terminate -> SKIP
  within ( ( ( mset.sv_min.(RAN.0) ->
    ( let X = mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    ( ( inc ->
    mset.sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 2) -> SKIP
      [] minsReq ->
    ans.valueRAN(v_sv_min) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |] Memory2(b_RAN))\MEMI )

Seconds2(b_RAN) =
  let
    Memory2(b_RAN) =
        ([] n:dom(b_RAN) @ mget.n!(apply(b_RAN,n)) -> Memory2(b_RAN))
        []
        ([] n:dom(b_RAN) @ mset.n?x:typeRAN(n) -> Memory2(over(b_RAN,n,x)))
        []
        terminate -> SKIP
     MemoryMergeRANVar(n,b_RAN,ns) =
        ( ( lget.n.apply(b_RAN,n) ->
    MemoryMergeRANVar(n,b_RAN,ns)
      [] lset.n?nv:typeRAN(n) ->
    MemoryMergeRANVar(n,over(b_RAN,n,nv),ns))
      [] lterminate ->
    (  ; bd : <b_RAN> @   ; n : <y | y <- ns,member(y,dom(bd))> @  mset.n.apply(bd,n) -> SKIP ))
     MemoryMergeRAN(b_RAN,ns) =
        ( [| {| lterminate |} |] n : dom(b_RAN) @ MemoryMergeRANVar(n,b_RAN,ns) )
     MemoryMerge(b_RAN,ns) =
        MemoryMergeRAN(b_RAN,ns)

  within ( ( ( mset.sv_sec.(RAN.0) ->
    ( let X = mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( tick ->
    mset.sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 2) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ((valueRAN(v_sv_sec) == 0) &
         inc -> SKIP [] (valueRAN(v_sv_sec) != 0) &
         SKIP)
      [] time ->
    minsReq ->
    ans?t_sv_min ->
    mset.sv_min.(RAN.t_sv_min) ->
    out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |] Memory2(b_RAN))\MEMI )

Chrono2(b_RAN) =
  let
    Memory2(b_RAN) =
        ([] n:dom(b_RAN) @ mget.n!(apply(b_RAN,n)) -> Memory2(b_RAN))
        []
        ([] n:dom(b_RAN) @ mset.n?x:typeRAN(n) -> Memory2(over(b_RAN,n,x)))
        []
        terminate -> SKIP
     MemoryMergeRANVar(n,b_RAN,ns) =
        ( ( lget.n.apply(b_RAN,n) ->
    MemoryMergeRANVar(n,b_RAN,ns)
      [] lset.n?nv:typeRAN(n) ->
    MemoryMergeRANVar(n,over(b_RAN,n,nv),ns))
      [] lterminate ->
    (  ; bd : <b_RAN> @   ; n : <y | y <- ns,member(y,dom(bd))> @  mset.n.apply(bd,n) -> SKIP ))
     MemoryMergeRAN(b_RAN,ns) =
        ( [| {| lterminate |} |] n : dom(b_RAN) @ MemoryMergeRANVar(n,b_RAN,ns) )
     MemoryMerge(b_RAN,ns) =
        MemoryMergeRAN(b_RAN,ns)

  within ( ( ( ( mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( ( lset.sv_sec.(RAN.0) ->
    ( ( let X = lget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    lget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    lget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( tick ->
    lset.sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 2) ->
    lget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ((valueRAN(v_sv_sec) == 0) &
         inc -> SKIP [] (valueRAN(v_sv_sec) != 0) &
         SKIP)
      [] time ->
    minsReq ->
    ans?t_sv_min ->
    mset.sv_min.(RAN.t_sv_min) ->
    mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP);
      X ) within X );
      lterminate -> SKIP )
      [| MEML |]
      MemoryMerge({(sv_min,v_sv_min),(sv_sec,v_sv_sec)},<sv_sec>) )\MEML )
      [| Sync |]
      ( ( lset.sv_min.(RAN.0) ->
    ( ( let X = lget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    ( ( inc ->
    lset.sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 2) -> SKIP
      [] minsReq ->
    ans.valueRAN(v_sv_min) -> SKIP);
      X ) within X );
      lterminate -> SKIP )
      [| MEML |]
      MemoryMerge({(sv_min,v_sv_min),(sv_sec,v_sv_sec)},<sv_min>) )\MEML ) )\Sync );
      terminate -> SKIP )
      [| MEMI |] Memory2(b_RAN))\MEMI )

AChrono2(b_RAN) =
  let
    Memory2(b_RAN) =
        ([] n:dom(b_RAN) @ mget.n!(apply(b_RAN,n)) -> Memory2(b_RAN))
        []
        ([] n:dom(b_RAN) @ mset.n?x:typeRAN(n) -> Memory2(over(b_RAN,n,x)))
        []
        terminate -> SKIP
  within ( ( ( mset.sv_sec.(RAN.0) ->
    mset.sv_min.(RAN.0) ->
    ( let X = mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( tick ->
    mset.sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 2) ->
    mset.sv_min.(RAN.valueRAN(v_sv_min)) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ((valueRAN(v_sv_sec) == 0) &
         mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    mset.sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 2) ->
    mset.sv_sec.(RAN.valueRAN(v_sv_sec)) -> SKIP [] (valueRAN(v_sv_sec) != 0) &
         SKIP)
      [] time ->
    out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |] Memory2(b_RAN))\MEMI )


-- CTOC
WakeUpOK3(b_RAN,b_ALA) =
  let
    MemoryALAVar(n,b_ALA) =
        mget.n.apply(b_ALA,n) -> MemoryALAVar(n,b_ALA)
        []
        mset.n?nv:typeALA(n) -> MemoryALAVar(n,over(b_ALA,n,nv))
        []
        terminate -> SKIP
    MemoryALA(b_ALA) =
        ( [| {| terminate |} |] n : dom(b_ALA) @ MemoryALAVar(n,dres(b_ALA,{n})) )
    MemoryRANVar(n,b_RAN) =
        mget.n.apply(b_RAN,n) -> MemoryRANVar(n,b_RAN)
        []
        mset.n?nv:typeRAN(n) -> MemoryRANVar(n,over(b_RAN,n,nv))
        []
        terminate -> SKIP
    MemoryRAN(b_RAN) =
        ( [| {| terminate |} |] n : dom(b_RAN) @ MemoryRANVar(n,dres(b_RAN,{n})) )
    Memory3(b_RAN, b_ALA) =
        MemoryRAN(b_RAN) [|{|terminate|}|] MemoryALA(b_ALA)
  within ( ( ( mset.sv_sec.(RAN.0) ->
    mset.sv_min.(RAN.0) ->
    mset.sv_buzz.(ALA.OFF) ->
    ( let X = mget.sv_buzz?v_sv_buzz:(typeALA(sv_buzz)) ->
    mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( ( ( tick ->
    mset.sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 2) ->
    mset.sv_min.(RAN.valueRAN(v_sv_min)) ->
    mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( (valueRAN(v_sv_sec) == 0) & mset.sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 2) ->
    mset.sv_sec.(RAN.valueRAN(v_sv_sec)) -> SKIP )
      [] ( (valueRAN(v_sv_sec) != 0) & SKIP ))
      [] ( (valueRAN(v_sv_min) == 1) & radioOn ->
    mset.sv_buzz.(ALA.ON) -> SKIP ))
      [] time ->
    out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP)
      [] snooze ->
    mset.sv_buzz.(ALA.OFF) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |] Memory3(b_RAN,b_ALA))\MEMI )

WakeUp3(b_RAN,b_ALA) =
  let
    MemoryALAVar(n,b_ALA) =
        mget.n.apply(b_ALA,n) -> MemoryALAVar(n,b_ALA)
        []
        mset.n?nv:typeALA(n) -> MemoryALAVar(n,over(b_ALA,n,nv))
        []
        terminate -> SKIP
    MemoryALA(b_ALA) =
        ( [| {| terminate |} |] n : dom(b_ALA) @ MemoryALAVar(n,dres(b_ALA,{n})) )
    MemoryRANVar(n,b_RAN) =
        mget.n.apply(b_RAN,n) -> MemoryRANVar(n,b_RAN)
        []
        mset.n?nv:typeRAN(n) -> MemoryRANVar(n,over(b_RAN,n,nv))
        []
        terminate -> SKIP
    MemoryRAN(b_RAN) =
        ( [| {| terminate |} |] n : dom(b_RAN) @ MemoryRANVar(n,dres(b_RAN,{n})) )
    Memory3(b_RAN, b_ALA) =
        MemoryRAN(b_RAN) [|{|terminate|}|] MemoryALA(b_ALA)
  within ( ( ( mset.sv_sec.(RAN.0) ->
    mset.sv_min.(RAN.0) ->
    mset.sv_buzz.(ALA.OFF) ->
    ( let X = tick ->
    mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    mset.sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 2) ->
    mset.sv_min.(RAN.valueRAN(v_sv_min)) ->
    mget.sv_buzz?v_sv_buzz:(typeALA(sv_buzz)) ->
    mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( ( ( ( ( (valueRAN(v_sv_sec) == 0) & mset.sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 2) ->
    mset.sv_sec.(RAN.valueRAN(v_sv_sec)) -> SKIP )
      [] ( (valueRAN(v_sv_sec) != 0) & SKIP ))
      [] ( (valueRAN(v_sv_min) == 1) & radioOn ->
    mset.sv_buzz.(ALA.ON) -> SKIP ))
      [] time ->
    out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP)
      [] snooze ->
    mset.sv_buzz.(ALA.OFF) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |] Memory3(b_RAN,b_ALA))\MEMI )

Minutes3(b_RAN) =
  let
    MemoryRANVar(n,b_RAN) =
        mget.n.apply(b_RAN,n) -> MemoryRANVar(n,b_RAN)
        [] mset.n?nv:typeRAN(n) -> MemoryRANVar(n,over(b_RAN,n,nv))
        [] terminate -> SKIP
    MemoryRAN(b_RAN) =
        ( [| {| terminate |} |] n : dom(b_RAN) @ MemoryRANVar(n,dres(b_RAN,{n})) )
    Memory3(b_RAN) = MemoryRAN(b_RAN)
  within ( ( ( mset.sv_min.(RAN.0) ->
    ( let X = mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    ( ( inc -> mset.sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 2) -> SKIP
      [] minsReq -> ans.valueRAN(v_sv_min) -> SKIP); X )
      within X );
      terminate -> SKIP )
      [| MEMI |] Memory3(b_RAN))\MEMI )

Seconds3(b_RAN) =
  let
    MemoryRANVar(n,b_RAN) =
        mget.n.apply(b_RAN,n) -> MemoryRANVar(n,b_RAN)
        []
        mset.n?nv:typeRAN(n) -> MemoryRANVar(n,over(b_RAN,n,nv))
        []
        terminate -> SKIP
    MemoryRAN(b_RAN) =
        ( [| {| terminate |} |] n : dom(b_RAN) @ MemoryRANVar(n,dres(b_RAN,{n})) )
    Memory3(b_RAN) =
        MemoryRAN(b_RAN)

  within ( ( ( mset.sv_sec.(RAN.0) ->
    ( let X = mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( tick ->
    mset.sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 2) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ((valueRAN(v_sv_sec) == 0) &
         inc -> SKIP [] (valueRAN(v_sv_sec) != 0) &
         SKIP)
      [] time ->
    minsReq ->
    ans?t_sv_min ->
    mset.sv_min.(RAN.t_sv_min) ->
    out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |] Memory3(b_RAN))\MEMI )


Chrono3(b_RAN) =
  let
    MemoryRANVar(n,b_RAN) =
        mget.n.apply(b_RAN,n) -> MemoryRANVar(n,b_RAN)
        [] mset.n?nv:typeRAN(n) -> MemoryRANVar(n,over(b_RAN,n,nv))
        [] terminate -> SKIP
    MemoryRAN(b_RAN) =
        ( [| {| terminate |} |] n : dom(b_RAN) @ MemoryRANVar(n,dres(b_RAN,{n})) )
    Memory3(b_RAN) =
        MemoryRAN(b_RAN)
     MemoryMergeRANVar(n,b_RAN,ns) =
        ( ( lget.n.apply(b_RAN,n) ->
    MemoryMergeRANVar(n,b_RAN,ns)
      [] lset.n?nv:typeRAN(n) ->
    MemoryMergeRANVar(n,over(b_RAN,n,nv),ns))
      [] lterminate ->
    (  ; bd : <b_RAN> @   ; n : <y | y <- ns,member(y,dom(bd))> @  mset.n.apply(bd,n) -> SKIP ))
     MemoryMergeRAN(b_RAN,ns) =
        ( [| {| lterminate |} |] n : dom(b_RAN) @ MemoryMergeRANVar(n,b_RAN,ns) )
     MemoryMerge(b_RAN,ns) =
        MemoryMergeRAN(b_RAN,ns)

  within ( ( ( ( mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( ( lset.sv_sec.(RAN.0) ->
    ( ( let X = lget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    lget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    lget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( tick ->
    lset.sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 2) ->
    lget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ((valueRAN(v_sv_sec) == 0) &
         inc -> SKIP [] (valueRAN(v_sv_sec) != 0) &
         SKIP)
      [] time ->
    minsReq ->
    ans?t_sv_min ->
    mset.sv_min.(RAN.t_sv_min) ->
    mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP);
      X ) within X );
      lterminate -> SKIP )
      [| MEML |]
      MemoryMerge({(sv_min,v_sv_min),(sv_sec,v_sv_sec)},<sv_sec>) )\MEML )
      [| Sync |]
      ( ( lset.sv_min.(RAN.0) ->
    ( ( let X = lget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    ( ( inc ->
    lset.sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 2) -> SKIP
      [] minsReq ->
    ans.valueRAN(v_sv_min) -> SKIP);
      X ) within X );
      lterminate -> SKIP )
      [| MEML |]
      MemoryMerge({(sv_min,v_sv_min),(sv_sec,v_sv_sec)},<sv_min>) )\MEML ) )\Sync );
      terminate -> SKIP )
      [| MEMI |] Memory3(b_RAN))\MEMI )

AChrono3(b_RAN) =
  let
    MemoryRANVar(n,b_RAN) =
        mget.n.apply(b_RAN,n) -> MemoryRANVar(n,b_RAN)
        [] mset.n?nv:typeRAN(n) -> MemoryRANVar(n,over(b_RAN,n,nv))
        [] terminate -> SKIP
    MemoryRAN(b_RAN) =
        ( [| {| terminate |} |] n : dom(b_RAN) @ MemoryRANVar(n,dres(b_RAN,{n})) )
    Memory3(b_RAN) = MemoryRAN(b_RAN)
  within ( ( ( mset.sv_sec.(RAN.0) ->
    mset.sv_min.(RAN.0) ->
    ( let X = mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
              mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
              ( ( tick ->
              mset.sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 2) ->
              mset.sv_min.(RAN.valueRAN(v_sv_min)) ->
              mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
              ((valueRAN(v_sv_sec) == 0) &
                   mget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
                    mget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
                    mset.sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 2) ->
                    mset.sv_sec.(RAN.valueRAN(v_sv_sec)) -> SKIP
              [] (valueRAN(v_sv_sec) != 0) & SKIP)
              [] time -> out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP); X )
      within X );
      terminate -> SKIP )
      [| MEMI |] Memory3(b_RAN))\MEMI )

-- Multiple mgets and msets
WakeUpOK4(b_RAN,b_ALA) =
  let
  Memory_sv_buzz(b_ALA) =
      mget_sv_buzz.apply(b_ALA,sv_buzz) -> Memory_sv_buzz(b_ALA)
      [] mset_sv_buzz?nv : typeALA(sv_buzz) -> Memory_sv_buzz(over(b_ALA,sv_buzz,nv))
      [] terminate -> SKIP
  Memory_sv_min(b_RAN) =
      mget_sv_min.apply(b_RAN,sv_min) -> Memory_sv_min(b_RAN)
      [] mset_sv_min?nv : typeRAN(sv_min) -> Memory_sv_min(over(b_RAN,sv_min,nv))
      [] terminate -> SKIP
  Memory_sv_sec(b_RAN) =
      mget_sv_sec.apply(b_RAN,sv_sec) -> Memory_sv_sec(b_RAN)
      [] mset_sv_sec?nv : typeRAN(sv_sec) -> Memory_sv_sec(over(b_RAN,sv_sec,nv))
      [] terminate -> SKIP
  Memory4(b_RAN, b_ALA) =
      ((Memory_sv_buzz(b_ALA)
      [| {| terminate |} |]
      Memory_sv_min(b_RAN))
      [| {| terminate |} |]
      Memory_sv_sec(b_RAN))

  within ( ( ( mset_sv_sec.(RAN.0) ->
    mset_sv_min.(RAN.0) ->
    mset_sv_buzz.(ALA.OFF) ->
    ( let X = mget_sv_buzz?v_sv_buzz:(typeALA(sv_buzz)) ->
    mget_sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget_sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( ( ( tick ->
    mset_sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 2) ->
    mset_sv_min.(RAN.valueRAN(v_sv_min)) ->
    mget_sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget_sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( (valueRAN(v_sv_sec) == 0) & mset_sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 2) ->
    mset_sv_sec.(RAN.valueRAN(v_sv_sec)) -> SKIP )
      [] ( (valueRAN(v_sv_sec) != 0) & SKIP ))
      [] ( (valueRAN(v_sv_min) == 1) & radioOn ->
    mset_sv_buzz.(ALA.ON) -> SKIP ))
      [] time ->
    out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP)
      [] snooze ->
    mset_sv_buzz.(ALA.OFF) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |] Memory2(b_RAN,b_ALA))\MEMIn )

WakeUp4(b_RAN,b_ALA) =
  let
  Memory_sv_buzz(b_ALA) =
      mget_sv_buzz.apply(b_ALA,sv_buzz) -> Memory_sv_buzz(b_ALA)
      [] mset_sv_buzz?nv : typeALA(sv_buzz) -> Memory_sv_buzz(over(b_ALA,sv_buzz,nv))
      [] terminate -> SKIP
  Memory_sv_min(b_RAN) =
      mget_sv_min.apply(b_RAN,sv_min) -> Memory_sv_min(b_RAN)
      [] mset_sv_min?nv : typeRAN(sv_min) -> Memory_sv_min(over(b_RAN,sv_min,nv))
      [] terminate -> SKIP
  Memory_sv_sec(b_RAN) =
      mget_sv_sec.apply(b_RAN,sv_sec) -> Memory_sv_sec(b_RAN)
      [] mset_sv_sec?nv : typeRAN(sv_sec) -> Memory_sv_sec(over(b_RAN,sv_sec,nv))
      [] terminate -> SKIP
  Memory4(b_RAN, b_ALA) =
      ((Memory_sv_buzz(b_ALA)
      [| {| terminate |} |]
      Memory_sv_min(b_RAN))
      [| {| terminate |} |]
      Memory_sv_sec(b_RAN))
  within ( ( ( mset_sv_sec.(RAN.0) ->
    mset_sv_min.(RAN.0) ->
    mset_sv_buzz.(ALA.OFF) ->
    ( let X = tick ->
    mget_sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget_sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    mset_sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 2) ->
    mset_sv_min.(RAN.valueRAN(v_sv_min)) ->
    mget_sv_buzz?v_sv_buzz:(typeALA(sv_buzz)) ->
    mget_sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget_sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( ( ( ( ( (valueRAN(v_sv_sec) == 0) & mset_sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 2) ->
    mset_sv_sec.(RAN.valueRAN(v_sv_sec)) -> SKIP )
      [] ( (valueRAN(v_sv_sec) != 0) & SKIP ))
      [] ( (valueRAN(v_sv_min) == 1) & radioOn ->
    mset_sv_buzz.(ALA.ON) -> SKIP ))
      [] time ->
    out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP)
      [] snooze ->
    mset_sv_buzz.(ALA.OFF) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |] Memory2(b_RAN,b_ALA))\MEMIn )

Minutes4(b_RAN) =
  let
  Memory_sv_min(b_RAN) =
      mget_sv_min.apply(b_RAN,sv_min) -> Memory_sv_min(b_RAN)
      [] mset_sv_min?nv : typeRAN(sv_min) -> Memory_sv_min(over(b_RAN,sv_min,nv))
      [] terminate -> SKIP
  Memory_sv_sec(b_RAN) =
      mget_sv_sec.apply(b_RAN,sv_sec) -> Memory_sv_sec(b_RAN)
      [] mset_sv_sec?nv : typeRAN(sv_sec) -> Memory_sv_sec(over(b_RAN,sv_sec,nv))
      [] terminate -> SKIP
  Memory4(b_RAN) =
      (Memory_sv_min(b_RAN)
      [| {| terminate |} |]
      Memory_sv_sec(b_RAN))
  within ( ( ( mset_sv_min.(RAN.0) ->
    ( let X = mget_sv_min?v_sv_min:(typeRAN(sv_min)) ->
    ( ( inc ->
    mset_sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 2) -> SKIP
      [] minsReq ->
    ans.valueRAN(v_sv_min) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |] Memory4(b_RAN))\MEMIn )

Seconds4(b_RAN) =
  let
  Memory_sv_min(b_RAN) =
      mget_sv_min.apply(b_RAN,sv_min) -> Memory_sv_min(b_RAN)
      [] mset_sv_min?nv : typeRAN(sv_min) -> Memory_sv_min(over(b_RAN,sv_min,nv))
      [] terminate -> SKIP
  Memory_sv_sec(b_RAN) =
      mget_sv_sec.apply(b_RAN,sv_sec) -> Memory_sv_sec(b_RAN)
      [] mset_sv_sec?nv : typeRAN(sv_sec) -> Memory_sv_sec(over(b_RAN,sv_sec,nv))
      [] terminate -> SKIP
  Memory4(b_RAN) =
      (Memory_sv_min(b_RAN)
      [| {| terminate |} |]
      Memory_sv_sec(b_RAN))
  within ( ( ( mset_sv_sec.(RAN.0) ->
    ( let X = mget_sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget_sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget_sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( tick ->
    mset_sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 2) ->
    mget_sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ((valueRAN(v_sv_sec) == 0) &
         inc -> SKIP [] (valueRAN(v_sv_sec) != 0) &
         SKIP)
      [] time ->
    minsReq ->
    ans?t_sv_min ->
    mset_sv_min.(RAN.t_sv_min) ->
    out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |] Memory4(b_RAN))\MEMIn )

Chrono4(b_RAN) =
  let
  Memory_sv_min(b_RAN) =
      mget_sv_min.apply(b_RAN,sv_min) -> Memory_sv_min(b_RAN)
      [] mset_sv_min?nv : typeRAN(sv_min) -> Memory_sv_min(over(b_RAN,sv_min,nv))
      [] terminate -> SKIP
  Memory_sv_sec(b_RAN) =
      mget_sv_sec.apply(b_RAN,sv_sec) -> Memory_sv_sec(b_RAN)
      [] mset_sv_sec?nv : typeRAN(sv_sec) -> Memory_sv_sec(over(b_RAN,sv_sec,nv))
      [] terminate -> SKIP
  Memory4(b_RAN) =
      (Memory_sv_min(b_RAN)
      [| {| terminate |} |]
      Memory_sv_sec(b_RAN))

  MemoryMergeRANVar(n,b_RAN,ns) =
        ( ( lget.n.apply(b_RAN,n) -> MemoryMergeRANVar(n,b_RAN,ns)
      [] lset.n?nv:typeRAN(n) -> MemoryMergeRANVar(n,over(b_RAN,n,nv),ns))
      [] lterminate ->
    (  ; bd : <b_RAN> @   ; n : <y | y <- ns,member(y,dom(bd))> @  mset.n.apply(bd,n) -> SKIP ))
     MemoryMergeRAN(b_RAN,ns) =
        ( [| {| lterminate |} |] n : dom(b_RAN) @ MemoryMergeRANVar(n,b_RAN,ns) )
     MemoryMerge(b_RAN,ns) =
        MemoryMergeRAN(b_RAN,ns)

  within ( ( ( ( mget_sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget_sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget_sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( ( lset.sv_sec.(RAN.0) ->
    ( ( let X = lget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    lget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    lget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( tick ->
    lset.sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 2) ->
    lget.sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ((valueRAN(v_sv_sec) == 0) &
         inc -> SKIP [] (valueRAN(v_sv_sec) != 0) &
         SKIP)
      [] time ->
    minsReq ->
    ans?t_sv_min ->
    mset_sv_min.(RAN.t_sv_min) ->
    mget_sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget_sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP);
      X ) within X );
      lterminate -> SKIP )
      [| MEML |]
      MemoryMerge({(sv_min,v_sv_min),(sv_sec,v_sv_sec)},<sv_sec>) )\MEML )
      [| Sync |]
      ( ( lset.sv_min.(RAN.0) ->
    ( ( let X = lget.sv_min?v_sv_min:(typeRAN(sv_min)) ->
    ( ( inc ->
    lset.sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 2) -> SKIP
      [] minsReq ->
    ans.valueRAN(v_sv_min) -> SKIP);
      X ) within X );
      lterminate -> SKIP )
      [| MEML |]
      MemoryMerge({(sv_min,v_sv_min),(sv_sec,v_sv_sec)},<sv_min>) )\MEML ) )\Sync );
      terminate -> SKIP )
      [| MEMI |] Memory4(b_RAN))\MEMIn )

AChrono4(b_RAN) =
  let
    Memory_sv_min(b_RAN) =
        mget_sv_min.apply(b_RAN,sv_min) -> Memory_sv_min(b_RAN)
        []
        mset_sv_min?nv : typeRAN(sv_min) -> Memory_sv_min(over(b_RAN,sv_min,nv))
        []
        terminate -> SKIP
    Memory_sv_sec(b_RAN) =
        mget_sv_sec.apply(b_RAN,sv_sec) -> Memory_sv_sec(b_RAN)
        []
        mset_sv_sec?nv : typeRAN(sv_sec) -> Memory_sv_sec(over(b_RAN,sv_sec,nv))
        []
        terminate -> SKIP
    Memory4(b_RAN) =
        (Memory_sv_min(b_RAN)
        [| {| terminate |} |]
        Memory_sv_sec(b_RAN))
  within ( ( ( mset_sv_sec.(RAN.0) ->
    mset_sv_min.(RAN.0) ->
    ( let X = mget_sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget_sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ( ( tick ->
    mset_sv_sec.(RAN.(valueRAN(v_sv_sec) + 1) % 2) ->
    mset_sv_min.(RAN.valueRAN(v_sv_min)) ->
    mget_sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    ((valueRAN(v_sv_sec) == 0) &
         mget_sv_min?v_sv_min:(typeRAN(sv_min)) ->
    mget_sv_sec?v_sv_sec:(typeRAN(sv_sec)) ->
    mset_sv_min.(RAN.(valueRAN(v_sv_min) + 1) % 2) ->
    mset_sv_sec.(RAN.valueRAN(v_sv_sec)) -> SKIP [] (valueRAN(v_sv_sec) != 0) &
         SKIP)
      [] time ->
    out.(valueRAN(v_sv_min),valueRAN(v_sv_sec)) -> SKIP);
      X ) within X );
      terminate -> SKIP )
      [| MEMI |] Memory4(b_RAN))\MEMIn )


-- Assertions
m2HAC = |~| b_RAN:BINDINGS_RAN @ AChrono2(b_RAN)
m2aHAC = |~| b_RAN:BINDINGS_RAN @ AChrono2(b_RAN)[[mget.sv_min <- mget_sv_min,
                                                  mget.sv_sec <- mget_sv_sec,
                                                  mset.sv_min <- mset_sv_min,
                                                  mset.sv_sec <- mset_sv_sec]]
m2HC = |~| b_RAN:BINDINGS_RAN @ Chrono2(b_RAN)
m2aHC = |~| b_RAN:BINDINGS_RAN @ Chrono2(b_RAN)[[mget.sv_min <- mget_sv_min,
                                                  mget.sv_sec <- mget_sv_sec,
                                                  mset.sv_min <- mset_sv_min,
                                                  mset.sv_sec <- mset_sv_sec]]
m2HWU = |~| b_RAN:BINDINGS_RAN, b_ALA:BINDINGS_ALA @ WakeUp2(b_RAN,b_ALA)
m2aHWU = |~| b_RAN:BINDINGS_RAN, b_ALA:BINDINGS_ALA @ WakeUp2(b_RAN,b_ALA)[[mget.sv_min <- mget_sv_min,
                                                  mget.sv_sec <- mget_sv_sec,
                                                  mset.sv_min <- mset_sv_min,
                                                  mset.sv_sec <- mset_sv_sec,
                                                  mget.sv_buzz <- mget_sv_buzz,
                                                  mset.sv_buzz <- mset_sv_buzz]]
m2CF = |~| b_RAN:BINDINGS_RAN @ ( ( Seconds2(b_RAN) [| Sync |] Minutes2(b_RAN) ) \ Sync )
m2aCF = |~| b_RAN:BINDINGS_RAN @ ( ( Seconds2(b_RAN) [| Sync |] Minutes2(b_RAN) ) \ Sync )[[mget.sv_min <- mget_sv_min,
                                                  mget.sv_sec <- mget_sv_sec,
                                                  mset.sv_min <- mset_sv_min,
                                                  mset.sv_sec <- mset_sv_sec]]
m2S = |~| b_RAN:BINDINGS_RAN @ Seconds2(b_RAN)
m2aS = |~| b_RAN:BINDINGS_RAN @ Seconds2(b_RAN)[[mget.sv_min <- mget_sv_min,
                                                 mget.sv_sec <- mget_sv_sec,
                                                 mset.sv_min <- mset_sv_min,
                                                 mset.sv_sec <- mset_sv_sec]]
m2M = |~| b_RAN:BINDINGS_RAN @ Minutes2(b_RAN)
m2aM = |~| b_RAN:BINDINGS_RAN @ Minutes2(b_RAN)[[mget.sv_min <- mget_sv_min,
                                                 mget.sv_sec <- mget_sv_sec,
                                                 mset.sv_min <- mset_sv_min,
                                                 mset.sv_sec <- mset_sv_sec]]
m2HWUok = |~| b_RAN:BINDINGS_RAN, b_ALA:BINDINGS_ALA @ WakeUpOK2(b_RAN,b_ALA)
m2aHWUok = |~| b_RAN:BINDINGS_RAN, b_ALA:BINDINGS_ALA @ WakeUpOK2(b_RAN,b_ALA)[[mget.sv_min <- mget_sv_min,
                                                  mget.sv_sec <- mget_sv_sec,
                                                  mset.sv_min <- mset_sv_min,
                                                  mset.sv_sec <- mset_sv_sec,
                                                  mget.sv_buzz <- mget_sv_buzz,
                                                  mset.sv_buzz <- mset_sv_buzz]]

m3HAC =  |~| b_RAN:BINDINGS_RAN @ AChrono3(b_RAN)
m3aHAC =  |~| b_RAN:BINDINGS_RAN @ AChrono3(b_RAN)[[mget.sv_min <- mget_sv_min,
                                                  mget.sv_sec <- mget_sv_sec,
                                                  mset.sv_min <- mset_sv_min,
                                                  mset.sv_sec <- mset_sv_sec]]
m3HC =  |~| b_RAN:BINDINGS_RAN @ Chrono3(b_RAN)
m3aHC =  |~| b_RAN:BINDINGS_RAN @ Chrono3(b_RAN)[[mget.sv_min <- mget_sv_min,
                                                  mget.sv_sec <- mget_sv_sec,
                                                  mset.sv_min <- mset_sv_min,
                                                  mset.sv_sec <- mset_sv_sec]]
m3HWU =  |~| b_RAN:BINDINGS_RAN, b_ALA:BINDINGS_ALA @ WakeUp3(b_RAN,b_ALA)
m3aHWU =  |~| b_RAN:BINDINGS_RAN, b_ALA:BINDINGS_ALA @ WakeUp3(b_RAN,b_ALA)[[mget.sv_min <- mget_sv_min,
                                                  mget.sv_sec <- mget_sv_sec,
                                                  mset.sv_min <- mset_sv_min,
                                                  mset.sv_sec <- mset_sv_sec,
                                                  mget.sv_buzz <- mget_sv_buzz,
                                                  mset.sv_buzz <- mset_sv_buzz]]
m3CF =  |~| b_RAN:BINDINGS_RAN @ ( ( Seconds3(b_RAN) [| Sync |] Minutes3(b_RAN) ) \ Sync )
m3aCF =  |~| b_RAN:BINDINGS_RAN @ ( ( Seconds3(b_RAN) [| Sync |] Minutes3(b_RAN) ) \ Sync )[[mget.sv_min <- mget_sv_min,
                                                  mget.sv_sec <- mget_sv_sec,
                                                  mset.sv_min <- mset_sv_min,
                                                  mset.sv_sec <- mset_sv_sec]]
m3S =  |~| b_RAN:BINDINGS_RAN @ Seconds3(b_RAN)
m3aS =  |~| b_RAN:BINDINGS_RAN @ Seconds3(b_RAN)[[mget.sv_min <- mget_sv_min,
                                                 mget.sv_sec <- mget_sv_sec,
                                                 mset.sv_min <- mset_sv_min,
                                                 mset.sv_sec <- mset_sv_sec]]
m3M =  |~| b_RAN:BINDINGS_RAN @ Minutes3(b_RAN)
m3aM =  |~| b_RAN:BINDINGS_RAN @ Minutes3(b_RAN)[[mget.sv_min <- mget_sv_min,
                                                 mget.sv_sec <- mget_sv_sec,
                                                 mset.sv_min <- mset_sv_min,
                                                 mset.sv_sec <- mset_sv_sec]]
m3HWUok =  |~| b_RAN:BINDINGS_RAN, b_ALA:BINDINGS_ALA @ WakeUpOK3(b_RAN,b_ALA)
m3aHWUok =  |~| b_RAN:BINDINGS_RAN, b_ALA:BINDINGS_ALA @ WakeUpOK3(b_RAN,b_ALA)[[mget.sv_min <- mget_sv_min,
                                                  mget.sv_sec <- mget_sv_sec,
                                                  mset.sv_min <- mset_sv_min,
                                                  mset.sv_sec <- mset_sv_sec,
                                                  mget.sv_buzz <- mget_sv_buzz,
                                                  mset.sv_buzz <- mset_sv_buzz]]

m4HAC =  |~| b_RAN:BINDINGS_RAN @ AChrono4(b_RAN)
m4aHAC =  |~| b_RAN:BINDINGS_RAN @ AChrono4(b_RAN)[[mget_sv_min <- mget.sv_min,
                                                  mget_sv_sec <- mget.sv_sec,
                                                  mset_sv_min <- mset.sv_min,
                                                  mset_sv_sec <- mset.sv_sec]]
m4HC =  |~| b_RAN:BINDINGS_RAN @ Chrono4(b_RAN)
m4aHC =  |~| b_RAN:BINDINGS_RAN @ Chrono4(b_RAN)[[mget_sv_min <- mget.sv_min,
                                                  mget_sv_sec <- mget.sv_sec,
                                                  mset_sv_min <- mset.sv_min,
                                                  mset_sv_sec <- mset.sv_sec]]
m4HWU =  |~| b_RAN:BINDINGS_RAN, b_ALA:BINDINGS_ALA @ WakeUp4(b_RAN,b_ALA)
m4aHWU =  |~| b_RAN:BINDINGS_RAN, b_ALA:BINDINGS_ALA @ WakeUp4(b_RAN,b_ALA)[[mget_sv_min <- mget.sv_min,
                                                  mget_sv_sec <- mget.sv_sec,
                                                  mset_sv_min <- mset.sv_min,
                                                  mset_sv_sec <- mset.sv_sec,
                                                  mget_sv_buzz <- mget.sv_buzz,
                                                  mset_sv_buzz <- mset.sv_buzz]]
m4HWUok =  |~| b_RAN:BINDINGS_RAN, b_ALA:BINDINGS_ALA @ WakeUpOK4(b_RAN,b_ALA)
m4aHWUok =  |~| b_RAN:BINDINGS_RAN, b_ALA:BINDINGS_ALA @ WakeUpOK4(b_RAN,b_ALA)[[mget_sv_min <- mget.sv_min,
                                                  mget_sv_sec <- mget.sv_sec,
                                                  mset_sv_min <- mset.sv_min,
                                                  mset_sv_sec <- mset.sv_sec,
                                                  mget_sv_buzz <- mget.sv_buzz,
                                                  mset_sv_buzz <- mset.sv_buzz]]
m4CF =  |~| b_RAN:BINDINGS_RAN @ ( ( Seconds4(b_RAN) [| Sync |] Minutes4(b_RAN) ) \ Sync )
m4aCF =  |~| b_RAN:BINDINGS_RAN @ ( ( Seconds4(b_RAN) [| Sync |] Minutes4(b_RAN) ) \ Sync )[[mget_sv_min <- mget.sv_min,
                                                  mget_sv_sec <- mget.sv_sec,
                                                  mset_sv_min <- mset.sv_min,
                                                  mset_sv_sec <- mset.sv_sec]]
m4S =  |~| b_RAN:BINDINGS_RAN @ Seconds4(b_RAN)
m4aS =  |~| b_RAN:BINDINGS_RAN @ Seconds4(b_RAN)[[mget_sv_min <- mget.sv_min,
                                                  mget_sv_sec <- mget.sv_sec,
                                                  mset_sv_min <- mset.sv_min,
                                                  mset_sv_sec <- mset.sv_sec]]
m4M =  |~| b_RAN:BINDINGS_RAN @ Minutes4(b_RAN)
m4aM =  |~| b_RAN:BINDINGS_RAN @ Minutes4(b_RAN)[[mget_sv_min <- mget.sv_min,
                                                  mget_sv_sec <- mget.sv_sec,
                                                  mset_sv_min <- mset.sv_min,
                                                  mset_sv_sec <- mset.sv_sec]]
